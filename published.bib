%Brand New PEM papers

@inproceedings{lerner2007searching,
 author = {Lerner, Benjamin S. and Flower, Matthew and Grossman, Dan and Chambers, Craig},
 title = {Searching for Type-error Messages},
 booktitle = {Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '07},
 year = {2007},
 isbn = {978-1-59593-633-2},
 location = {San Diego, California, USA},
 pages = {425--434},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1250734.1250783},
 doi = {10.1145/1250734.1250783},
 acmid = {1250783},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {error messages, objective Caml, seminal, type-checking, type-inference},
} 

@article{scholtz1993using,
  title={Using Unfamiliar Programming Languages: The Effects on Expertise},
  author={Scholtz, Jean and Wiedenbeck, Susan},
  journal={Interacting with Computers},
  volume={5},
  number={1},
  pages={13--30},
  year={1993},
  publisher={Elsevier}
}

@inproceedings{seo2014programmers,
address = {New York, New York, USA},
author = {Seo, Hyunmin and Sadowski, Caitlin and Elbaum, Sebastian and Aftandilian, Edward and Bowdidge, Robert},
booktitle = {Proceedings of the 36th International Conference on Software Engineering - ICSE 2014},
doi = {10.1145/2568225.2568255},
isbn = {9781450327565},
pages = {724--734},
publisher = {ACM Press},
title = {{Programmers' Build Errors: A Case Study (at Google)}},
url = {http://dl.acm.org/citation.cfm?doid=2568225.2568255},
year = {2014}
}

@article{wong2019syntax,
abstract = {One problem when studying how to find and fix syntax errors is how to get natural and representative examples of syntax errors. Most syntax error datasets are not free, open, and public, or they are extracted from novice programmers and do not represent syntax errors that the general population of developers would make. Programmers of all skill levels post questions and answers to Stack Overflow which may contain snippets of source code along with corresponding text and tags. Many snippets do not parse, thus they are ripe for forming a corpus of syntax errors and corrections. Our primary contribution is an approach for extracting natural syntax errors and their corresponding human made fixes to help syntax error research. A Python abstract syntax tree parser is used to determine preliminary errors and corrections on code blocks extracted from the SOTorrent data set. We further analyzed our code by executing the corrections in a Python interpreter. We applied our methodology to produce a public data set of 62,965 Python Stack Overflow code snippets with corresponding tags, errors, and stack traces. We found that errors made by Stack Overflow users do not match errors made by student developers or random mutations, implying there is a serious representativeness risk within the field. Finally we share our dataset openly so that future researchers can re-use and extend our syntax errors and fixes.},
archivePrefix = {arXiv},
arxivId = {1907.07803},
author = {Wong, Alexander William and Salimi, Amir and Chowdhury, Shaiful and Hindle, Abram},
eprint = {1907.07803},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Wong et al. - 2019 - Syntax and Stack Overflow A Methodology for Extracting a Corpus of Syntax Errors and Fixes.pdf:pdf},
month = {Jul},
title = {{Syntax and Stack Overflow: A Methodology for Extracting a Corpus of Syntax Errors and Fixes}},
url = {http://arxiv.org/abs/1907.07803},
year = {2019}
}

@article{mccall2019new,
abstract = {The types of programming errors that novice programmers make and struggle to resolve have long been of interest to researchers. Various past studies have analyzed the frequency of compiler diagnostic messages. This information, however, does not have a direct correlation to the types of errors students make, due to the inaccuracy and imprecision of diagnostic messages. Furthermore, few attempts have been made to determine the severity of different kinds of errors in terms other than frequency of occurrence. Previously, we developed a method for meaningful categorization of errors, and produced a frequency distribution of these error categories; in this article, we extend the previous method to also make a determination of error difficulty, in order to give a better measurement of the overall severity of different kinds of errors. An error category hierarchy was developed and validated, and errors in snapshots of students source code were categorized accordingly. The result is a frequency table of logical error categories rather than diagnostic messages. Resolution time for each of the analyzed errors was calculated, and the average resolution time for each category of error was determined; this defines an error difficulty score. The combination of frequency and difficulty allow us to identify the types of error that are most problematic for novice programmers. The results show that ranking errors by severity (a product of frequency and difficulty) yields a significantly different ordering than ranking them by frequency alone, indicating that error frequency by itself may not be a suitable indicator for which errors are actually the most problematic for students.},
archivePrefix = {arXiv},
arxivId = {10.1145/3335814},
author = {McCall, Davin and K{\"{o}}lling, Michael},
doi = {10.1145/3335814},
eprint = {3335814},
file = {::},
journal = {ACM Transactions on Computing Education},
keywords = {difficulties,empirical},
mendeley-tags = {difficulties,empirical},
number = {4},
pages = {1--30},
primaryClass = {10.1145},
title = {{A New Look at Novice Programmer Errors}},
volume = {19},
year = {2019}
}


%%%STRUCTURE OF THIS FILE IS:
% original corpus
% semi-systematic search results
% overlapping (those in both of the above)
% external refs

%%%BEGIN FILE%%%

%% DUPLICATE ENTRIES, COMMENTED FOR NOW. I AM KEEPING THE KEYS SINCE IT IS NOT CLEAR WHICH SECTION THEY BELONG TO. -- AMEY
%% article{buxton1987experiment,
%% inproceedings{becker2016effectiveSIGCSE,
%% article{brown2018ten,
    


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Original Corpus
%%NEW PAPERS DIRECTLY RELATED TO PROGRAMMING ERROR MESSAGES CAN GO HERE
%%NEW PAPERS NEED TO GO AT THE TOP, RIGHT BELOW THIS COMMENT, BEFORE THE "END NEW ORIGINAL (PEM) PAPERS" COMMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%BEGIN NEW ORIGINAL (PEM) PAPERS

@inproceedings{ahmed2019targeted,
 title={Targeted Example Generation for Compilation Errors},
 author={Umair Z. Ahmed and Renuka Sindhgatta and Nisheeth Srivastava and Amey Karkare},
 booktitle = {Proceedings of the 34th ACM/IEEE International Conference on Automated Software Engineering},
 series = {ASE '19},
 year = {2019},
 publisher = {ACM},
 numpages={12},
 address = {New York, NY, USA},
 keywords = {Android, linters, performance, static analysis},
}

@inproceedings{becker2019parlez-vous,
author = {Becker, Brett A.},
title = {{Parlez-vous Java? Bonjour La Monde != Hello World: Barriers to Programming Language Acquisition for Non-Native English Speakers}},
booktitle = {Proceedings of the 30th Annual Conference of the Psychology of Programming Interest Group (PPIG '19)},
year = {2019},
url = {http://www.ppig.org/library/paper/parlez-vous-java-bonjour-la-monde-hello-world-barriers-programming-language}{http://www.ppig.org/library/paper/parlez-vous-java-bonjour-la-monde-hello-world-barriers-programming-language}
}

@book{cress1970fortran,
 address = {Englewood Cliffs, New Jersey},
 author = {Cress, Paul and Dirksen, Paul and Graham, Wesley J},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Cress, Dirksen, Graham - 1970 - FORTRAN IV With WATFOR and WATFIV.pdf:pdf},
 keywords = {difficulties,enhancement},
 mendeley-tags = {enhancement,difficulties},
 publisher = {Prentice-Hall},
 title = {{FORTRAN IV With WATFOR and WATFIV}},
 year = {1970},
 isbn = {0133294331},
}

@article{dean1982how,
 abstract = {I would now like to summarize briefly what has been discussed. I begand by stating that one cannot produce good messages by just letting them grow like weeds during program development, then rewording them after the fact to make them read well. My experience and reflection have convinced me that, to create messages that work for their intended readers, we must do a number of things: Set human goals for messages. We should first commit ourselves to certain goals. A major goal is to be tolerant of “user errors.” We have to decide how much error-correction the program will do. By anticipating the kinds of mistakes humans will make, we can identify the messages needed to account for those mistakes, as well as for error-free operation.},
 author = {Dean, Morris},
 doi = {10.1147/sj.214.0424},
 issn = {00188670},
 journal = {IBM Systems Journal},
 keywords = {guidelines},
 mendeley-tags = {guidelines},
 number = {4},
 pages = {424--453},
 title = {{How a Computer Should Talk To People.}},
 volume = {21},
 year = {1982}
}

@article{good2017programming,
  title={Programming Language, Natural Language? Supporting the Diverse Computational Activities of Novice Programmers},
  author={Good, Judith and Howland, Kate},
  journal={Journal of Visual Languages \& Computing},
  volume={39},
  pages={78--92},
  year={2017},
  publisher={Elsevier}
}

@MastersThesis{hartz2012catsoop,
 author = {Hartz, Adam, J.},
 title = {{CAT-SOOP: A Tool for Automatic Collection and Assessment of Homework Exercises}},
 school = {Massachusetts Institute of Technology},
 address = {},
 year = {2012},
 keywords = {empirical,enhancement},
 mendeley-tags = {empirical,enhancement},
 url = {https://dspace.mit.edu/bitstream/handle/1721.1/77086/825763362-MIT.pdf?sequence=2},
 abstract = {CAT-SOOP is a tool which allows for automatic collection and assessment of various types of homework exercises. CAT-SOOP is capable of assessing a variety of exercises, including symbolic math and computer programs written in the Python programming language. This thesis describes the design and implementation of the CAT-SOOP system, as well as the methods by which it assesses these various types of exercises. In addition, the implementation of an add-on tool for providing novel forms of feedback about student-submitted computer programs is discussed.}
}

@article{jadud2005first,
author = { Matthew C   Jadud },
title = {A First Look at Novice Compilation Behaviour Using BlueJ},
journal = {Computer Science Education},
volume = {15},
number = {1},
pages = {25-40},
year  = {2005},
publisher = {Routledge},
doi = {10.1080/08993400500056530},
URL = { https://doi.org/10.1080/08993400500056530},
eprint = { https://doi.org/10.1080/08993400500056530},
abstract = {Syntactically correct code does not fall from the sky; the process that leads to a student's first executable program is not well understood. At the University of Kent we have begun to explore the compilation behaviours of novice programmers, or the behaviours that students exhibit while authoring code; in our initial study, we have focused on when and what they choose to compile. By examining these behaviours, we have determined the most common errors encountered by students using BlueJ in our introductory course on object-oriented programming, how those students tend to program when in supervised laboratory sessions, and we have identified future directions of study driven by our initial observations. Our goal is to apply this research to the future development of BlueJ and instructional methodologies involving its use in the classroom. }
}

@article{murphyhill2013interactive,
 abstract = {Some software packages offer the user soft advice: recommendations that are intended to help the user create high-quality artifacts but which may turn out to be bad advice. It is left to the user to determine whether the soft advice really will improve quality and to decide whether to adopt it. Visualizations can help the user in making this decision, but we believe that conventional visualizations are less than ideal. In this article, we describe an interactive ambient visualization to help users identify, understand, and interpret soft advice. Our visualization was developed to help programmers interpret code smells, which are indications that a software project may be suffering from design problems. We describe a laboratory experiment with 12 programmers that tests several hypotheses about our visualization. The findings suggest that our tool helps programmers to identify smells more effectively and to make more informed judgments about the design of the program under development. We then describe an application of our visualization technique in another domain: an English style and grammar advisor. This second application suggests that our technique can be applied to several domains and also suggests how the technique must be varied to make it domain specific.},
 author = {Murphy-Hill, Emerson and Barik, Titus and Black, Andrew P.},
 doi = {10.1177/1473871612469020},
 file = {:Users/brianharrington/Documents/Mendeley Desktop/Murphy-Hill, Barik, Black - 2013 - Interactive ambient visualizations for soft advice.pdf:pdf},
 issn = {14738716},
 journal = {Information Visualization},
 keywords = {Ambient,Code smells,Design,Grammar,Refactoring,Soft advice,Software,Style,Visualization,guidelines},
 mendeley-tags = {guidelines},
 number = {2},
 pages = {107--132},
 title = {{Interactive Ambient Visualizations For Soft Advice}},
 volume = {12},
 year = {2013}
}

@article{murphyhill2012programmer,
 abstract = {Refactoring tools, common to many integrated development environments, can help programmers to restructure their code. These tools sometimes refuse to restructure the programmer's code, instead giving the programmer a textual error message that she must decode if she wishes to understand the reason for the tool's refusal and what corrective action to take. This paper describes a graphical alternative to textual error messages called Refactoring Annotations. It reports on two experiments, one using an integrated development environment and the other using paper mockups, that show that programmers can use Refactoring Annotations to quickly and accurately understand the cause of refactoring errors. {\textcopyright} 2012 IEEE.},
 author = {Murphy-Hill, Emerson and Black, Andrew P.},
 doi = {10.1109/TSE.2011.110},
 file = {:Users/brianharrington/Documents/Mendeley Desktop/Murphy-Hill, Black - 2012 - Programmer-friendly refactoring errors.pdf:pdf},
 issn = {00985589},
 journal = {IEEE Transactions on Software Engineering},
 keywords = {Refactoring,guidelines,programmers,refactoring errors,tools,usability},
 mendeley-tags = {guidelines},
 number = {6},
 pages = {1417--1431},
 title = {{Programmer-Friendly Refactoring Errors}},
 volume = {38},
 year = {2012}
}

@article{rosen1965pufft,
author = {Rosen, Saul and Spurgeon, Robert A. and Donnelly, Joel K.},
doi = {10.1145/365660.365671},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Rosen, Spurgeon, Donnelly - 1965 - PUFFT - The Purdue University Fast FORTRAN Translator.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
month = {nov},
number = {11},
pages = {661--666},
title = {{PUFFT - The Purdue University Fast FORTRAN Translator}},
url = {http://portal.acm.org/citation.cfm?doid=365660.365671},
volume = {8},
year = {1965}
}

%%END NEW ORIGINAL (PEM) PAPERS

%BEGIN PAPERS THAT FELL THROUGH THE CRACKS. 
%THESE WERE ON MENDELEY BUT WERE NOT IN ANY OF:
%ORIGINAL, SEMI-SYS, OVERLAPPING, EXTERNAL.

@incollection{horning1976what,
address = {Berlin-Heidelberg},
author = {Horning, James J},
booktitle = {Compiler Construction: An Advanced Course},
editor = {Goos, G and Hartmanis, J},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Horning - 1976 - What the Compiler Should Tell the User.pdf:pdf;::},
keywords = {guidelines,justification,technical},
mendeley-tags = {guidelines,justification,technical},
pages = {525--548},
publisher = {Springer-Verlag},
title = {{What the Compiler Should Tell the User}},
year = {1976}
}

@inproceedings{prather2018metacognitive,
 abstract = {{\textcopyright} 2018 Association for Computing Machinery. Most novice programmers are not explicitly aware of the problemsolving process used to approach programming problems and cannot articulate to an instructor where they are in that process. Many are now arguing that this skill, called metacognitive awareness, is crucial for novice learning. However, novices frequently learn in university CS1 courses that employ automated assessment tools (AATs), which are not typically designed to provide the cognitive scaffolding necessary for novices to develop metacognitive awareness. This paper reports on an experiment designed to understand what difficulties novice programmers currently face when learning to code with an AAT. We describe the experiences of CS1 students who participated in a think-aloud study where they were observed solving a programming problem with an AAT. Our observations show that some students mentally augmented the tool when it did not explicitly support their metacognitive awareness, while others stumbled due to the tool's lack of such support. We use these observations to formulate difficulties faced by novices that lack metacognitive awareness, compare these results to other related studies, and look toward future work in modifying AATs.},
 mendeley-tags = {difficulties,empirical,pedagogy,pre-guidelines,tool},
 author = {Prather, James and Pettit, Raymond and McMurry, Kayla and Peters, Alani and Homer, John and Cohen, Maxine},
 title = {Metacognitive Difficulties Faced by Novice Programmers in Automated Assessment Tools},
 booktitle = {Proceedings of the 2018 ACM Conference on International Computing Education Research},
 series = {ICER '18},
 year = {2018},
 isbn = {978-1-4503-5628-2},
 location = {Espoo, Finland},
 pages = {41--50},
 url = {http://doi.acm.org/10.1145/3230977.3230981},
 doi = {10.1145/3230977.3230981},
 acmid = {3230981},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automated assessment tools, cs1, education, hci, human factors, metacognitive awareness},
}

@article{buxton1987experiment,
 abstract = {Error messages were provoked by making thirteen deliberate errors (if possible) on commercial information retrieval systems, online library catalogues, and information retrieval packages. These messages were examined for friendly' features politeness, specificity, constructiveness, and helpfulness and for unfriendly' features the use of cryptic codes or vocabulary, or language which users might find threatening, domineering, or emotive. A mark was awarded for each friendly feature and deducted for each unfriendly feature. The new version of BLAISE-LINE and Dialog II came out with the best scores (+ 13 and + 11), followed by the Cambridge and York University Library catalogues (both + 10). The worst scores (- 30) were for ECHO and STATUS on Southampton University's computer. It is clear that systems are not as friendly as they could be. Programmers need to see error messages not just as the functional reporting of errors, but as a means of communicating with users to increase their efficiency.},
 author = {Buxton, Andrew and Trenner, Lesley},
 doi = {10.1177/016555158701300403},
 issn = {0165-5515},
 journal = {Journal of Information Science},
 month = {Aug},
 number = {4},
 pages = {197--209},
 title = {{An Experiment to Assess the Friendliness of Error Messages from Interactive Information Retrieval Systems}},
 url = {http://journals.sagepub.com/doi/10.1177/016555158701300403},
 volume = {13},
 year = {1987}
}

%END PAPERS THAT FELL THROUGH THE CRACKS. 
%THESE WERE ON MENDELEY BUT WERE NOT IN ANY OF:
%ORIGINAL, SEMI-SYS, OVERLAPPING, EXTERNAL.

@inproceedings{becker2016effectiveSIGCSE,
 abstract = {One of the many challenges novice programmers face from the time they write their first program is inadequate compiler error messages. These messages report details on errors the programmer has made and are the only feedback the programmer gets from the compiler. For students they play a particularly essential role as students often have little experience to draw upon, leaving compiler error messages as their primary guidance on error correction. However these messages are frequently inadequate, presenting a barrier to progress and are often a source of discouragement. We have designed and implemented an editor that provides enhanced compiler error messages and conducted a controlled empirical study with CS1 students learning Java. We find a reduced frequency of overall errors and errors per student. We also identify eight frequent compiler error messages for which enhancement has a statistically significant effect. Finally we find a reduced number of repeated errors. These findings indicate fewer students struggling with compiler error messages.},
 mendeley-tags = {difficulties,empirical,enhancement,justification},
 author = {Becker, Brett A.},
 title = {An Effective Approach to Enhancing Compiler Error Messages},
 booktitle = {Proceedings of the 47th ACM Technical Symposium on Computing Science Education},
 series = {SIGCSE '16},
 year = {2016},
 isbn = {978-1-4503-3685-7},
 location = {Memphis, Tennessee, USA},
 pages = {126--131},
 url = {http://doi.acm.org/10.1145/2839509.2844584},
 doi = {10.1145/2839509.2844584},
 acmid = {2844584},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compiler errors, cs1, debugging, error messages, errors, feedback, java, novice, programming, syntax errors},
}


@inproceedings{brna1993support,
abstract = {We consider the current state of automated support for novices learning to debug faulty programs. We examine a particular approach embodied in a prototype environment called SWANN. This is derived from the MARCEL model of program construction developed by Spohrer. SWANN itself provides very simple support for novices trying to debug a faulty program. SWANN can detect a discrepancy between the actual and expected program behaviours. SWANN offers the novice a set of plausible operators which can be applied to try and fix the discrepant behaviour. It is then up to the novice to decide how to continue. We examine this approach for its suitability for further development, and compare it with other possible ways in which novices might be supported.},
annote = {The tool produces suggested fixes to an incorrect program by comparing two graphs - these each correspond to a "plan" (one for the target program and one for the current program). Isomorphic plan graphs indicate the student has a correct solution. The tool suggests changes to the program (which will affect the plan graph).},
author = {Brna, Paul and Mathjeson, Martin},
booktitle = {Proceedings of AI-ED93 (Artificial Intelligence in Education 1993)},
editor = {Brna, P and Ohlsson, S. and Pain, H.},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Brna, Mathjeson - 1993 - Support for Novices Learning to Debug SWANN'S Way.pdf:pdf},
keywords = {anecdotal},
mendeley-tags = {anecdotal},
pages = {505--512},
publisher = {Association for the Advancement of Computing in Education},
title = {{Support for Novices Learning to Debug: SWANN'S Way}},
year = {1993}
}

@inproceedings{price2019progsnap2,
abstract = {In this paper, we introduce ProgSnap2, a standardized format for logging programming process data. The goal of this common format is to encourage collaboration among researchers by helping them to share data, analysis code, and data-driven tools to support students. We first highlight possible use cases for ProgSnap2 and give a high-level overview of the format. We then share two case studies of our experience using the format and outline goals for the future of ProgSnap2, including a call for collaboration with interested researchers.},
address = {Tempe, AZ, USA},
author = {Price, Thomas W and Hovemeyer, David and Rivers, Kelly and Bart, Austin Cory and Petersen, Andrew and Becker, Brett A. and Lefever, Jason},
booktitle = {Proceedings of the Educational Data Mining in Computer Science Workshop in the Companion Proceedings of the International Conference on Learning Analytics and Knowledge (LAK 2019)},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Price et al. - 2019 - ProgSnap2 A Flexible Format for Programming Process Data.pdf:pdf},
keywords = {data sharing,data standards,learning analytics,programming process data,technical,tool},
mendeley-tags = {technical,tool},
pages = {1--7},
title = {{ProgSnap2: A Flexible Format for Programming Process Data}},
url = {https://people.engr.ncsu.edu/twprice/website/files/CSEDM 2019 ProgSnap2.pdf},
year = {2019}
}

@phdthesis{barik2018error,
 abstract = {Program analysis tools apply elegant algorithms such as static analysis, model checking, and type inference on source code to help developers resolve compiler errors, apply optimizations, identify security vulnerabilities, and reason about the logic of the program. In integrated development environments, program analysis tools provide feedback about their internal diagnostics to developers through error messages, using a variety of text and visual presentations such as error listings, tooltips, and source code underlined with red squiggles. The design of human-friendly error messages is important because error messages are the primary communication channel through which tools provide feedback to developers. Despite the intended utility of these tools, the error messages these tools produce are cryptic, frustrating, and generally unhelpful to developers as they attempt to understand and resolve the messages. Existing approaches in programming language research have attempted to surface the internal reasoning process of program analysis tools and present these details to developers to aid their comprehension process. However, we argue that the tool-centric perspective of simply revealing details in the error message about the tools' internal algorithms is insufficient: the fundamental problem is that computational tools do not reason about the causes of an identified error in the same way as the developer who attempts to understand and reconstruct why the tool produced that particular error. The goal of this research is to investigate these misalignments through the theoretical framework of rational reconstruction of a model for identifying rationales, or reasons, for arriving at a particular conclusion to the domain of error messages in program analysis tools. Essentially, a rational reconstruction ofan error message would present rationales to the developer from a human-centered perspective that aligns with the developers' reasoning process, irrespective of the underlying algorithm or process used by the program analysis tool to identify the error. Through rational reconstructions, we can identify how to design error messages that are most useful for developers, rather than those that are most convenient for the tool.},
 address = {Raleigh},
 author = {Barik, Titus},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Barik - 2018 - Error Messages as Rational Reconstructions(2).pdf:pdf},
 keywords = {anecdotal,compilers,design guidelines,difficulties,error messages,explanation,guidelines,program analysis tools,program comprehension,rational reconstruction,technical},
 mendeley-tags = {anecdotal,difficulties,guidelines,technical},
 pages = {271},
 school = {North Carolina State University},
 title = {{Error Messages as Rational Reconstructions}},
 url = {https://repository.lib.ncsu.edu/handle/1840.20/35439},
 year = {2018}
}

@phdthesis{lipman2014learncs,
 abstract = {Students entering introductory college computing courses (commonly known as CS1 courses) that use C as their primary language encounter a number of obstacles, each with its own steep learning curve: students must learn concepts of computational thinking and programming; they must learn the syntax of the C language; they delve into the world of text editors (Emacs, vi) or the sophistication and complexity of advanced IDEs; they may have to learn Linux commands; and they must understand the steps of writing code, compiling, linking, and execution. This is a huge burden to be borne all at one time by the aspiring computer science student. LearnCS! is a learning environment specifically written for use by introductory computer science students. It provides students with a browser-based programming and execution environment which contains a depiction of the notional machine for the C language, and contains a built-in debugger. Many error messages are customized to assist the beginning student of computer science. These features have yielded good results in improving students comprehension of CS1 concepts. In addition to its direct benefits to students, LearnCS! is designed as a research plat- form, to help discover areas in which students have difficulty, and to explore alternative methods or orders of teaching the topics of the CS1 course. An initial research study has been completed. The premise of this study is that CS1 students' programming ability is improved by learning and practicing debugging with a breakpoint debugger beginning early in the CS1 semester. This dissertation describes the pedagogical and research features of LearnCS!, reviews related work, and provides recommendations for CS1 instructors and for future, related work. LearnCS! is shown to have accomplished its goals of providing a low bar to entry development environment for CS1. Furthermore, the Debugging Early study ascertained that students who learned and received practice with a breakpoint debugger from early in the CS1 semester were statistically significantly more likely to succeed in completing their lab work than students who did not receive that early practice.},
 annote = {Chapter 6, pg. 49, is "Error messages for novices"},
 author = {Lipman, Derrell},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Lipman - 2014 - LEARNCS! A BROWSER-BASED RESEARCH PLATFORM FOR CS1 AND STUDYING THE ROLE OF INSTRUCTION OF DEBUGGING FROM EARLY IN THE C.pdf:pdf},
 keywords = {difficulties,empirical,enhancement,justification,pedagogy},
 mendeley-tags = {difficulties,empirical,enhancement,justification,pedagogy},
 school = {University of Massachusetts Lowell},
 title = {{LearnCS! a Browser-Based Research Platform for CS1 and Studying the Role of Instruction of Debugging from Early in the Course}},
 year = {2014}
}

@article{Learning2003Robins,
 abstract = {In this paper we review the literature relating to the psychological/educational study of programming. We identify general trends comparing novice and expert programmers, programming knowledge and strategies, program generation and comprehension, and object- oriented versus procedural programming. (We do not cover research relating specifically to other programming styles.) The main focus of the review is on novice programming and topics relating to novice teaching and learning. Various problems experienced by novices are identified, including issues relating to basic program design, to algorithmic complexity in certain language features, to the fragility'' of novice knowledge, and so on.We summarise this material and suggest some practical implications for teachers.We suggest that a key issue that emerges is the distinction between effective and ineffective novices. What characterises effective novices? Is it possible to identify the specific deficits of ineffective novices and help them to become effective learners of programming?},
 author = {Robins, Anthony and Rountree, Janet and Rountree, Nathan},
 doi = {10.1076/csed.13.2.137.14200},
 file = {::},
 issn = {0899-3408},
 journal = {Computer Science Education},
 keywords = {difficulties,pedagogy},
 mendeley-tags = {difficulties,pedagogy},
 number = {2},
 pages = {137--172},
 title = {{Learning and Teaching Programming: A Review and Discussion}},
 url = {https://www.tandfonline.com/doi/full/10.1076/csed.13.2.137.14200},
 volume = {13},
 year = {2003}
}

@inproceedings{parr2011ll,
 abstract = {Despite the power of Parser Expression Grammars (PEGs) and GLR, parsing is not a solved problem. Adding nondeterminism (parser speculation) to traditional LL and LR parsers can lead to unexpected parse-time behavior and introduces practical issues with error handling, single-step debugging, and side-effecting embedded grammar actions. This paper introduces the LL(*) parsing strategy and an associated grammar analysis algorithm that constructs LL(*) parsing decisions from ANTLR grammars. At parse-time, decisions gracefully throttle up from conventional fixed k>=1 lookahead to arbitrary lookahead and, finally, fail over to backtracking depending on the complexity of the parsing decision and the input symbols. LL(*) parsing strength reaches into the context-sensitive languages, in some cases beyond what GLR and PEGs can express. By statically removing as much speculation as possible, LL(*) provides the expressivity of PEGs while retaining LL's good error handling and unrestricted grammar actions. Widespread use of ANTLR (over 70,000 downloads/year) shows that it is effective for a wide variety of applications.},
 mendeley-tags = {technical},
 author = {Parr, Terence and Fisher, Kathleen},
 title = {LL(*): The Foundation of the ANTLR Parser Generator},
 booktitle = {Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '11},
 year = {2011},
 isbn = {978-1-4503-0663-8},
 location = {San Jose, California, USA},
 pages = {425--436},
 url = {http://doi.acm.org/10.1145/1993498.1993548},
 doi = {10.1145/1993498.1993548},
 acmid = {1993548},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {augmented transition networks, backtracking, context-sensitive parsing, deterministic finite automata, glr, memoization, nondeterministic parsing, peg, semantic predicates, subset construction, syntactic predicates},
}

@article{zhang2007towards,
abstract = {Execution omission errors are known to be difficult to locate using dynamic analysis. These errors lead to a failure at runtime because of the omission of execution of some statements that would have been executed if the program had no errors. Since dynamic anal- ysis is typically designed to focus on dynamic information arising from executed statements, and statements whose execution is omitted do not produce dynamic information, detection of execution omission errors becomes a challenging task. For example, while dynamic slices are very effective in capturing faulty code for other types of errors, they fail to capture faulty code in presence of execution omission errors. To address this issue relevant slices have been defined to consider certain static dependences (called potential dependences) in addition to dynamic dependences. However, due to the conservative nature of static analysis, overly large slices are produced. In this paper, we propose a fully dynamic solution to locating execution omission errors using dynamic slices.We in- troduce the notion of implicit dependences which are dependences that are normally invisible to dynamic slicing due to the omission of execution of some statements.We design a dynamic method that forces the execution of the omitted code by switching outcomes of relevant predicates such that those implicit dependences are ex- posed and become available for dynamic slicing. Dynamic slices can be computed and effectively pruned to produce fault candidate sets containing the execution omission errors. We solve two main problems: verifying the existence of a single implicit depen- dence through predicate switching, and recovering the implicit dependences in a demand driven manner such that a small number of verifications are required before the root cause is captured. Our experiments show that the proposed technique is highly effective in capturing execution omission errors.},
author = {Zhang, Xiangyu and Tallam, Sriraman and Gupta, Neelam and Gupta, Rajiv},
doi = {10.1145/1273442.1250782},
file = {::},
isbn = {9781595936332},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {all or part of,and predicate switching,classroom use is granted,copies are not made,debugging,execution omission,im-,or,or distributed,or hard copies of,permission to make digital,plicit dependence,potential dependence,relevant slicing,technical,this work for personal,without fee provided that},
mendeley-tags = {technical},
number = {6},
pages = {415},
title = {{Towards locating execution omission errors}},
volume = {42},
year = {2007}
}
@inproceedings{soloway2004workshop,
abstract = {This volume studies programmers to gain insights to facilitate improved productivity and quality software. The chapters cover a range of topics including cognitive models of programming; measuring program complexity; and the effects of program style and structure on program comprehension.},
author = {Soloway, Eliot},
booktitle = {ACM SIGSOFT Software Engineering Notes},
doi = {10.1145/382298.382366},
issn = {01635948},
keywords = {pedagogy},
mendeley-tags = {pedagogy},
number = {5},
pages = {38},
title = {{Workshop on empirical studies of programmers}},
volume = {11},
year = {2004}
}

@phdthesis{kohn2017teaching,
 abstract = {One of the great challenges in teaching to program is to help students understand how programming actually works. Students unavoidably develop misconceptions during their learning process, which must be corrected through skillful feedback. Such misconceptions reach from rather simple syntactical problems to deep underlying misunderstandings about what a compu- tational machine is, and how it works. With the objective to assist the students in developing correct mental models, we must understand these misconceptions, and how to correct them. An example of a misconception about the syntax is the well-documented problem that the assignment operator is believed to be symmetric, i. e., 2 = x is seen as equivalent to x = 2. At the other end of the spectrum, we find fundamental misconceptions about the computational machine itself. One such misconception is to apply a model of mathematical procedure to the computational machine, and thereby attribute algebraic capabilities to the machine. This is evidenced by the belief that the statement y = 2*x establishes a link between the two variables x and y, so that any change of x is subsequently also reflected by y. The primary and foremost means to detect misconceptions is through careful analysis of the students' mistakes and errors. While some errors lead to syntactically incorrect programs, which are not even accepted by the computer, and therefore quickly recognized, other errors show themselved in incorrect outputs once the program is run. However, the main question to answer is: what can we infer about a student's mental models and misconceptions from his or her errors? This dissertation investigates the errors of novice programming students in high school. In particular, it provides evidence that some students apply a model of mathematical substitution when reasoning about variables in a program. This misconception is relevant as it directly per- tains the sequential nature and data abstraction as employed in imperative computer programming; in fact, variables are a core concept in imperative programming. However, the dissertation also proposes a teaching method to specifically overcome this misconception by carefully addressing it in the classroom. Preliminary results are promising, and indicate that such dedicated teaching might indeed be effective. During a period of five years, we have collected erroneous program of novice programming high school students. Based on this collection, the dissertation includes a list of common student errors. While there are several such collections of student errors already available, this dissertation provides the first collection based on the programming language Python. Python has recently become a popular programming language for introductory courses. At the same time, it differs significantly from more traditional programming languages such as Java, in both syntax and execution model. Hence, many previously documented errors do not apply equally to Python. Finally, the dissertation describes a parser for Python programs, capable of recognizing various error patterns, as documented in the collection of student errors. The parser has been implemented as part of the educational Python environment TigerJython, which has already found widespread use. Moreover, with the possibility to discern different errors more accurately than what traditional Python environments provide, future research can study the relationships between the observed errors and the underlying misconce},
 annote = {8.4 Do Error Messages Help the Student},
 author = {Kohn, Tobias},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Kohn - Unknown - Teaching Python Programming to Novices Addressing Misconceptions and Creating a Development Environment.pdf:pdf},
 keywords = {empirical,justification},
 mendeley-tags = {empirical,justification},
 school = {ETH Z{\"{u}}rich},
 title = {{Teaching Python Programming to Novices: Addressing Misconceptions and Creating a Development Environment}},
 type = {PhD Thesis},
 year = {2017}
}

@inproceedings{simon2008saying,
abstract = {Jane sees 50 compiler errors as a challenge. John sees them as defeat. Psychology research suggests these contrasting reactions may stem from students' self-theories, or their beliefs about themselves. Jane's reaction is characteristic of a growth mindset, the idea that with hard work and persistence, one's intelligence can increase. John's behavior is in line with a fixed mindset, the belief that individuals are born with a certain amount of intelligence and there is little they can do to change it. Numerous studies of self-theories have shown that students with a growth mindset perform better in academic settings; they cope more effectively with challenges, maintain higher grades, and are less susceptible to stereotype threat. In this study we attempted a "saying is believing" intervention to encourage CS1 students to adopt a growth mindset both in general and towards programming. Despite notable success of this type of intervention in a non-CS context, our results offered few statistically significant differences both from pre-survey to post-survey and between control and intervention groups. Further, the statistically significant results we did find differed in direction between institutions (some students exhibited more growth response, others less). We analyzed further evidence to explore possible confounding issues including whether our intervention even registered with students and how students interpreted the questions which we used to assess their self-theories.},
address = {Sydney, Australia},
author = {Simon, Beth and Hanks, Brian and Murphy, Laurie and Fitzgerald, Sue and McCauley, Ren{\'e}e and Thomas, Lynda and Zander, Carol},
booktitle = {Fourth International Workshop on Computing Education Research},
doi = {10.1145/1404520.1404537},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Simon et al. - 2008 - Saying Isn't Necessarily Believing Influencing Self-theories in Computing.pdf:pdf},
isbn = {9781605582160},
keywords = {CS0,CS1,Dweck,Likert,Self-theories,attitudinal,debugging,enhancement,growth mindset,novice programmers,programming},
mendeley-tags = {enhancement},
pages = {173--184},
publisher = {ACM},
title = {{Saying Isn't Necessarily Believing: Influencing Self-theories in Computing}},
url = {http://doi.acm.org/10.1145/1404520.1404537},
year = {2008}
}

@inproceedings{ko2004six,
 abstract = {As programming skills increase in demand and utility, the learnability of end-user programming systems is of utmost importance. However, research on learning barriers in programming systems has primarily focused on languages, overlooking potential barriers in the environment and accompanying libraries. To address this, a study of beginning programmers learning Visual Basic.NET was performed. This identified six types of barriers: design, selection, coordination, use, understanding, and information. These barriers inspire a new metaphor of computation, which provides a more learner-centric view of programming system design. 1. Introduction According to the U.S. Departm},
 author = {Ko, Amy J and Myers, Brad A and Aung, Htet Htet},
 doi = {10.1109/VLHCC.2004.47},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Ko, Myers, Aung - 2004 - Six Learning Barriers in End-User Programming Systems Prior Research on Learning Barriers A Study of Visual Bas.pdf:pdf},
 isbn = {0-7803-8696-5},
 booktitle = {Proceedings of IEEE Symposium on Visual Languages and Human-Centric Computing},
 series = {VLHCC '04},
 keywords = {difficulties,justification,pedagogy,pre-guidelines,runtime-errors},
 mendeley-tags = {difficulties,justification,pedagogy,pre-guidelines,runtime-errors},
 pages = {199--206},
 title = {{Six Learning Barriers in End-User Programming Systems Prior Research on Learning Barriers A Study of Visual Basic . NET 2003}},
 url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1372321},
 year = {2004}
}

@article{barr2016using,
abstract = {T his experiential paper focuses on CodeLab, a tool for improving student learning in CS1. We introduce the basic features of CodeLab, both from the student and instructor side, discuss the use of CodeLab at two different types of institutions, and compare CodeLab to other interactive programming tutor products (CodingBat, Problets, zyBooks, and Python Tutor) that we have used in the last academic year.},
author = {Barr, Valerie and Trytten, Deborah},
doi = {10.1145/2903724},
file = {::},
issn = {21532184},
journal = {ACM Inroads},
keywords = {anecdotal},
mendeley-tags = {anecdotal},
month = {May},
number = {2},
pages = {67--75},
title = {{Using turing's craft codelab to support CS1 students as they learn to program}},
url = {http://dl.acm.org/citation.cfm?doid=2938622.2903724},
volume = {7},
year = {2016}
}

@inproceedings{tabanao2011predicting,
 abstract = {In this study, we attempted to quantify indicators of novice programmer progress in the task of writing programs,and we evaluated the use of these indicators for identifying academically at-risk students. Over the course of nine weeks, students completed five different graded programming exercises in a computer lab. Using an instrumented version of BlueJ, an integrated development environment for Java, we collected novice compilations and explored the errors novices encountered, the locations of these errors, and the frequency with which novices compiled their programs.We identified which frequently encountered errors and which compilation behaviorswere characteristic of at-risk students. Based on these findings, we developed linear regression models that allowed prediction of scores on a midterm exam. However, the models derived could not accurately predict the at-risk students. Although our goal of identifying at-risk students was not attained, we have gained insightsregarding the compilation behavior of our students, which may help us identify students who are in need of intervention. Categories},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Tabanao, Rodrigo, Jadud - 2011 - Predicting at-risk novice Java programmers through the analysis of online protocols.pdf:pdf},
 mendeley-tags = {empirical,justification,performance},
 author = {Tabanao, Emily S. and Rodrigo, Ma. Mercedes T. and Jadud, Matthew C.},
 title = {Predicting At-risk Novice Java Programmers Through the Analysis of Online Protocols},
 booktitle = {Proceedings of the 7th International Workshop on Computing Education Research},
 series = {ICER '11},
 year = {2011},
 isbn = {978-1-4503-0829-8},
 location = {Providence, Rhode Island, USA},
 pages = {85--92},
 url = {http://doi.acm.org/10.1145/2016911.2016930},
 doi = {10.1145/2016911.2016930},
 acmid = {2016930},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {achievement, compilation behavior, cs1, java programming, novice programmers},
 }

@article{mccracken2001multi-national,
 abstract = {In computer science, an expected outcome of a student's education is programming skill. This working group investigated the programming competency students have as they complete their first one or two courses in computer science. In order to explore options for assessing students, the working group developed a trial assessment of whether students can program. The underlying goal of this work was to initiate dialog in the Computer Science community on how to develop these types of assessments. Several universities participated in our trial assessment and the disappointing results suggest that many students do not know how to program at the conclusion of their introductory courses. For a combined sample of 216 students from four universities, the average score was 22.89 out of 110 points on the general evaluation criteria developed for this study. From this trial assessment we developed a framework of expectations for first-year courses and suggestions for further work to develop more comprehensive assessments.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/McCracken et al. - 2001 - A multi-national, multi-institutional study of assessment of programming skills of first-year CS students(2).pdf:pdf},
 mendeley-tags = {difficulties,justification},
 author = {McCracken, Michael and Almstrum, Vicki and Diaz, Danny and Guzdial, Mark and Hagan, Dianne and Kolikant, Yifat Ben-David and Laxer, Cary and Thomas, Lynda and Utting, Ian and Wilusz, Tadeusz},
 title = {A Multi-national, Multi-institutional Study of Assessment of Programming Skills of First-year CS Students},
 journal = {SIGCSE Bull.},
 issue_date = {December 2001},
 volume = {33},
 number = {4},
 month = Dec,
 year = {2001},
 issn = {0097-8418},
 pages = {125--180},
 url = {http://doi.acm.org/10.1145/572139.572181},
 doi = {10.1145/572139.572181},
 acmid = {572181},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@book{santos2018syntax,
 abstract = {Syntax errors are made by novice and experienced programmers alike; however, novice programmers lack the years of experience that help them quickly resolve these frustrating errors. Standard LR parsers are of little help, typically resolving syntax errors and their precise location poorly. We propose a methodology that locates where syntax errors occur, and suggests possible changes to the token stream that can fix the error identified. This methodology finds syntax errors by using language models trained on correct source code to find tokens that seem out of place. Fixes are synthesized by consulting the language models to determine what tokens are more likely at the estimated error location. We compare n-gram and LSTM (long short-term memory) language models for this task, each trained on a large corpus of Java code collected from GitHub. Unlike prior work, our methodology does not rely that the problem source code comes from the same domain as the training data. We evaluated against a repository of real student mistakes. Our tools are able to find a syntactically-valid fix within its top-2 suggestions, often producing the exact fix that the student used to resolve the error. The results show that this tool and methodology can locate and suggest corrections for syntax errors. Our methodology is of practical use to all programmers, but will be especially useful to novices frustrated with incomprehensible syntax errors.},
 annote = {Since this paper talks about Corrections of errors, I am tagging it as "enhancement", even though it does not really change the error messages.},
 author = {{Eddie Antonio Santos, Joshua Charles Campbell, Dhvani Patel, Abram Hindle}, and Jos{\'{e}} Nelson Amaral},
 booktitle = {25th IEEE International Conference on Software Analysis, Evolution, and Reengineering : SANER 2018 : Campobasso, Italy},
 file = {::},
 isbn = {9781538649695},
 keywords = {empirical,enhancement,technical},
 mendeley-tags = {empirical,enhancement,technical},
 pages = {311--322},
 title = {{Syntax and Sensibility: Using Language Models to Detect and Correct Syntax Errors}},
 year = {2018}
}

@inproceedings{odekirk-hash2004automated,
 abstract = {Many educators believe that the most effective means of teaching is through one-on-one interactions with students. It is not surprising, then, that an effective way to teach programming is to give students immediate feedback on programs that they have just written. Unfortunately, such one-on-one teaching scenarios are becoming increasingly difficult to arrange. We built InSTEP, an online tutoring system for beginning C programmers, to see whether an automated system could provide effective immediate feedback to beginning programming students. In an introductory programming course, we compared two groups of students. One group solved six programming problems with feedback from InSTEP; the second group solved the same six problems without feedback from InSTEP; both groups had access to feedback from teaching assistants. While both groups of students took about the same amount of time to complete the problems and performed about the same on a subsequent test, the students who received feedback from InSTEP spent less than a third of the time asking the teaching assistants questions than did the others.},
 mendeley-tags = {empirical,enhancement},
 author = {Odekirk-Hash, Elizabeth and Zachary, Joseph L.},
 title = {Automated Feedback on Programs Means Students Need Less Help from Teachers},
 booktitle = {Proceedings of the Thirty-second SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '01},
 year = {2001},
 isbn = {1-58113-329-4},
 location = {Charlotte, North Carolina, USA},
 pages = {55--59},
 url = {http://doi.acm.org/10.1145/364447.364537},
 doi = {10.1145/364447.364537},
 acmid = {364537},
 publisher = {ACM},
 address = {New York, NY, USA},
}}

@article{morales2019programmer,
abstract = {Programmers use various software development artifacts in their work, such as programming environments, design documents, and programming codes. These software artifacts can be studied and improved based on usability and User eXperience (UX) factors. In this work, we consider programmers to be a specific case of users and analyze different elements that influence their experience in this specific context. We conducted a systematic literature review of papers published over the last 10 years related to: (i) the definition of the Programmer eXperience (PX); (ii) the PX, UX, and usability factors regarding the programming environments, design documents, and programming codes; and (iii) sets of heuristics to evaluate the software development artifacts mentioned before. We analyzed 73 articles, and the results obtained show: (i) the important elements that influence the PX are the motivation of programmers and the choice of tools they use in their work, such as programming environments; (ii) most of the identified studies (59%) aimed to evaluate the influence of the PX, UX, and usability on programming environments; (iii) the majority of the studies (70%) used methods such as usability tests and/or heuristic evaluation methods; (iv) 4 sets of heuristics are used to evaluate software development artifacts in relation to programming environments, programming languages and application programming interfaces. The results suggest that further research in this area is necessary to better understand and evaluate the concept of the PX.},
author = {Morales, J. and Rusu, C. and Botella, F. and Quinones, D.},
doi = {10.1109/ACCESS.2019.2920124},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Morales et al. - 2019 - Programmer eXperience A Systematic Literature Review.pdf:pdf},
issn = {2169-3536},
journal = {IEEE Access},
keywords = {Heuristic evaluation,Programmer eXperience,Systematic Literature Review,Usability,User,eXperience,gen-lit,justification},
mendeley-tags = {gen-lit,justification},
number = {c},
pages = {1--1},
title = {{Programmer eXperience: A Systematic Literature Review}},
url = {https://ieeexplore.ieee.org/document/8727527/},
volume = {3536},
year = {2019}
}

@inproceedings{lee2011personifying,
 abstract = {Many novice programmers view programming tools as all-knowing, infallible authorities about what is right and wrong about code. This misconception is particularly detrimental to beginners, who may view the cold, terse, and often judgmental errors from compilers as a sign of personal failure. It is possible, however, that attributing this failure to the computer, rather than the learner, may improve learners' motivation to program. To test this hypothesis, we present Gidget, a game where the eponymous robot protagonist is cast as a fallible character that blames itself for not being able to correctly write code to complete its missions. Players learn programming by working with Gidget to debug its problematic code. In a two-condition controlled experiment, we manipulated Gidget's level of personification in: communication style, sound effects, and image. We tested our game with 116 self-described novice programmers recruited on Amazon's Mechanical Turk and found that, when given the option to quit at any time, those in the experimental condition (with a personable Gidget) completed significantly more levels in a similar amount of time. Participants in the control and experimental groups played the game for an average time of 39.4 minutes (SD=34.3) and 50.1 minutes (SD=42.6) respectively. These finding suggest that how programming tool feedback is portrayed to learners can have a significant impact on motivation to program and learning success.},
 mendeley-tags = {difficulties,empirical,enhancement,justification},
 author = {Lee, Michael J. and Ko, Amy J.},
 title = {Personifying Programming Tool Feedback Improves Novice Programmers' Learning},
 booktitle = {Proceedings of the Seventh International Workshop on Computing Education Research},
 series = {ICER '11},
 year = {2011},
 isbn = {978-1-4503-0829-8},
 location = {Providence, Rhode Island, USA},
 pages = {109--116},
 url = {http://doi.acm.org/10.1145/2016911.2016934},
 doi = {10.1145/2016911.2016934},
 acmid = {2016934},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {debugging, education, motivation, personification, programming},
}

@inproceedings{becker201950,
 abstract = {The SIGCSE Technical Symposium is celebrating its 50th year, and a constant theme throughout this history has been to better understand how novices learn to program. In this paper, we present a perspective on the evolution of introductory programming education research at the Symposium over these 50 years. We also situate the Symposium's impact in the context of the wider literature on introductory programming research. Applying a systematic approach to collecting papers presented at the Symposium that focus on novice programming / CS1, we categorized hundreds of papers according to their main focus, revealing important introductory programming topics and their trends from 1970 to 2018. Some of these topics have faded from prominence and are less relevant today while others, including many topics focused on students, such as making learning programming more appropriate from gender, diversity, accessibility and inclusion standpoints, have garnered significant attention more recently. We present discussions on these trends and in doing so, we provide a checkpoint for introductory programming research. This may provide insights for future research on how we teach novices and how they learn to program.},
 mendeley-tags = {justification},
 author = {Becker, Brett A. and Quille, Keith},
 title = {50 Years of CS1 at SIGCSE: A Review of the Evolution of Introductory Programming Education Research},
 booktitle = {Proceedings of the 50th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '19},
 year = {2019},
 isbn = {978-1-4503-5890-3},
 location = {Minneapolis, MN, USA},
 pages = {338--344},
 url = {http://doi.acm.org/10.1145/3287324.3287432},
 doi = {10.1145/3287324.3287432},
 acmid = {3287432},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {cs 1, cs-1, cs1, introduction to programming, introductory programming, novice programming, programming, review, survey},
}

@inproceedings{rigby2005study,
 abstract = {In this paper we discuss a pilot user study that compares the use of two integrated development environments (IDEs), Eclipse and Gild, by novice programmers. Gild is a perspective for Eclipse that is intended to be more suitable for first-year students who are learning how to program in Java. This study focuses on qualitative and quantitative measures; the quantitative measures include: efficiency, effectiveness, satisfaction and understanding. Two statistically significant results are obtained from the satisfaction measure, in particular: the frustration level and the overall level of satisfaction. The mean differences for the remaining measures indicate that Gild was more suitable for novices than Eclipse. Qualitative analysis yields suggestions for improvement for both interfaces and also identifies areas of success.},
 mendeley-tags = {difficulties,pre-guidelines},
 author = {Rigby, Peter C. and Thompson, Suzanne},
 title = {Study of Novice Programmers Using Eclipse and Gild},
 booktitle = {Proceedings of the 2005 OOPSLA Workshop on Eclipse Technology eXchange},
 series = {eclipse '05},
 year = {2005},
 isbn = {1-59593-342-5},
 location = {San Diego, California},
 pages = {105--109},
 url = {http://doi.acm.org/10.1145/1117696.1117718},
 doi = {10.1145/1117696.1117718},
 acmid = {1117718},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {integrated development environment, novice, user study},
}

@article{ala-mutka2005survey,
 abstract = {Practical programming is one of the basic skills pursued in computer science education. On programming courses, the coursework consists of programming assignments that need to be assessed from different points of view. Since the submitted assignments are executable programs with a formal structure, some features can be assessed automatically. The basic requirement for automated assessment is the numerical measurability of assessment targets, but semiautomatic approaches can overcome this restriction. Recognizing automatically assessable features can help teachers to create educational models, where automatic tools let teachers concentrate their work on the learning issues that need student-teacher interaction the most. Several automatic tools for both static and dynamic assessment of computer programs have been reported in the literature. This article promotes these issues by surveying several automatic approaches for assessing programming assignments. Not all the existing tools will be covered, simply because of the vast number of them. The article concentrates on bringing forward different assessment techniques and approaches to give an interested reader starting points for finding further information in the area. Automatic assessment tools can be used to help teachers in grading tasks as well as to support students' working process with automatic feedback. Common advantages of automation are the speed, availability, consistency and objectivity of assessment. However, automatic tools emphasize the need for careful pedagogical design of the assignment and assessment settings. To effectively share the knowledge and good assessment solutions already developed, better interoperability and portability of the tools is needed.},
 author = {Ala-Mutka, Kirsti M},
 doi = {10.1080/08993400500150747},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Ala-Mutka - 2005 - A Survey of Automated Assessment Approaches for Programming  Assignments.pdf:pdf},
 isbn = {0899-3408},
 issn = {0899-3408},
 journal = {Computer Science Education},
 keywords = {enhancement},
 mendeley-tags = {enhancement},
 number = {2},
 pages = {83--102},
 title = {{A Survey of Automated Assessment Approaches for Programming Assignments}},
 volume = {15},
 year = {2005}
}

@article{etheredge2004cmerun,
 abstract = {It is generally known that most, if not all, beginning programming students have difficulty understanding and debugging programs. For many students the primary problem is that when a program executes, it is essentially a "black box". They know what they think they wrote, but their only clues to logic errors come from watching the output of the program. If there are problems, it is difficult for inexperienced programmers to trace the problem back to the source of the error(s). This paper presents CMeRun, a tool that allows the user to see each statement in a program as it executes. This tool will allow beginning students to master coding and debugging skills much faster since it allows them to "look into" a program as it executes. Having this kind of insight into program execution will improve understanding, decrease development time, and reduce student frustration.},
 mendeley-tags = {errors-only},
 author = {Etheredge, Jim},
 title = {CMeRun: Program Logic Debugging Courseware for CS1/CS2 Students},
 booktitle = {Proceedings of the 35th SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '04},
 year = {2004},
 isbn = {1-58113-798-2},
 location = {Norfolk, Virginia, USA},
 pages = {22--25},
 url = {http://doi.acm.org/10.1145/971300.971311},
 doi = {10.1145/971300.971311},
 acmid = {971311},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, CS2, courseware, debugging aid, pedagogy},
}

@article{wang2017data-driven,
abstract = {This paper introduces the "Search, Align, and Repair" data-driven program repair framework to automate feedback generation for introductory programming exercises. Distinct from existing techniques, our goal is to develop an efficient, fully automated, and problem-agnostic technique for large or MOOC-scale introductory programming courses. We leverage the large amount of available student submissions in such settings and develop new algorithms for identifying similar programs, aligning correct and incorrect programs, and repairing incorrect programs by finding minimal fixes. We have implemented our technique in the SARFGEN system and evaluated it on thousands of real student attempts from the Microsoft-DEV204.1X edX course and the Microsoft CodeHunt platform. Our results show that SARFGEN can, within two seconds on average, generate concise, useful feedback for 89.7% of the incorrect student submissions. It has been integrated with the Microsoft-DEV204.1X edX class and deployed for production use.},
archivePrefix = {arXiv},
arxivId = {1711.07148},
author = {Wang, Ke and Singh, RIshabh and Su, Zhendong},
eprint = {1711.07148},
file = {::},
isbn = {9781450356985},
keywords = {automatic grading,computer-aided education,technical},
mendeley-tags = {technical},
pages = {481--495},
title = {{Data-Driven Feedback Generation for Introductory Programming Exercises}},
url = {http://arxiv.org/abs/1711.07148},
year = {2017}
}
@techreport{singer-heinze2015smarter,
abstract = {Experience with software compilers tells us that error notification messages leave a lot to be desired. Current software compilers do not differentiate between the causes of a specific compiler error. This task is instead left to the developer to decipher, which can result in significant amounts of time lost. To help alleviate this burden, we present a method for providing smarter compiler error messages in Eclipse for the case of missing semicolons. By building a repository of different Java program cases that can result in a semicolon missing error, we can extract their abstract syntax trees and use this as basis of comparison for any incoming Java programs featuring this compiler error to make more specific and comprehensible error messages. Through empirical study we show that users prefer these finer grain compiler messages over the default ones provided by Eclipse.},
address = {Irvine, Califronia, USA},
author = {Singer-Heinze, Roeland and Rajasekaran, Prabhu Karthikeyan and Gupta, Nikhil},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Singer-Heinze, Rajasekaran, Gupta - 2015 - Smarter Compiler Messages for Semicolons in Eclipse.pdf:pdf},
institution = {University of California Irvine},
keywords = {empirical,enhancement},
mendeley-tags = {empirical,enhancement},
pages = {5},
title = {{Smarter Compiler Messages for Semicolons in Eclipse}},
url = {http://sites.uci.edu/nikhilgupta/files/2015/10/SoftwareEngineeringResearchProj.pdf},
year = {2015}
}

@phdthesis{thompson2004exploratory,
 abstract = {Learning howto program is a difficult task: students must learn programming concepts, a language's syntax, and a software environment that will assist their programming activi- ties. In this work we attempt to learn more about novice programming errors so that we can provide better tool support and information for instructors. We discuss our study where, with a software monitor, we tracked students' errors and their usage of the Gild integrated development environment. Based on our log file data, we describe student interactions with Gild: their first use, the features they use, and how they used them. It was found that a small number of error types accounted for the majority of errors made. Although feed- back to Gild's extra error help feature was largely positive, improvements to this feature are required as it was found that the errors that students take the longest to fix are also less frequently made.},
 author = {Thompson, Suzanne Marie},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Thompson - 2004 - An Exploratory Study of Novice Programming Experiences and Errors.pdf:pdf},
 keywords = {Novice programmer,empirical,enhancement,errors-only},
 mendeley-tags = {empirical,enhancement,errors-only},
 school = {University of Victoria},
 title = {{An Exploratory Study of Novice Programming Experiences and Errors}},
 type = {Masters Thesis},
 year = {2006}
}

@article{chatley2005kenyaeclipse,
abstract = {A fundamental part of a Computer Science degree is learning to program. Rather than starting students on a full commercial language , we favour using a dedicated "teaching language" to introduce programming concepts. At the same time, we want to introduce students to popular tools that assist in the software development process. However, up until now our teaching language, Kenya, has not been supported by professional IDEs. Therefore, we have been unable to progress smoothly from first principles to the state of the art within one environment. We present work that integrates the Kenya language into the Eclipse environment. Students can now become familiar with the major features of a professional IDE while learning to program, and experience a smooth transition to commercial languages within the same environment. One of the hardest things to teach students is good programming style. Compilers reveal syntactic and type errors, but do not analyse style. We have harnessed as-you-type code checking, as seen in Eclipse's Java development tools, to provide advice on program style as well as correctness.},
author = {Chatley, Robert and Timbul, Thomas},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Chatley, Timbul - 2005 - KenyaEclipse Learning to Program in Eclipse.pdf:pdf},
journal = {ACM SIGSOFT Software Engineering Notes},
keywords = {D23 [Coding Tools and Techniques]: Structured Prog,Eclipse,Languages Keywords programming,education,enhancement,style checking},
mendeley-tags = {enhancement},
number = {5},
title = {{KenyaEclipse: Learning to Program in Eclipse}},
volume = {30},
year = {2005}
}
@techreport{furman2014human,
abstract = {The Department of Homeland Security (DHS) requires general human systems integration (HSI) criteria for the design and development of human-machine interfaces for their technology, systems, equipment, and facilities. The goal of DHS Science and Technology (S&T) Human Factors and Behavioral Science Division Human Systems Engineering Project is to identify, develop, and apply a standard process to enhance technology and system design, system safety, and operational efficiency. The project manager partnered with the National Institute of Standards and Technology (NIST) Visualization and Usability Group (VUG) in furtherance of this effort. As part of its mission, NIST performs research to develop the technical basis for standards related to measurement, equipment specifications, procedures, and quality control benchmarks for industrial processes (among others), while remaining objective and vendor-neutral for organizations and users in industry, academia, government, and other sectors. VUG, part of the NIST Information Technology Laboratory, conducts research in HSI and human- computer interaction (HCI) technologies. Members of VUG are also active on the International Organization for Standardization (ISO) Technical Committees Working Groups in},
author = {Furman, Susanne and Theofanos, Mary and Wald, Hannah and Allen, Booz and Mclean, Hamilton and Pritzker, Penny and Gallagher, Patrick D},
doi = {10.6028/NIST.IR.7889},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Furman et al. - 2014 - Human Engineering Design Criteria Standards Part 1 Project Introduction and Existing Standards DHS S&T TSD Standa.pdf:pdf},
keywords = {HSI,guidelines,human systems integration,pre-guidelines,standards,user-centered design},
mendeley-tags = {guidelines,pre-guidelines},
pages = {81},
title = {{Human Engineering Design Criteria Standards Part 1: Project Introduction and Existing Standards DHS S&T TSD Standards Project}},
url = {http://dx.doi.org/10.6028/NIST.IR.7889http://dx.doi.org/10.6028/NIST.IR.7889},
year = {2014}
}
@article{Rogerson2017Fear,
abstract = {This paper examines how students' experiences of le arning to program are affected by feelings of fear, using a phenomenological approach to elicit rich descriptions of personal experiences from the narratives of final year undergraduate students. In the course of reviewing current work concerning learning or teaching programming, certain focal areas of research emerged. This paper a ttempted to group these into three main topics. These are the predictors of student success in learning programming, the barriers to learning pro- gramming. and the teaching tools or learning methodologies which could assist with learning programming. The review was conducted with pa rticular emphasis on phenomenological research in this field. Cockburn's concepts of skills ac quisition and Dreyfus' levels of adult learning are discussed and are used as a theoretical lens to examine the growth of the students. Learning to program or code forms part of th e core courses taught by the Information Systems (IS) department at the University of Cape Town (UCT). Assuming one of the goals of education is to prepare students for the working world, a strong practical component is required. Although programming skills are less central to the IS curriculum than to that of computer science, a num- ber of IS graduates become business analysts or project managers and are required to communi- cate with team members and, at the very least , to have a good understanding of programming is- sues. To address this need, the IS department at UCT designed a curriculum that introduces stu- dents to problem-solving, coding, and testing issues through an action learning cycle and that culminates in third year by requiring students to initialize an IS project from conception to readi- ness to implement. It is from this background th at the students for this study were selected. This paper approached the research from an inte rpretative stance, and, as the main aim was to describe students' life experiences and discove r the essence and meaning of programming from their perspective, a phenomenological methodology appeared to be ideally suited. From the analysis, six themes were uncovered. These themes are the apprehension or fear associ- ated with programming, the resulting negative pe rceptions, the nature of programming that gives rise to these feelings, the internal factors influencing these feelings, the external factors influenc- ing these feelings, and finally how these feelings have affected the students' growth or skills acquisition. A model is proposed that illustrates the relationship between the six themes, guides the analysis, and helps to makes sense of the implications. This paper offers an insight into the dif- ficulties experienced by students learn- ing to program, and should be of interest to educationalists, particularly those in the programming environment, who seek to understand the problems faced by students in order to prov ide more effective support through their teaching approach and student interactions.},
author = {Rogerson, Christine and Scott, Elsje},
doi = {10.28945/1183},
file = {::},
issn = {1547-9714},
journal = {Journal of Information Technology Education: Research},
keywords = {Education,Fear,Information Systems,Phenomenology,Programming},
pages = {147--171},
title = {{The Fear Factor: How It Affects Students Learning to Program in a Tertiary Environment}},
volume = {9},
year = {2017}
}
@article{kelleher2005lowering,
abstract = {Since the early 1960's, researchers have built a number of programming languages and environments with the intention of making programming accessible to a larger number of people. This article presents a taxonomy of languages and environments designed to make programming more accessible to novice programmers of all ages. The systems are organized by their primary goal, either to teach programming or to use programming to empower their users, and then, by each system's authors' approach, to making learning to program easier for novice programmers. The article explains all categories in the taxonomy, provides a brief description of the systems in each category, and suggests some avenues for future work in novice programming environments and languages.},
annote = {See Figure 30 (right about "6. Summary and Future Directions" for a table where one of the items listed is "better syntax error messages" and note that only one language has said feature.},
author = {Kelleher, Caitlin and Pausch, Randy},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Kelleher, Pausch - Unknown - Lowering the Barriers to Programming a survey of programming environments and languages for novice programm.pdf:pdf},
journal = {ACM Computing Surveys (CSUR)},
keywords = {Computer Science education,H52 [Information Interfaces and Presentation]: Use,Human Factors Additional Key Words and Phrases: Hu,Interaction styles,K3 [Computing Milieux]: Computers and Education Ge,Languages,Theory and methods,justification,learning,literacy,pre-guidelines,problem solving},
mendeley-tags = {justification,pre-guidelines},
number = {2},
pages = {83--137},
title = {{Lowering the barriers to programming: A taxonomy of programming environments and languages for novice programmers}},
volume = {37},
year = {2005}
}

@article{brown2018ten,
 abstract = {Research from educational psychology suggests that teaching and learning are subject-specific activities [1]: learning programming has a different set of challenges and techniques than learning physics or learning to read and write. Computing is a younger discipline than mathematics, physics, or biology, and while there have been correspondingly fewer studies of how best to teach it, there is a growing body of evidence about what works and what doesn't. This paper presents 10 quick tips that should be the foundation of any teaching of programming, whether formal or informal. These tips will be useful to anyone teaching programming at any level and to any audience. A larger list aimed primarily at K12 audiences can be found at [2].},
 author = {Brown, Neil C. C. and Wilson, Greg},
 title = {Ten Quick Tips For Teaching Programming},
 doi = {10.1371/journal.pcbi.1006023},
 editor = {Ouellette, Francis},
 issn = {1553-7358},
 month = {Apr},
 number = {4},
 pages = {e1006023},
 url = {https://dx.plos.org/10.1371/journal.pcbi.1006023},
 volume = {14},
 year = {2018},
 journal = {{PLoS} Computational Biology},
 publisher = {Public Library of Science},
}

@article{sowmya2009automating,
abstract = {Even though everyone knows Compilers, when we think a step above the compilation, then the work is to find the ways to deal with the compilation errors, or to resolve them. As a start of this, a project was carried out at Oracle India Pvt. Ltd, Server Technology, Bangalore, as a part of University-Industry collaboration program of BITS-Pilani. This project was developed as a prototype for the concept of automating the process of resolving compilation errors. This paper presents the details of the way the compilation errors were resolved in this project.},
author = {Sowmya, Karumuri Nagasai and Banerjee, Subhranshu and Desai, Arun K},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Sowmya, Banerjee, Desai - 2009 - Automating the Process to Resolve Compilation Errors.pdf:pdf},
journal = {CURIE},
keywords = {Application Migration,Compilation errors,difficulties},
mendeley-tags = {difficulties},
number = {3},
pages = {46--52},
title = {{Automating the Process to Resolve Compilation Errors}},
volume = {2},
year = {2009}
}
@article{barron1975note,
author = {Barron, D. W.},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Barron - 1975 - A Note on APL.pdf:pdf},
journal = {The Computer Journal},
keywords = {difficulties,justification},
mendeley-tags = {difficulties,justification},
number = {1},
pages = {93},
title = {{A Note on APL}},
url = {https://academic.oup.com/comjnl/article-pdf/19/1/93/1058172/190093.pdf},
volume = {19},
year = {1975}
}

@inproceedings{furuta2004experimental,
 abstract = {The interaction between programmer and programming language affects the maintainability, reliability, and understandability of the resulting programs. Their results are important both to the educator and to the language designer, particularly when examining languages to be used when teaching beginning programmers. The purpose of this paper is to examine and discuss the methodology and results of a number of these research studies.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Furuta, Kemp - 2004 - Experimental evaluation of programming language features.pdf:pdf},
 mendeley-tags = {anecdotal,pre-guidelines},
 author = {Furuta, Richard and Kemp, P. Michael},
 title = {Experimental Evaluation of Programming Language Features: Implications for Introductory Programming Languages},
 booktitle = {Proceedings of the 10th SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '79},
 year = {1979},
 pages = {18--21},
 url = {http://doi.acm.org/10.1145/800126.809544},
 doi = {10.1145/800126.809544},
 acmid = {809544},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@phdthesis{mciver2001syntactic,
 abstract = {Learning computer programming is difficult. Students often have trouble coming to terms with the fundamentals of programming. At the same time, they are forced to tackle the complexities of a particular programming language. There is considerable debate about the choice of programming language for introductory programming courses, but little empirical evidence for the efficacy of any particular language. This thesis examines why learning to program is difficult. Programming languages are discussed as user interfaces, and hence analysed using usability principles. This analysis is used as the basis for the construction of a theory of pedagogical programming language design, which is then applied to the design of a new pedagogical programming language, GRAIL. A new framework is presented for the evaluation of pedagogical programming languages. Using this framework, GRAIL is evaluated, and subsequently redesigned. The results of the evaluation provide evidence of the impact of introductory programming languages on the learning process, and show that the choice of introductory programming language is important.},
 author = {McIver, Linda Kathryn},
 file = {::},
 keywords = {difficulties,empirical,guidelines,justification,pedagogy,performance},
 mendeley-tags = {difficulties,empirical,guidelines,justification,pedagogy,performance},
 pages = {200},
 school = {Monash University},
 title = {{Syntactic and Semantic Issues in Introductory Programming Education}},
 type = {PhD Thesis},
 year = {2001}
}

@inproceedings{vihavainen2014how,
 abstract = {While computing educators have put plenty of effort into researching and developing programming environments that make it easier for students to create their first programs, these tools often have only little resemblance with the tools used in the industry. We report on a study, where students with no previous programming experience started to program directly using an industry strength programming environment. The programming environment was augmented with logging capability that recorded every keystroke and event within the system, which provided a view on how the novices tackle their first lines of code. Our results show that while at first, the students struggle with syntax-as is typical with learning a new language-no evidence can be found that suggests that learning to use the programming environment is hard. In a two-week period, the students learned to use the basic features of the programming environment such as specific shortcuts. Although we observed students using copy-paste-programming relatively often, most of the pasted code is from their own previous work. Finally, when considering the compilation errors and error distributions, we hypothesize that the errors are a product of three factors ; the exercises, the environment, and the data logging granularity.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Vihavainen, Helminen, Ihantola - 2014 - How novices tackle their first lines of code in an IDE analysis of programming session traces.pdf:pdf},
 mendeley-tags = {difficulties,empirical,justification},
 author = {Vihavainen, Arto and Helminen, Juha and Ihantola, Petri},
 title = {How Novices Tackle Their First Lines of Code in an IDE: Analysis of Programming Session Traces},
 booktitle = {Proceedings of the 14th Koli Calling International Conference on Computing Education Research},
 series = {Koli Calling '14},
 year = {2014},
 isbn = {978-1-4503-3065-7},
 location = {Koli, Finland},
 pages = {109--116},
 url = {http://doi.acm.org/10.1145/2674683.2674692},
 doi = {10.1145/2674683.2674692},
 acmid = {2674692},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {data mining, introductory programming, learning analytics, novice programmers, novices and programming environments, programming behavior, programming environments, programming session trace analysis, source code snapshot analysis},
}

@inproceedings{Nielsen1994enhancing,
abstract = {Several published sets of usability heuristics were compared with a database of existing usability problems drawn from a variety of projects in order to determine what heuristics best explain actual usability problems. Based on a factor analysis of the explanations as well as an analysis of the heuristics providing the broadest explanatory coverage of the problems, a new set of nine heuristics were derived: visibility of system status, match between system and the real world, user control and freedom, consistency and standards, error prevention, recognition rather than recall, flexibility and efficiency of use, aesthetic and minimalist design, and helping users rec- ognize, diagnose, and recover from errors. Keywords:},
address = {New York, New York, USA},
annote = {This was added by Ray. Guidelines people, search this document for "message"},
author = {Nielsen, Jakob},
booktitle = {Conference companion on Human factors in computing systems - CHI '94},
doi = {10.1145/259963.260333},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Nielsen - 1994 - Enhancing the explanatory power of usability heuristics.pdf:pdf},
isbn = {0897916514},
keywords = {Heuristic evaluation,Usability problems,guidelines},
mendeley-tags = {guidelines},
pages = {152--158},
publisher = {ACM Press},
title = {{Enhancing the explanatory power of usability heuristics}},
url = {http://portal.acm.org/citation.cfm?doid=259963.260333},
year = {1994}
}

@inproceedings{freund1996thetis,
 abstract = {Commercially available compilers, particularly those used for languages like ANSI C that have extensive commercial applicability, are not well-suited to students in introductory computer science courses because they assume a level of sophistication that beginning students do not possess. To alleviate this problem at Stanford, we have developed the Thetis programming environment designed specifically for student use. The system consists of a C interpreter and associated user interface that provides students with simple and easily understood editing, debugging, and visualization capabilities. Reactions of students and instructors indicate that Thetis fulfills the goals we set out to accomplish and provides a significantly better learning environment for students in CS l/CS2.},
 mendeley-tags = {empirical,enhancement},
 author = {Freund, Stephen N. and Roberts, Eric S.},
 title = {Thetis: An ANSI C Programming Environment Designed for Introductory Use},
 booktitle = {Proceedings of the Twenty-seventh SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '96},
 year = {1996},
 isbn = {0-89791-757-X},
 location = {Philadelphia, Pennsylvania, USA},
 pages = {300--304},
 url = {http://doi.acm.org/10.1145/236452.236560},
 doi = {10.1145/236452.236560},
 acmid = {236560},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{denny2011codeWrite,
 abstract = {Drill and practice exercises enable students to master skills needed for more sophisticated programming. A barrier to providing such activities is the effort required to set up the programming environment. Testing is an important component to writing good software, but it is difficult to motivate students to write tests. In this paper we describe and evaluate CodeWrite, a web-based tool that provides drill and practice support for Java programming, and for which testing plays a central role in its use. We describe how we have used CodeWrite in a CS1 course, and demonstrate its effectiveness in providing good coverage of the language features presented in the course.},
 mendeley-tags = {enhancement},
 author = {Denny, Paul and Luxton-Reilly, Andrew and Tempero, Ewan and Hendrickx, Jacob},
 title = {CodeWrite: Supporting Student-driven Practice of Java},
 booktitle = {Proceedings of the 42nd ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '11},
 year = {2011},
 isbn = {978-1-4503-0500-6},
 location = {Dallas, TX, USA},
 pages = {471--476},
 url = {http://doi.acm.org/10.1145/1953163.1953299},
 doi = {10.1145/1953163.1953299},
 acmid = {1953299},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CodeWrite, assessment, constructive evaluation, contributing student pedagogy, online, student-generated content},
}

@article{carter2015its,
abstract = {An Intelligent Tutoring System to teach debugging skills to novice computer science students was previously proposed and discussed in [3] and [4]. [4] additionally discussed the implementation and some preliminary evaluation results. This paper presents new results from the completion of the formal evaluation of this system and discusses the practical implications of these results.},
author = {Carter, Elizabeth},
file = {::},
journal = {Journal of Computing Sciences in Colleges},
keywords = {enhancement},
mendeley-tags = {enhancement},
number = {3},
pages = {9--15},
title = {{ITS Debug: Practical Results}},
url = {http://dl.acm.org/citation.cfm?id=2675327.2675330},
volume = {30},
year = {2015}
}
@inproceedings{evangelidis2001x-compiler,
abstract = {The paper presents a simple programming language, called X, and an educational programming environment, called X-Compiler, designed to introduce students to programming. X-Compiler can be used to edit, compile, debug and run programs written in X, a subset of Pascal. X-Compiler could be didactically interesting because of the following features: (a) users can watch the intermediate steps of the execution of a program: source code compilation, correspondence of source and pseudo-assembly code during execution, register content, and intermediate values of user and temporary system variables; also, they can edit the produced pseudo-assembly code and re-execute it, (b) there are many detailed and explanatory messages that can guide novice programmers when debugging their programs and, in general, help them write better programs},
author = {Evangelidis, Georgios and Dagdilelis, Vassilios and Satratzemi, Maria and Efopoulos, Vassilios},
booktitle = {Proceedings IEEE International Conference on Advanced Learning Technologies},
doi = {10.1109/ICALT.2001.943890},
file = {::},
isbn = {0-7695-1013-2},
keywords = {pre-guidelines},
mendeley-tags = {pre-guidelines},
pages = {166--169},
publisher = {IEEE Comput. Soc},
title = {{X-compiler: Yet Another Integrated Novice Programming Environment}},
url = {http://ieeexplore.ieee.org/document/943890/},
year = {2001}
}

@article{chen2018advanced,
abstract = {In 2014, Heizmann et al. proposed a novel framework for program termination analysis. The analysis starts with a termination proof of a sample path. The path is generalized to a B{\"{u}}chi automaton (BA) whose language (by construction) represents a set of terminating paths. All these paths can be safely removed from the program. The removal of paths is done using automata difference, implemented via BA com-plementation and intersection. The analysis constructs in this way a set of BAs that jointly "cover" the behavior of the program, thus proving its termination. An implementation of the approach in Ultimate Automizer won the 1st place in the Termination category of SV-Comp 2017. In this paper, we exploit advanced automata-based algorithms and propose several non-trivial improvements of the framework. To alleviate the complementation computation for BAs-one of the most expensive operations in the framework-, we propose a multi-stage generalization construction. We start with generalizations producing subclasses of BAs (such as deterministic BAs) for which efficient com-plementation algorithms are known, and proceed to more general classes only if necessary. Particularly, we focus on the quite expressive subclass of semideterministic BAs and provide an improved complementation algorithm for this class. Our experimental evaluation shows that the proposed approach significantly improves the power of termination checking within the Ultimate Automizer framework. CCS Concepts ¢ Theory of computation â Automata over infinite objects; ¢ Software and its engineering â Formal software verification;},
author = {Chen, Yu-Fang and Heizmann, Matthias and Leng{\'{a}}l, OndÅej and Li, Yong and Tsai, Ming-Hsien and Turrini, Andrea and Zhang, Lijun},
doi = {10.1145/3296979.3192405},
file = {::},
isbn = {9781450356985},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {acm reference format,b{\"{u}}chi automata comple-,matthias heizmann,mentation and language difference,ming-,ondÅej leng{\'{a}}l,program termination,technical,yong li,yu-fang chen},
mendeley-tags = {technical},
number = {4},
pages = {135--150},
title = {{Advanced automata-based algorithms for program termination checking}},
volume = {53},
year = {2018}
}
@inproceedings{garner2005program,
abstract = {In this paper we describe an ongoing study of novice programmers. The aim is to record (as close as possible to) all of the problems encountered by students during the laboratory sessions of our introductory Java programming class. We discuss the tools and methods employed, in particular presenting the list of problem definitions which is used to classify students' problems. Data collected during 2003 are presented and discussed. The results are consistent with trends noted in the literature, and highlight the significance of both fundamental design issues and the procedural aspects of programming. Different problem distributions are observed for high and low performing students. An analysis of individual lab sessions can be useful for refining course materials and teaching practice.},
author = {Garner, Sandy and Haden, Patricia and Robins, Anthony},
booktitle = {Proceedings of the 7th Australasian Conference on Computing Education},
file = {::},
keywords = {difficulties,empirical,novice programming errors CS1},
mendeley-tags = {difficulties,empirical},
pages = {173--180},
title = {{My Program is Correct But it Doesn't Run: A Preliminary Investigation of Novice Programmers' Problems}},
year = {2005}
}

@inproceedings{becker2016categorizing,
 abstract = {Being a competent programmer is critical for students in all computing disciplines and software engineering in particular. Novice programming students face a number of challenges and these have been shown to contribute to worrying dropout rates for students majoring in computing, and the growing number of non-majors who are learning to program. Methods of identifying and helping at-risk programming students have been researched for decades. Much of this research focuses on categorizing the errors that novice programmers make, in order to help understand why these errors are made, with the goal of helping them overcome these errors quickly, or avoid them altogether. This paper presents the first known work on categorizing compiler errors using Principal Component Analysis. In this, we find a new way of discovering categories of related errors from data produced by the students in the course of their programming activity. This method may be used to identify where these students are struggling and provide direction in efforts to help them.},
 address = {Shenyang, China},
 author = {Becker, Brett A. and Mooney, Catherine},
 booktitle = {Proceedings of the 12th China-Europe International Symposium on Software Engineering Education},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Becker, Mooney - 2016 - Categorizing Compiler Error Messages with Principal Component Analysis.pdf:pdf},
 keywords = {compiler error messages,compiler errors,cs1,difficulties,empirical,error message categorization,java,justification,novice programmers,principal component analysis,programming},
 mendeley-tags = {difficulties,empirical,justification},
 pages = {1--8},
 title = {{Categorizing Compiler Error Messages with Principal Component Analysis}},
 url = {https://researchrepository.ucd.ie/handle/10197/7889},
 year = {2016},
 series = {CEISEE '16},
}

@article{bergin2003deficiencies,
abstract = {C++ is a popular programming language for the introductory level (CS1) and at the advance level (CS2) at many community colleges and universities in the USA. While teaching CS1 and CS2, we observed some deficiencies of C++, which are discussed in this paper. Students and instructors should be aware of these problems in CS1 and CS2. Selecting the "right" language for pedagogical purposes can be made easier if these pitfalls are observed.},
author = {Bergin, Joe and Agarwal, Achla and Agarwal, Krishna},
doi = {10.1145/885638.885642},
file = {::},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {C++,CS1,CS2,anecdotal,introductory programming},
mendeley-tags = {anecdotal},
number = {6},
pages = {9--13},
title = {{Some Deficiencies of C++ in Teaching CS1 and CS2}},
volume = {38},
year = {2003}
}
@article{isradisaikul2015finding,
abstract = {Writing a parser remains remarkably painful. Automatic parser generators offer a powerful and systematic way to parse complex grammars, but debugging conflicts in grammars can be time-consuming even for experienced language designers. Better tools for diagnosing parsing conflicts will alleviate this difficulty. This paper proposes a practical algorithm that generates compact, helpful counterexamples for LALR grammars. For each parsing conflict in a grammar, a counterexample demonstrating the conflict is constructed. When the grammar in question is ambiguous, the algorithm usually generates a compact counterexample illustrating the ambiguity. This algorithm has been implemented as an extension to the CUP parser generator. The results from applying this implementation to a diverse collection of faulty grammars show that the algorithm is practical, effective, and suitable for inclusion in other LALR parser generators. Copyright is held by the owner/author(s). Publication rights licensed to ACM.},
author = {Isradisaikul, Chinawat and Myers, Andrew C.},
doi = {10.1145/2813885.2737961},
file = {::},
isbn = {9781450334686},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {ambiguous,context-free grammar,error diagnosis,grammar,lookahead-sensitive path,product parser,shift-reduce parser,technical},
mendeley-tags = {technical},
number = {6},
pages = {555--564},
title = {{Finding counterexamples from parsing conflicts}},
volume = {50},
year = {2015}
}
@techreport{schliep2015usability,
abstract = {Error messages are an important tool programmers use to help find and fix mistakes or issues in their code. When an error message is unhelpful, it can be difficult to find the issue and may impose additional challenges in learning the language and concepts. Error messages are especially critical for introductory programmers in understanding problems with their code. Unfortunately, not all error messages in programming are beneficial for novice programmers. This paper discusses the general usability of error messages for introductory programmers, analyses of error messages in compilers and DrRacket, and two methodologies intended to improve error handling.},
author = {Schliep, Paul A},
booktitle = {Morris Undergraduate Journal},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Schliep - 2015 - Usability of Error Messages for Introductory Students.pdf:pdf},
keywords = {Novice programmers,compiler errors,difficulties,empirical,enhancement,error messages,guidelines,justification,syntax errors,usability,usability stud-ies},
mendeley-tags = {difficulties,empirical,enhancement,guidelines,justification},
number = {2},
publisher = {Paul A},
title = {{Usability of Error Messages for Introductory Students}},
url = {http://digitalcommons.morris.umn.edu/horizonsAvailableat:http://digitalcommons.morris.umn.edu/horizons/vol2/iss2/5 https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2505746},
volume = {2},
year = {2015}
}
@techreport{motil1998jj,
abstract = {This paper describes a way of teaching programming to beginning students, by first introducing them to basic principles with a small language having a simple syntax and student-friendly environment which runs in a browser. Shortly after the basics, students can convert quickly and easily from JJ to Java. Less at first results in more later.},
author = {Motil, John and Epstein, David},
file = {::},
institution = {California State University; California Institute of Technology},
keywords = {pedagogy},
mendeley-tags = {pedagogy},
title = {{JJ: A Language Designed for Beginners (Less is More)}},
year = {1998}
}

@phdthesis{becker2015effects,
 abstract = {Computer programming is an essential skill that all computing students must master and is increasingly important in many diverse disciplines. It is also difficult to learn. One of the many challenges novice programmers face from the start are notoriously cryptic compiler error messages. These report details on errors made by students and are essential as the primary source of information used to rectify those errors. However these difficult to understand messages are often a barrier to progress and a source of discouragement. A high number of student errors, and in particular a high frequency of repeated errors when a student makes the same error consecutively  have been shown to be indicators of students who are struggling with learning to program. This instrumental case study research investigates the student experience with, and the effects of, software that has been specifically written to help students overcome their challenges with compiler error messages. This software provides help by enhancing error messages, presenting them in a straightforward, informative manner. Two cohorts of first year computing students at an Irish higher education institution participated over two academic years; a control group in 2014-15 that did not experience enhanced error messages, and an intervention group in 2013-14 that did. This thesis lays out a comprehensive view of the student experience starting with a quantitative analysis of the student errors themselves. It then views the students as groups, revealing interesting differences in error profiles. Following this, some individual student profiles and behaviours are investigated. Finally, the student experience is discovered through their own words and opinions by means of a survey that incorporated closed and open-ended questions. In addition to reductions in errors overall, errors per student, and the key metric of repeated error frequency, the intervention group is shown to behave more cohesively with fewer indications of struggling students. A positive learning experience using the software is reported by the students and the lecturer. These results are of interest to educators who have witnessed students struggle with learning to program, and who are looking to help remove the barrier presented by compiler error messages. This work is important for two reasons. First, the effects of error message enhancement have been debated in the literature this work provides evidence that there can be positive effects. Second, these results should be generalisable at least in part, to other languages, students and institutions.},
 author = {Becker, Brett A.},
 doi = {10.13140/RG.2.2.26637.13288},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Becker - 2015 - An Exploration Of The Effects Of Enhanced Compiler Error Messages For Computer Programming Novices.pdf:pdf},
 issn = {978-1-59593-799-5},
 keywords = {difficulties,empirical,enhancement,justification,pedagogy,pre-guidelines},
 mendeley-tags = {difficulties,empirical,enhancement,justification,pedagogy,pre-guidelines},
 school = {Dublin Institute of Technology},
 type={Masters Thesis},
 title = {{An Exploration Of The Effects Of Enhanced Compiler Error Messages For Computer Programming Novices}},
 url = {https://arrow.dit.ie/cgi/viewcontent.cgi?article=1036&context=ltcdis},
 year = {2015}
}

@phdthesis{kolling1999design,
 author = {K{\"{o}}lling, Michael},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/K{\"{o}}lling - 1999 - The Design of an Object-Oriented Environment and Language for Teaching.pdf:pdf},
 school = {University of Sydney},
 title = {{The Design of an Object-Oriented Environment and Language for Teaching}},
 url = {https://kar.kent.ac.uk/21868/1/the_design_of_an_object-oriented_kolling.pdf},
 year = {1999}
}

@inproceedings{ahmadzadeh2005analysis,
 abstract = {The process by which students learn to program is a major issue in computer science educational research. Programming is a fundamental part of the computer science curriculum, but one which is often problematic. It seems to be difficult to find an effective method of teaching that is suitable for all students. In this research we tried to gain insights into ways of improving our teaching by a careful examination of students' mistakes. The compiler errors that were generated by their programs together with the pattern that was observed in their debugging activities formed the basis of this research. We discovered that many students with a good understanding of programming do not acquire the skills to debug programs effectively, and this is a major impediment to their producing working code of any complexity. Skill at debugging seems to increase a programmer's confidence and we suggest that more emphasis be placed on debugging skills in the teaching of programming.},
 mendeley-tags = {empirical,errors-only},
 author = {Ahmadzadeh, Marzieh and Elliman, Dave and Higgins, Colin},
 title = {An Analysis of Patterns of Debugging Among Novice Computer Science Students},
 booktitle = {Proceedings of the 10th Annual SIGCSE Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '05},
 year = {2005},
 isbn = {1-59593-024-8},
 location = {Caparica, Portugal},
 pages = {84--88},
 url = {http://doi.acm.org/10.1145/1067445.1067472},
 doi = {10.1145/1067445.1067472},
 acmid = {1067472},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {debugging, programming},
} 

@inproceedings{bouvier2016novice,
 abstract = {It is often debated whether a problem presented in a straightforward minimalist fashion is better, or worse, for learning than the same problem presented with a "real-life" or "concrete" context. The presentation, contextualization, or "problem description" has been well studied over several decades in disciplines such as mathematics education and psychology; however, little has been published in the field of computing education. In psychology it has been found that not only the presence of context, but the type of context can have dramatic results on problem success. In mathematics education it has been demonstrated that there are non-mathematical factors in problem presentation that can a?ect success in solving the problem and learning. The contextual background of a problem can also impact cognitive load, which should be considered when evaluating the e?ects of context. Further, it has been found that regarding cognitive load, computer science has unique characteristics compared to other disciplines, with the consequence that results from other disciplines may not apply to computer science, thus requiring investigation within computer science. This paper presents a multi-national, multi-institutional study of the e?ects of problem contextualization on novice programmer success in a typical CS1 exercise.},
 mendeley-tags = {errors-only},
 author = {Bouvier, Dennis and Lovellette, Ellie and Matta, John and Alshaigy, Bedour and Becker, Brett A. and Craig, Michelle and Jackova, Jana and McCartney, Robert and Sanders, Kate and Zarb, Mark},
 title = {Novice Programmers and the Problem Description Effect},
 booktitle = {Proceedings of the 2016 ITiCSE Working Group Reports},
 series = {ITiCSE-WGR '16},
 year = {2016},
 isbn = {978-1-4503-4882-9},
 location = {Arequipa, Peru},
 pages = {103--118},
 url = {http://doi.acm.org/10.1145/3024906.3024912},
 doi = {10.1145/3024906.3024912},
 acmid = {3024912},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, context, novice programmers},
} 

@inproceedings{ahadi2016students,
 abstract = {The computing education community has studied extensively the errors of novice programmers. In contrast, little attention has been given to student's mistake in writing SQL statements. This paper represents the first large scale quantitative analysis of the student's syntactic mistakes in writing different types of SQL queries. Over 160 thousand snapshots of SQL queries were collected from over 2000 students across eight years. We describe the most common types of syntactic errors that students make. We also describe our development of an automatic classifier with an overall accuracy of 0.78 for predicting student performance in writing SQL queries.},
 mendeley-tags = {empirical,errors-only},
 author = {Ahadi, Alireza and Behbood, Vahid and Vihavainen, Arto and Prior, Julia and Lister, Raymond},
 title = {Students' Syntactic Mistakes in Writing Seven Different Types of SQL Queries and Its Application to Predicting Students' Success},
 booktitle = {Proceedings of the 47th ACM Technical Symposium on Computing Science Education},
 series = {SIGCSE '16},
 year = {2016},
 isbn = {978-1-4503-3685-7},
 location = {Memphis, Tennessee, USA},
 pages = {401--406},
 url = {http://doi.acm.org/10.1145/2839509.2844640},
 doi = {10.1145/2839509.2844640},
 acmid = {2844640},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {databases, machine learning, online assessment, sql queries},
}

@phdthesis{zhang2012emperical,
 abstract = {Students in first-year computer science at many universities are required to enroll in an introductory programming course to learn Java. Programming defects provide useful information revealing the challenges students face in achieving high quality code. The identification of defects also enables instructors to improve their teaching by placing greater emphasis on those areas where students are struggling. In this dissertation, a range of defect types has been identified and a taxonomy - called Novice Defect Taxonomy (NDT) developed. This taxonomy may be used to hierarchically classify defects in a clear and reproducible way. Its derivation from a large number of student assignments is described. Assignments are assessed within a defect measurement framework which combines dynamic and static analysis. The approach measures defects in functionality, code style, language syntax and code completeness. Based on the analyses, it is shown that automatic assistance has a positive impact on the program quality of novice programmers. Students rapidly accept automatic tools. Finally, this taxonomy provides other researchers with a framework and reference baseline for developing new defect classifications.},
 annote = {Was previously classified as a Report, but I believe it's correctly classified as a (Masters) thesis.},
 author = {Zhang, Lu},
 file = {::},
 keywords = {empirical,justification},
 mendeley-tags = {empirical,justification},
 pages = {89 pages},
 school = {The University of Western Australia},
 title = {{Empirical Design and Analysis of a Defect Taxonomy for Novice Programmers}},
 type = {Masters Thesis (by Research)},
 url = {https://research-repository.uwa.edu.au/files/3232803/Zhang_Lu_2012.pdf},
 year = {2012}
}

@techreport{farragher2000java,
abstract = {Most modern programming languages are complex and feature rich. Whilst this is (sometimes) an advantage for industrial-strength applications, it complicates both language teaching and language research. We describe our experiences in the design of a reduced subset of the Java language and its implementation using the Vanilla language development framework. We argue that Vanilla's component-based approach allows the language's feature set to be varied quickly and simply compared with other development approaches.},
author = {Farragher, Linda and Dobson, Simon},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Farragher, Dobson - 2000 - Java Decaffeinated Experiences Building a Programming Language from Components.pdf:pdf},
institution = {Trinity College, Dublin, Ireland},
keywords = {enhancement},
mendeley-tags = {enhancement},
title = {{Java Decaffeinated: Experiences Building a Programming Language from Components}},
url = {http://www.vanilla.ie},
year = {2000}
}
@article{fenichel1970program,
abstract = {The TEACH system was developed at MIT to ease the cost and improve the results of elementary instruction in programming. To the student, TEACH offers loosely guided experience with a conversational language which was designed with teaching in mind. Faculty involvement is minimal. A term of experience with TEACH is discussed. Pedagogically, the system appears to be successful; straightforward reimple- mentation will make it economically successful as well. Similar programs of profound tutorial skiH will appear only as the results of extended research. The outlines of this research are beginning to become clear.},
author = {Fenichel, Robert R. and Weizenbaum, Joseph and Yochelson, Jerome C.},
doi = {10.1145/362052.362053},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Fenichel, Weizenbaum, Yochelson - 1970 - A Program to Teach Programming.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {TEACH,UNCL,computer-assisted learning,elementary,programming,technical},
mendeley-tags = {technical},
number = {3},
pages = {141--146},
title = {{A Program to Teach Programming}},
volume = {13},
year = {1970}
}

@inproceedings{ihantola2015educational,
 abstract = {Educational data mining and learning analytics promise better understanding of student behavior and knowledge, as well as new information on the tacit factors that contribute to student actions. This knowledge can be used to inform decisions related to course and tool design and pedagogy, and to further engage students and guide those at risk of failure. This working group report provides an overview of the body of knowledge regarding the use of educational data mining and learning analytics focused on the teaching and learning of programming. In a literature survey on mining students' programming processes for 2005-2015, we observe a significant increase in work related to the field. However, the majority of the studies focus on simplistic metric analysis and are conducted within a single institution and a single course. This indicates the existence of further avenues of research and a critical need for validation and replication to better understand the various contributing factors and the reasons why certain results occur. We introduce a novel taxonomy to analyse replicating studies and discuss the importance of replicating and reproducing previous work. We describe what is the state of the art in collecting and sharing programming data. To better understand the challenges involved in replicating or reproducing existing studies, we report our experiences from three case studies using programming data. Finally, we present a discussion of future directions for the education and research community.},
 mendeley-tags = {errors-only},
 author = {Ihantola, Petri and Vihavainen, Arto and Ahadi, Alireza and Butler, Matthew and B\"{o}rstler, J\"{u}rgen and Edwards, Stephen H. and Isohanni, Essi and Korhonen, Ari and Petersen, Andrew and Rivers, Kelly and Rubio, Miguel \'{A}ngel and Sheard, Judy and Skupas, Bronius and Spacco, Jaime and Szabo, Claudia and Toll, Daniel},
 title = {Educational Data Mining and Learning Analytics in Programming: Literature Review and Case Studies},
 booktitle = {Proceedings of the 2015 ITiCSE Working Group Reports},
 series = {ITICSE-WGR '15},
 year = {2015},
 isbn = {978-1-4503-4146-2},
 location = {Vilnius, Lithuania},
 pages = {41--63},
 url = {http://doi.acm.org/10.1145/2858796.2858798},
 doi = {10.1145/2858796.2858798},
 acmid = {2858798},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {educational data mining, learning analytics, literature review, programming, replication},
} 

@phdthesis{jadud2006exploration,
 abstract = {Our research explores the process by which beginning programmers go about writing pro- grams. We have focused our explorations on what we call compilation behaviour: the program- ming behaviour a student engages in while repeatedly editing and compiling their programs in an attempt to make them syntactically, if not semantically, correct. The students whose be- haviour we have observed were engaged in learning to program in an objects-first style using BlueJ, an environment designed for supporting novice programmers just starting out with the Java programming language. The significant results of our work are two-fold. First, we have developed tools for visu- alising the process by which students write their programs. Using these tools, we can quickly obtain valuable information about their process, and use that information to inform further research regarding their behaviour, or apply it immediately in a classroom context to better support the struggling learner. Second, we have proposed a quantification of novice compila- tion behavior which we call the error quotient. Using this metric, we can determine how well (or poorly) a student fares with syntax errors while learning to program. This quantity, like our tools for visualisation, provides a powerful indicator for how much or little a student is struggling with the language while programming, and correlates significantly with traditional indicators for academic progress. iii},
 author = {Jadud, Matthew C.},
 booktitle = {Thesis},
 file = {::},
 keywords = {empirical,errors-only},
 mendeley-tags = {empirical,errors-only},
 pages = {1--250},
 school = {University of Kent at Canterbury},
 title = {{An Exploration of Novice Compilation Behaviour in BlueJ}},
 year = {2006},
 url = {https://jadud.com/dl/pdf/jadud-dissertation.pdf}
}

@incollection{krishnamurthi2019programming,
abstract = {Programming is a central concern of computer science, so its medium-programming languages-should be a focus of computing education. Unfortunately, much of the community lacks useful tools to understand and organize languages, since the standard literature is mired in the ill-defined and even confusing concept of paradigms. This chapter suggests the use of notional machines, i.e., human-accessible operational semantics, as a central organizing concept for understanding languages. It introduces or reexamines several concepts in programming and languages, especially state, whose complexity is understood well in the programming languages literature but is routinely overlooked in computing education. It identifies and provides context for numerous open problems worthy of research focus, some of which are new twists on long-running debates while others have not received the attention in the literature that they deserve. 2},
annote = {Section 7.2: Errors and Error Messages},
author = {Krishnamurthi, Shriram and Fisler, Kathi},
booktitle = {The Cambridge Handbook of Computing Education Research},
chapter = {13},
doi = {10.1017/9781108654555.014},
editor = {Fincher, Sally A. and Robins, Anthony V.},
file = {::},
keywords = {difficulties,justification},
mendeley-tags = {difficulties,justification},
pages = {377--413},
publisher = {Cambridge University Press},
title = {{Programming Paradigms and Beyond}},
year = {2019}
}
@article{petricek2017miscomputation,
abstract = {Computer programs do not always work as expected. In fact, ominous warnings about the desperate state of the software industry continue to be released with almost ritualistic regularity. In this paper, we look at the 60 years history of programming and at the different practical methods that software community developed to live with programming errors. We do so by observing a class of students discussing different approaches to programming errors. While learning about the different methods for dealing with errors, we uncover basic assumptions that proponents of different paradigms follow. We learn about the mathematical attempt to eliminate errors through formal methods, scientific method based on testing, a way of building reliable systems through engineering methods, as well as an artistic approach to live coding that accepts errors as a creative inspiration. This way, we can explore the differences and similarities among the different paradigms. By inviting proponents of different methods into a single discussion, we hope to open potential for new thinking about errors. When should we use which of the approaches? And what can software development learn from mathematics, science, engineering and art? When programming or studying programming, we are often enclosed in small communities and we take our basic assumptions for granted. Through the discussion in this paper, we attempt to map the large and rich space of programming ideas and provide reference points for exploring, perhaps foreign, ideas that can challenge some of our assumptions.},
author = {Petricek, Tomas},
doi = {10.22152/programming-journal.org/2017/1/14},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Petricek - 2017 - Miscomputation in software Learning to live with errors.pdf:pdf},
journal = {The Art, Science, and Engineering of Programming},
keywords = {errors-only},
mendeley-tags = {errors-only},
number = {2},
title = {{Miscomputation in software: Learning to live with errors}},
volume = {1},
year = {2017}
}

@article{mayer2004teaching,
 abstract = {Psychology of subject matter refers to the scientific study of learning and instruction within school subjects. The growing research literature on teaching and learning of school subjects represents one of educational psychology's most productive accomplishments of the past two decades. The purpose of this chapter is to examine representative advances in the psychology of subject matter, including how people learn to read words, comprehend printed passages, write compositions, solve arithmetic word problems, and understand how scientific systems work. The introduction provides a historical overview of how to promote transfer and is followed by reviews of representative research in learning and teaching of reading fluency, reading comprehension, writing, mathematics, and science.},
 author = {Mayer, Richard E.},
 doi = {10.1146/annurev.psych.55.082602.133124},
 issn = {0066-4308},
 journal = {Annual Review of Psychology},
 keywords = {cognitive psychology,educational psychology,instruction,learning,reading},
 month = { Feb},
 number = {1},
 pages = {715--744},
 title = {{Teaching of Subject Matter}},
 url = {http://www.annualreviews.org/doi/10.1146/annurev.psych.55.082602.133124},
 volume = {55},
 year = {2004}
}

@inproceedings{jesna2016ide,
abstract = {Novices find it difficult to learn programming. In order to write a program, they have to learn the basic concepts of programming along with the syntax and semantics of a programming language. One of the important tasks in programming is debugging. To become good programmers, novices need to have good debugging skills. Typically it is difficult for novices to understand and rectify the syntax errors from the compiler-generated error messages, which they encounter during the debugging process. Professional Integrated Development Environments (IDEs) are not novice-friendly in debugging. Hence an IDE for novices has been designed and implemented for Java programming. It provides multilevel hints for the compiler-generated error messages, which will make the debugging process easier. A preliminary evaluation of the tool among engineering graduates is promising. This paper explains the design and implementation of this IDE.},
author = {{Jesna AA} and {Renumol V. G.}},
booktitle = {IAFOR International Conference on Education, IICEDubai2016},
file = {::},
keywords = {Compiler error messages,Debugging,Integrated Development Environment,Java,Novice programmer,anecdotal,difficulties,enhancement},
mendeley-tags = {anecdotal,difficulties,enhancement},
pages = {1--14},
title = {{An IDE for Java with Multilevel Hints to Develop Debugging Skills in Novices}},
url = {www.iafor.org},
year = {2016}
}

@inproceedings{brown2018blackbox,
abstract = {The Blackbox project has been collecting programming activity data from users of BlueJ (a novice-targeted Java development environ- ment) for nearly five years. The resulting dataset of more than two terabytes of data has been made available to interested researchers from the outset. In this paper, we assess the impact of the Blackbox project: we perform a mapping study to assess eighteen publica- tions which have made use of the Blackbox data, and we report on the advantages and difficulties experienced by researchers working with this data, collected via a survey. We find that Blackbox has enabled pieces of research which otherwise would not have been possible, but there remain technical challenges in the analysis. Some of these but not all relate to the scale of the data. We provide suggestions for the future use of Blackbox, and reflections on the role of such data collection projects in programming research.},
address = {Espoo, Finland},
author = {Brown, Neil C. C. and Altadmri, Amjad and Sentance, Sue and K{\"{o}}lling, Michael},
booktitle = {Proceedings of the 2018 ACM Conference on International Computing Education Research - ICER '18},
doi = {10.1145/3230977.3230991},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Brown et al. - 2018 - Blackbox, Five Years On.pdf:pdf},
isbn = {9781450356282},
keywords = {Blackbox,Mapping Study,Shared Data,tool},
mendeley-tags = {tool},
pages = {196--204},
publisher = {ACM},
title = {{Blackbox, Five Years On}},
url = {http://dl.acm.org/citation.cfm?doid=3230977.3230991},
year = {2018}
}

@phdthesis{coull2008snoopie,
 abstract = {Learning to program is recognised nationally and internationally as a complex task that novices find challenging. There exist many endeavours to support the novice in this activity, including software tools that aim to provide a more supportive environment than that provided by standard software facilities, together with schemes that reduce the underlying complexity of programming by providing accessible micro-worlds in which students develop program code. Existing literature recognises that learning to program is difficult because of the need to learn the rules and operation of the language (program formulation), and the concurrent need to interpret problems and recognise the required components for that problem (problem formulation). This thesis describes a new form of learning support that addresses that dual task of program and problem formulation. A review of existing teaching tools that support the novice programmer leads to a set of requirements for a support tool that encompasses the processes of both program and problem formulation. This set of requirements is encapsulated in a conceptual framework for software tool development. The framework demonstrates how the requirements of a support tool can be met by performing a series of automated analyses at different stages in the student's development of a solution. An extended series of observations demonstrates the multi-faceted nature of problems that students encounter whilst they are learning to program and how these problems can be mapped onto the different levels of programs and problem formulation. These observations and the framework were used to inform the development ofSNOOPIE, a sample instantiation of the framework for learning Java programming. This software tool has been fully evaluated and demonstrated to have a significant impact on the learning process for novice Java programmers. SNOOPIE is fully integrated into a current introductory programming module and a future programme of work is being established that will see SNOOPIE integrated with other established software tools.},
 address = {St Andrews, Scotland},
 author = {Coull, Natalie J},
 file = {::},
 school = {University of St Andrews},
 keywords = {enhancement,guidelines},
 mendeley-tags = {enhancement,guidelines},
 pages = {236},
 title = {{SNOOPIE: Development of a Learning Support Tool for Novice Programmers within a Conceptual Framework}},
 url = {http://hdl.handle.net/10023/522},
 year = {2008}
}

@inproceedings{stripeikaite2017skipping,
abstract = {As programming becomes one of the most sought-after skills in today's digital world, the demand for computer literate coders is ever-increasing. However, programming novices face many challenges when learning programming theory and syntax, showing the highest failure rates at university level. This study proposes a new syntax-based serious game solution which teaches programming novices C-Style syntax and programming theory. It aims to provide an alternative to block-based programming environment tools like Scratch and aims to better understand how novice programmers learn best today. The proposed solution focuses on two key areas which have shown the most promising results: motivation and syntax. The solution also focuses on rein-forcing good programming practices to provide the novice with guidance to transition them to computer programming. The results show that the proposed application users saw an increase of 62.5% in their programming test results in comparison to 34.17% in Scratch users. Overall, the participants using the proposed tool were more positive about their experience, describing it as 'very fun' and 'a very good educational experience!'. Results suggested that partici-pants were not intimidated by the syntax where 9 out of 10 participants have said that they feel more comfortable about programming in the future. Not only that, but encouragingly, novices wanted the proposed application " to be more complex " challenging the perceptions novices have about programming. Overall, the results support the hypothesis that the proposed syntax-based application is a more motivational and effective tool in transitioning novices to computer programming.},
annote = {Only one mention of compiler errors: "The error messages are worded in a way that would allow a novice to understand what the error means specifically in the task they are working in. This"},
author = {StripeikaitÄ, Iveta},
booktitle = {Joint International Conference on Serious Games},
doi = {10.1007/978-3-319-70111-0_30},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/StripeikaitÄ - 2017 - Skipping the Baby Steps The Importance of Teaching Practical Programming Before Programming Theory.pdf:pdf},
isbn = {9783319701103},
issn = {16113349},
keywords = {Learning environment,Motivation,Practice learning,Serious games,Syntax,difficulties,justification},
mendeley-tags = {difficulties,justification},
pages = {319--330},
title = {{Skipping the Baby Steps: The Importance of Teaching Practical Programming Before Programming Theory}},
volume = {10622 LNCS},
year = {2017}
}

@inproceedings{thiselton2019enhancing,
 abstract = {Background: Compilers tend to produce cryptic and uninformative error messages, leaving programmers confused and requiring them to spend precious time to resolve the underlying error. To find help, programmers often take to online question-and-answer forums such as Stack Overflow to start discussion threads about the errors they encountered. Aims: We conjecture that information from Stack Overflow threads which discuss compiler errors can be automatically collected and repackaged to provide programmers with enhanced compiler error messages, thus saving programmers' time and energy. Method: We present Pycee, a plugin integrated with the popular Sublime Text IDE to provide enhanced compiler error messages for the Python programming language. Pycee automatically queries Stack Overflow to provide customised and summarised information within the IDE. We evaluated two Pycee variants through a think-aloud user study during which 16 programmers completed Python programming tasks while using Pycee. Results: The majority of participants agreed that Pycee was helpful while completing the study tasks. When compared to a baseline relying on the official Python documentation to enhance compiler error messages, participants generally preferred Pycee in terms of helpfulness, citing concrete suggestions for fixes and example code as major benefits. Conclusions: Our results confirm that data from online sources such as Stack Overflow can be successfully used to automatically enhance compiler error messages. Our work opens up venues for future work to further enhance compiler error messages as well as to automatically reuse content from Stack Overflow for other aspects of programming.},
 archivePrefix = {arXiv},
 arxivId = {1906.11456},
 author = {Thiselton, Emillie and Treude, Christoph},
 keywords = {Compiler errors,Stack Overflow,computer science,difficulties,empirical,enhancement,guidelines,justification,retag,software engineering,think-aloud},
 mendeley-tags = {difficulties,empirical,enhancement,guidelines,justification,retag},
 month = {Jun},
 pages = {arXiv:1906.11456},
 title = {{Enhancing Python Compiler Error Messages via Stack Overflow}},
 url = {http://arxiv.org/abs/1906.11456},
 year = {2019},
 booktitle = {Proceedings of the 19th International Symposium on Empirical Software Engineering and Measurement},
 series = {ESEM '19},
}

@article{pane1996usability,
abstract = {This report reviews and organizes research about novice programmers. Over the past two decades, many aspects of novice programming have been investigated, resulting in the discovery of important facts and tradeoffs about what makes programming difficult to learn, and about the effectiveness of existing languages, environments, and methods of instruction. However, because this research is dispersed throughout the literature, it is difficult for designers of new programming systems to consider all of the issues collectively. The result is that most new systems are built primarily around technical objectives, perhaps considering only a subset of the usability issues summarized here. In addition to providing a checklist of issues that should be considered in the design of future systems, this report can be used to help researchers identify fruitful topics of future novice programming research.},
author = {Pane, John and Myers, Brad},
file = {::},
isbn = {CMU-CS-96-132},
journal = {Education},
keywords = {empirical studies programmers,end user,guidelines,human computer interaction,justification,novice programming environments,programming,programming languages,usability},
mendeley-tags = {guidelines,justification},
number = {August},
pages = {78},
title = {{Usability Issues in the Design of Novice Programming Systems}},
url = {http://repository.cmu.edu/isr https://www.researchgate.net/publication/200085843_Usability_Issues_in_the_Design_of_Novice_Programming_Systems http://repository.cmu.edu/isr/820/},
year = {1996}
}

@inproceedings{cormack1989lr,
 abstract = {For a context-free grammar G, a construction is given to produce an LR parser that recognizes any substring of the language generated by G. The construction yields a conflict-free (deterministic) parser for the bounded context class of grammars (Floyd, 1964). The same wnstruction yields either a left-to-right or right-to-left substring parser, as required to implement Noncorrecting Syntax Error Recovery as proposed by Richter (1985). Experience in constructing a substring parser for Pascal is described.},
 mendeley-tags = {technical},
 author = {Cormack, G. V.},
 title = {An LR Substring Parser for Noncorrecting Syntax Error Recovery},
 booktitle = {Proceedings of the ACM SIGPLAN 1989 Conference on Programming Language Design and Implementation},
 series = {PLDI '89},
 year = {1989},
 isbn = {0-89791-306-X},
 location = {Portland, Oregon, USA},
 pages = {161--169},
 url = {http://doi.acm.org/10.1145/73141.74832},
 doi = {10.1145/73141.74832},
 acmid = {74832},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{storey2004improving,
abstract = {This paper describes how we are designing a set of plug-ins to improve teaching and learning of Java programming. Based on requirements gathered from key project stakeholders, the plug-ins include perspectives for both students and instructors. These plug-ins are being developed as part of the Gild project. The paper summarizes our design process from requirements gathering through to initial tool evaluation. In particular, it details the student perspective and describes how it addresses many pedagogical issues facing computer science educators today. Gild is currently deployed and in use at the University of Victoria.},
address = {Anaheim, California},
author = {Storey, Margaret-Anne and Damian, Daniela and Michaud, Jeff and Myers, Del and Mindel, Marcellus and German, Daniel and Sanseverino, Mary and Hargreaves, Elizabeth},
booktitle = {Proceedings of the 2003 OOPSLA Workshop on Eclipse Technology eXchange},
doi = {10.1145/965660.965668},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Storey et al. - 2003 - Improving the Usability of Eclipse for Novice Programmers.pdf:pdf},
keywords = {pedagogy},
mendeley-tags = {pedagogy},
pages = {35--39},
publisher = {ACM},
title = {{Improving the Usability of Eclipse for Novice Programmers}},
year = {2003}
}
@article{ott2015illustrating,
 abstract = {In higher education, quality feedback for students is regarded as one of the main contributors to improve student learning. Feedback to support students' development into self-regulated learners, who set their own goals, self-monitor their actual performance according to these goals, and adjust learning strategies if necessary, is seen as an important aspect of contemporary feedback practice. However, only those students who are aware of the course demands and the impact of certain study behaviors on their final achievement are in a position to self-regulate their learning on an informed basis. Learning analytics is an emerging field primarily concerned with using predictive models to inform educational instructors or learners about projected study outcomes. In a scoping study, over 200 students of an introductory programming course (CS1) were supplied with information revealing performance indicators for different stages on the course and projecting final performance for various achievement levels. The s...},
 author = {Ott, Claudia and Robins, Anthony and Haden, Patricia and Shephard, Kerry},
 doi = {10.1080/08993408.2015.1033129},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Ott et al. - 2015 - Illustrating performance indicators and course characteristics to support students' self-regulated learning in CS1.pdf:pdf},
 issn = {17445175},
 journal = {Computer Science Education},
 keywords = {CS1,feedback,infographic,performance,self-regulated learning},
 mendeley-tags = {performance},
 number = {2},
 pages = {174--198},
 publisher = {Routledge},
 title = {{Illustrating performance indicators and course characteristics to support students' self-regulated learning in CS1}},
 url = {http://dx.doi.org/10.1080/08993408.2015.1033129},
 volume = {25},
 year = {2015}
}
@inproceedings{edwards2017investigating,
abstract = {Research on students learning to program has produced studies on both compile-time errors (syntax errors) and run-time errors (exceptions). Both of these types of errors are natural targets, since detection is built into the programming language. In this paper, we present an empirical investigation of static analysis errors present in syntactically correct code. Static analysis errors can be revealed by tools that examine a program's source code, but this error detection is typically not built into common programming languages and instead requires separate tools. Static analysis can be used to check formatting or commenting expectations, but it also can be used to identify problematic code or to find some kinds of conceptual or logic errors. We study nearly 10 million static analysis errors found in over 500 thousand program submissions made by students over a five-semester period. The study includes data from four separate courses, including a non-majors introductory course as well as the CS1/CS2/CS3 sequence for CS majors. We examine the differences between the error rates of CS major and non-major beginners, and also examine how these patterns change over time as students progress through the CS major course sequence. Our investigation shows that while formatting and Javadoc issues are the most common, static checks that identify coding flaws that are likely to be errors are strongly correlated with producing correct programs, even when students eventually fix the problems. With experience, students produce fewer errors, but the errors that are most frequent are consistent between both computer science majors and non-majors, and across experience levels. These results can highlight student struggles or misunderstandings that have escaped past analyses focused on syntax or run-time errors.},
address = {Tacoma, Washington, USA},
author = {Edwards, Stephen H. and Kandru, Nischel and Rajagopal, Mukund B.M.},
doi = {10.1145/3105726.3106182},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Edwards, Kandru, Rajagopal - 2017 - Investigating Static Analysis Errors in Student Java Programs.pdf:pdf},
keywords = {Checkstyle,Java,PMD,Web-CAT,coding standard,coding style,documentation,empirical,errors-only,formatting,performance,static analysis},
mendeley-tags = {empirical,errors-only,performance},
pages = {65--73},
publisher = {ACM},
title = {{Investigating Static Analysis Errors in Student Java Programs}},
year = {2017}
}
@article{dillig2012automated,
abstract = {When program verification tools fail to verify a program, either the program is buggy or the report is a false alarm. In this situation, the burden is on the user to manually classify the report, but this task is time-consuming, error-prone, and does not utilize facts already proven by the analysis. We present a new technique for assisting users in classifying error reports. Our technique computes small, relevant queries presented to a user that capture exactly the information the analysis is missing to either discharge or validate the error. Our insight is that identifying these missing facts is an instance of the abductive inference problem in logic, and we present a new algorithm for computing the smallest and most general abductions in this setting. We perform the first user study to rigorously evaluate the accuracy and effort involved in manual classification of error reports. Our study demonstrates that our new technique is very useful for improving both the speed and accuracy of error report classification. Specifically, our approach improves classification accuracy from 33% to 90% and reduces the time programmers take to classify error reports from approximately 5 minutes to under 1 minute.},
author = {Dillig, Isil and Dillig, Thomas and Aiken, Alex},
doi = {10.1145/2345156.2254087},
file = {::},
isbn = {9781450312059},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {algorithms,are inevitable no matter,experimen-,false alarms,how sophisticated the reasoning,in general,languages,performed,since program verification is,technical,undecidable,verification},
mendeley-tags = {technical},
number = {6},
pages = {181--192},
title = {{Automated error diagnosis using abductive inference}},
volume = {47},
year = {2012}
}
@inproceedings{holland2009jlatte,
abstract = {We present J-LATTE, a constraint-based intelligent tutoring system that teaches a subset of the Java programming language. J-LATTE supports two modes: concept mode, in which the student designs the program without having to specify contents of statements, and coding mode, in which the student completes the code. We present the style of interaction with J-LATTE, its interface, domain model and the student modeling approach. We also report the results of a study we conducted in an introductory programming course. Although we did not have enough participants to obtain statistical significance, the results show very promising trends indicating that students learned the constraints.},
address = {Hong Kong},
author = {Holland, Jay and Mitrovic, Antonija and Martin, Brent},
booktitle = {Proceedings of the 17th International Conference on Computers in Education, ICCE},
file = {::},
isbn = {9789868473539},
keywords = {empirical,enhancement},
mendeley-tags = {empirical,enhancement},
pages = {142--146},
publisher = {Asia-Pacific Society for Computers in Education},
title = {{J-LATTE : A Constraint-based Tutor for Java}},
url = {http://ir.canterbury.ac.nz/bitstream/10092/3110/1/12619603_Jay-ICCE2009-Camera-Ready.pdf},
year = {2009}
}
@article{moons2009rationale,
abstract = {The EduVisor software visualization component is a new pedagogical tool specifically developed to address some wide-spread problems in teaching object-oriented technology to novice programmers. The visualization tool is integrated in a world-class IDE, and shows the students the structure of their own creations at runtime. EduVisor is based on a solid grounding in literature and over 25 years of combined experience in teaching a CS1 course. With this component we have set the goal of helping our students progress faster through the most difficult initial stages of programming.},
author = {Moons, Jan and {De Backer}, Carlos},
doi = {10.1016/j.entcs.2008.12.049},
file = {::},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {CS1,Java programming,Program visualization,anecdotal,errors-only,runtime-errors},
mendeley-tags = {anecdotal,errors-only,runtime-errors},
pages = {57--65},
title = {{Rationale Behind the Design of the EduVisor Software Visualization Component}},
volume = {224},
year = {2009}
}

@inproceedings{flowers2005empowering,
abstract = {All freshmen at the United States Military Academy take an information technology course in which they learn fundamental programming skills using Java. For novice programmers, Java's compile-time errors can be undecipherable. Instructors noted that students made the same mistakes and became frustrated trying to understand the error messages and correct their code often wasting hours of time on a simple error. Given our focus on problem solving in the course as opposed to debugging code, we needed a new approach. Our initial premise was that we could significantly enhance the student experience and instructor workload by catching and explaining the top fifty programming errors in a pre-compiler. To empower the students, we developed a program called Gauntlet that pre-processes student source code and explains in layman's terms each of the syntax errors. Gauntlet also finds many common novice-level semantic errors that do not necessarily result in syntax errors. Gauntlet empowers students to solve their own problems with system development efforts.},
address = {Savannah, GA, USA},
author = {Flowers, Thomas and Carver, Curtis and Jackson, James},
booktitle = {34th ASEE/IEEE Annual Frontiers in Education, 2004. FIE 2004},
doi = {10.1109/fie.2004.1408551},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Flowers, Carver, Jackson - 2004 - Empowering students and building confidence in novice programmers through gauntlet.pdf:pdf},
keywords = {Active Learning,Information Technology,Programming,anecdotal,enhancement,pre-guidelines},
mendeley-tags = {anecdotal,enhancement,pre-guidelines},
pages = {T3H10--13},
publisher = {IEEE},
title = {{Empowering students and building confidence in novice programmers through gauntlet}},
url = {https://ieeexplore.ieee.org/document/1408551},
year = {2004}
}


@phdthesis{johansen2015errors,
 abstract = {Novice programmers make a lot of programming errors as they strive to become experts. This is a known fact to teaching faculty in introductory programming courses. The errors play a major role in both formative and summative assessment of the students. The Computer Science research of today trends towards focusing on automatic assessment of program, becoming more remote from the student who wrote the program. In an attempt to create a better understanding of the novice programmers and the errors they make, this thesis takes a look at the errors novice programmers produce in programming assignments and the misunderstandings that may have caused them. We use a qualitative approach to analyze assignments, interviews and observations with 23 students of a second semester course in object-oriented programming, using Java, at the University of Oslo. 33 solutions to mandatory assignments were analyzed to identify errors. 14 students were interviewed about their solutions to identify the misunderstandings that caused the errors we identified. Nine students participated in think-aloud observations to add further insights into how students of the targeted course approach problem solving. Finally the misunderstandings are analyzed to review the feasibility of using misunderstandings to guide formative and summative assessment. We have identified multiple student errors in both result and design. Multiple errors and misunderstandings revolved around generic class parameters, a topic that not much existing research covers. Our findings suggest that misunderstandings considering the principles of object-oriented design lead to further misunderstandings about the important aspects that must be considered to write good programs. We did not find a feasible way to use pre-identified misunderstandings as a sole metric for assessment but believe our research may be used to help create a statistical analysis of the frequency of misunderstandings causing errors. With a larger amount of participants a study could supply examiners with an additional tool to help them gain insight into the understanding of the students they assess.},
 author = {Johansen, Mathias Johan},
 file = {::},
 keywords = {difficulties,empirical,justification,pre-guidelines},
 mendeley-tags = {difficulties,empirical,justification,pre-guidelines},
 pages = {159},
 school = {University of Oslo},
 title = {{Errors and Misunderstandings Among Novice Programmers Assessing the Student Not the Program}},
 type = {Masters Thesis},
 url = {https://www.duo.uio.no/handle/10852/49045},
 year = {2015}
}

@inproceedings{mciver2000effect,
abstract = {This paper describes the design and testing of a new introductory programming language, GRAIL1. GRAIL was designed to minimise student syntax errors, and hence allow the study of the impact of syntax errors on learning to program. An experiment was conducted using students learning programming for the first time. The students were split into two groups, one group learning LOGO and the other GRAIL. The resulting code was then analysed for syntax and logic errors. The groups using LOGO made more errors than the groups using GRAIL, which shows that choice of programming language can have a substantial impact on error rates of novice programmers.},
address = {Newcastle, UK},
author = {McIver, Linda},
booktitle = {12th Annual Workshop of the Psychology of Programming Interest Group (PPIG '00)},
editor = {Blackwell, A.F. and Bilotta, E.},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Mciver - 2000 - The Effect of Programming Language on Error Rates of Novice Programmers.pdf:pdf},
keywords = {barriers to programming,empirical,errors-only,novice programmers},
mendeley-tags = {empirical,errors-only},
number = {April},
pages = {181--192},
title = {{The effect of programming language on error rates of novice programmers}},
url = {www.ppig.org http://www.ppig.org/papers/12th-mciver.pdf},
year = {2000}
}

@inproceedings{denny2012syntax,
 abstract = {Identifying and correcting syntax errors is a challenge all novice programmers confront. As educators, the more we understand about the nature of these errors and how students respond to them, the more effective our teaching can be. It is well known that just a few types of errors are far more frequently encountered by students learning to program than most. In this paper, we examine how long students spend resolving the most common syntax errors, and discover that certain types of errors are not solved any more quickly by the higher ability students. Moreover, we note that these errors consume a large amount of student time, suggesting that targeted teaching interventions may yield a significant payoff in terms of increasing student productivity.},
 mendeley-tags = {empirical,errors-only},
 author = {Denny, Paul and Luxton-Reilly, Andrew and Tempero, Ewan},
 title = {All Syntax Errors Are Not Equal},
 booktitle = {Proceedings of the 17th ACM Annual Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '12},
 year = {2012},
 isbn = {978-1-4503-1246-2},
 location = {Haifa, Israel},
 pages = {75--80},
 url = {http://doi.acm.org/10.1145/2325296.2325318},
 doi = {10.1145/2325296.2325318},
 acmid = {2325318},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {assessment, codewrite, drill and practice, java, syntax errors},
} 

@article{simon2007debugging,
 abstract = {This paper reports on the efforts of an ITiCSE 2007 working group with the aim of producing a publicly available, searchable, tagable, Web 2.0-style repository of short debugging videos. This repository may be accessed from http://debug.csi.muohio.edu/. The videos are aimed at novice Java programmers who may need help debugging when none is available (e.g. in the middle of the night before the homework is due). However, it could also be used by instructors of introductory programming. Here we discuss our motivation in creating this repository and detail the process we followed and the products we produced.},
 author = {Simon, Beth and Fitzgerald, Sue and McCauley, Ren{\'e}e and Haller, Susan and Hamer, John and Hanks, Brian and Helmick, Michael T. and Mostr\"{o}m, Jan Erik and Sheard, Judy and Thomas, Lynda},
 title = {Debugging Assistance for Novices: A Video Repository},
 booktitle = {Proceedings of the 2007 ITiCSE Working Group Reports},
 series = {ITiCSE-WGR '07},
 year = {2007},
 location = {Dundee, Scotland},
 pages = {137--151},
 url = {http://doi.acm.org/10.1145/1345443.1345437},
 doi = {10.1145/1345443.1345437},
 acmid = {1345437},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, Java, debugging, introductory programming, novice programmers, video, web 2.0},
}

@article{Kurtz1978BASIC,
author = {Kurtz, Thomas},
doi = {10.1145/960118.808376},
file = {::},
journal = {ACM SIGPLAN Notices - Special issue: History of programming languages conference},
keywords = {pedagogy},
mendeley-tags = {pedagogy},
number = {8},
pages = {103--118},
title = {{BASIC}},
volume = {13},
year = {1978}
}
@techreport{shneiderman1976exploratory,
abstract = {The techniques of cognitive psychological experimentation can help resolve specific issues in programming and explore the broader issues of programmer behavior. This paper describes the methodological questions of such experimentation and presents two exploratory experiments: a memorization task and a comparison of the arithmetic and logical IF statements in FORTRAN.},
author = {Shneiderman, Ben},
booktitle = {International Journal of Computer and Information Sciences},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Shneiderman - 1976 - Exploratory Programmer Experiments in Behavior.pdf:pdf},
keywords = {Programming,cognitive psychology,conditional branching,errors-only,human factors,justification,memorization,programmers,psychological experimenta-tions},
mendeley-tags = {errors-only,justification},
number = {2},
pages = {123 -- 143},
title = {{Exploratory Programmer Experiments in Behavior}},
volume = {5},
year = {1976}
}
@article{litecky1976study,
abstract = {This paper provides data on Cobol error frequency for correction of errors in student-oriented compilers, improvement of teaching, and changes in programming language. Cobol was studied because of economic importance, widespread usage, possible error-inducing design, and lack of research. The types of errors were identified in a pilot study; then, using the 132 error types found, 1,777 errors were classified in 1,400 runs of 73 Cobol students. Error density was high: 20 percent of the types contained 80 percent of the total frequency, which implies high potential effectiveness for software-based correction of Cobol. Surprisingly, only four high-frequency errors were error-prone, which implies minimal error inducing design. 80 percent of Cobol misspellings were classifiable in the four error categories of previous researchers, which implies that Cobol misspellings are correctable by existent algorithms. Reserved word usage was not error-prone, which implies minimal interference with usage of reserved words. Over 80 percent of error diagnosis was found to be inaccurate. Such feedback is not optimal for users, particularly for the learning user of Cobol.},
author = {Litecky, Charles R. and Davis, Gordon B.},
doi = {10.1145/359970.359991},
file = {::},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {empirical,pre-guidelines},
mendeley-tags = {empirical,pre-guidelines},
number = {1},
pages = {33--38},
title = {{A Study of Errors, Error-proneness, and Error Diagnosis in Cobol}},
volume = {19},
year = {1976}
}

@phdthesis{harker2017examining,
 abstract = {Programs written by novices programmers often contain errors. Previous work shows students struggle when compiler error messages are inaccurate, misleading, or both. Loss of productivity caused by poor error messages has not been thoroughly explored in the literature. This thesis examines how enhanced compilers improve the experiences of those learning to program. The thesis follows fifty non-CS majors with little programming experience through a one-semester CS1-like course at the University of Northern British Columbia, a small western Canadian university. Half of the participants used the enhanced compiler for Java named Decaf while the other half used the standard Java compiler. The evidence shows that Decaf is beneficial with regards to the number and types of errors generated, productivity, frustration, and confidence in programming ability, and compares results with the literature.},
 author = {Harker, Devon},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Harker - 2017 - Examining the Effects of Enhanced Compilers on Student Productivity.pdf:pdf},
 keywords = {difficulties,empirical,enhancement,justification,pedagogy,performance,pre-guidelines,technical},
 mendeley-tags = {difficulties,empirical,enhancement,justification,pedagogy,performance,pre-guidelines,technical},
 title = {{Examining the Effects of Enhanced Compilers on Student Productivity}},
 type= {Masters Thesis},
 year = {2017},
 url={https://unbc.arcabc.ca/islandora/object/unbc\%3A58897},
 school={University of Northern British Columbia},
}

@article{findler2002drscheme,
 abstract = {Teaching introductory computing courses with Scheme elevates the intellectual level of the course and thus makes the subject more appealing to students with scientific interests. Unfortunately, the poor quality of the available programming environments negates many of the pedagogic advantages. To overcome this problem, we have developed DrScheme, a comprehensive programming environment for Scheme. It fully integrates a graphics-enriched editor, a multi-lingual parser that can process a hierarchy of syntactically restrictive variants of Scheme, a functional read-eval-print loop, and an algebraically sensible printer. The environment catches the typical syntactic mistakes of beginners and pinpoints the exact source location of run-time exceptions. DrScheme also provides an algebraic stepper, a syntax checker and a static debugger. The first reduces Scheme programs, including programs with assignment and control effects, to values (and effects). The tool is useful for explaining the semantics of linguistic facilities and for studying the behavior of small programs. The syntax checker annotates programs with font and color changes based on the syntactic structure of the pro-gram. It also draws arrows on demand that point from bound to binding occurrences of identifiers. The static debugger, roughly speaking, provides a type inference system with explanatory capabilities. Preliminary experience with the environment shows that Rice University students and it helpful and that they greatly prefer it to shell- or Emacs-based systems.},
 journal = {Journal of Functional Programming},
 mendeley-tags = {anecdotal,difficulties,enhancement,pre-guidelines},
 author = {Findler, Robert Bruce and Clements, John and Flanagan, Cormac and Flatt, Matthew and Krishnamurthi, Shriram and Steckler, Paul and Felleisen, Matthias},
 title = {DrScheme: A Programming Environment for Scheme},
 issue_date = {March 2002},
 volume = {12},
 number = {2},
 month = mar,
 year = {2002},
 issn = {0956-7968},
 pages = {159--182},
 url = {http://dx.doi.org/10.1017/S0956796801004208},
 doi = {10.1017/S0956796801004208},
 acmid = {968416},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
}

@inproceedings{parihar2017automatic,
 abstract = {We present GradeIT, a system that combines the dual objectives of automated grading and program repairing for introductory programming courses (CS1). Syntax errors pose a significant challenge for testcase-based grading as it is difficult to differentiate between a submission that is almost correct and has some minor syntax errors and another submission that is completely off-the-mark. GradeIT also uses program repair to help in grading submissions that do not compile. This enables running testcases on submissions containing minor syntax errors, thereby awarding partial marks for these submissions (which, without repair, do not compile successfully and, hence, do not pass any testcase). Our experiments on 15613 submissions show that GradeIT results are comparable to manual grading by teaching assistants (TAs), and do not suffer from unintentional variability that happens when multiple TAs grade the same assignment. The repairs performed by GradeIT enabled successful compilation of 56\% of the submissions having compilation errors, and resulted in an improvement in marks for 11\% of these submissions.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Parihar et al. - 2017 - Automatic Grading and Feedback Using Program Repair for Introductory Programming Courses.pdf:pdf},
 mendeley-tags = {difficulties,empirical,enhancement,justification,pre-guidelines},
 author = {Parihar, Sagar and Dadachanji, Ziyaan and Singh, Praveen Kumar and Das, Rajdeep and Karkare, Amey and Bhattacharya, Arnab},
 title = {Automatic Grading and Feedback Using Program Repair for Introductory Programming Courses},
 booktitle = {Proceedings of the 22nd ACM Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '17},
 year = {2017},
 isbn = {978-1-4503-4704-4},
 location = {Bologna, Italy},
 pages = {92--97},
 url = {http://doi.acm.org/10.1145/3059009.3059026},
 doi = {10.1145/3059009.3059026},
 acmid = {3059026},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automated grading, cs1, programming assignments},
}

@inproceedings{watson2012bluefix,
 abstract = {Feedback is regarded as one of the most important influences on student learning and motivation. But standard compiler feedback is designed for experts - not novice programming students, who can find it difficult to interpret and understand. In this paper we present BlueFix, an online tool currently integrated into the BlueJ IDE which is designed to assist programming students with error diagnosis and repair. Unlike existing approaches, BlueFix proposes a feedback algorithm based upon frameworks combined from the HCI and Pedagogical domains, which can provide different students with dynamic levels of support based upon their compilation behaviour. An evaluation revealed that students viewed our tool positively and that our methodology could identify appropriate fixes for uncompilable source code with a significantly higher rate of speed and precision over related techniques in the literature.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Watson, Li, Godwin - 2012 - BlueFix using crowd-sourced feedback to support programming students in error diagnosis and repair.pdf:pdf},
 mendeley-tags = {difficulties,empirical,enhancement,justification,performance,pre-guidelines},
 author = {Watson, Christopher and Li, Frederick W. B. and Godwin, Jamie L.},
 title = {BlueFix: Using Crowd-sourced Feedback to Support Programming Students in Error Diagnosis and Repair},
 booktitle = {Proceedings of the 11th International Conference on Advances in Web-Based Learning},
 series = {ICWL'12},
 year = {2012},
 isbn = {978-3-642-33641-6},
 location = {Sinaia, Romania},
 pages = {228--239},
 url = {http://dx.doi.org/10.1007/978-3-642-33642-3_25},
 doi = {10.1007/978-3-642-33642-3_25},
 acmid = {2415431},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
 keywords = {compiler errors, crowd fixes, feedback, programming education},
}

@inproceedings{schorsch1995cap,
 abstract = {Student programmers have difficulty finding and fixing syntax, logic and style errors in their programs. The Code Analyzer for Pascal (CAP) analyzes programs that use a subset of the Pascal language and provides user-friendly feedback on the errors that it finds. This paper describes CAP and reports its use in teaching introductory programming at the United States Air Force Academy.},
 mendeley-tags = {difficulties,empirical,enhancement,justification},
 author = {Schorsch, Tom},
 title = {CAP: An Automated Self-assessment Tool to Check Pascal Programs for Syntax, Logic and Style Errors},
 booktitle = {Proceedings of the Twenty-sixth SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '95},
 year = {1995},
 isbn = {0-89791-693-X},
 location = {Nashville, Tennessee, USA},
 pages = {168--172},
 url = {http://doi.acm.org/10.1145/199688.199769},
 doi = {10.1145/199688.199769},
 acmid = {199769},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{mciver1996seven,
 abstract = {We discuss seven undesirable features common to many programming languages used to teach first-time program- mers, and illustrate typical pedagogical difficulties which stem from them with examples drawn from the program- ming languages ABC, Ada, C, C++, Eiffel, Haskell, LISP, Modula 3, Pascal, Prolog, Scheme, and Turing. We propose seven language design (or selection) principles which may reduce the incidence of such undesirable features.},
 address = {Dunedin, New Zealand},
 annote = {Discusses seven undesirable features that are common to many programming languages used to teach first-time programmers: (1) less is more; (2) more is more; (3) grammatical traps; (4) hardware dependence; (5) backwards compatibility; (6) excessive cleverness; and (7) violation of expectations. We illustrate typical pedagogical difficulties which stem from these features, with examples drawn from the programming languages ABC, Ada, C, C++, Eiffel, Haskell, LISP, Modula 3, Pascal, Prolog, Scheme and Turing. We propose seven language design (or selection) principles which may reduce the incidence of such undesirable features: (1) start where the novice is; (2) differentiate semantics with syntax; (3) make the syntax readable and consistent; (4) provide a small and orthogonal set of features; (5) be especially careful with I/O; (6) provide better error diagnosis; and (7) choose a suitable level of abstraction},
 author = {McIver, L. and Conway, D.},
 booktitle = {International Conference on Software Engineering: Education and Practice},
 series = {SEEP '96},
 doi = {10.1109/SEEP.1996.534015},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/McIver, Conway - 1996 - Seven Deadly Sins of Introductory Programming Language Design.pdf:pdf},
 isbn = {0818673796},
 keywords = {anecdotal,guidelines},
 mendeley-tags = {anecdotal,guidelines},
 pages = {309--316},
 publisher = {IEEE Computer Society},
 title = {{Seven Deadly Sins of Introductory Programming Language Design}},
 year = {1996}
}

@misc{toomey2011quantifying,
 abstract = {Existing research shows that students learning to program for the first time often make the same types of errors. Tools have been written to give students useful feedback when they make these errors, but no research has been done to determine the effectiveness of these tools. This paper is the preliminary result of a long-term study to answer the research question: will timely reporting of novice programming errors in an understandable format reduce the incidence of these errors? We report on a tool called Arjen which is designed to quantify the errors made by novice programmers. We give the results of a pilot study where first programming students used Arjen as part of their learning environment.},
 address = {Gold Coast, Australia},
 annote = {This report is unpublished and has no clear date. The latest reference is from 2008. I have emailed the author to see if we can lock down the date.},
 author = {Toomey, Warren},
 file = {::},
 institution = {Bond University},
 keywords = {Common programming errors,Computer Science Education,Java,Programming,empirical,enhancement,pre-guidelines},
 mendeley-tags = {empirical,enhancement,pre-guidelines},
 pages = {5},
 title = {{Quantifying The Incidence of Novice Programmers' Errors}},
  year = {2011},
 url = {https://minnie.tuhs.org/Programs/BlueJErrors/arjen_draft.pdf},
 OPTyear = {2011}
}

@article{Harvey1982Why,
 abstract = {Logo is a dialect of Lisp designed for educational use. Like other dialects of Lisp, Logo is a general-purpose programming language with special emphasis on symbolic computing and on the functional programming style. Three things give Logo its special educational focus: a simplified syntax, detailed attention to the programmer's metaphors for computational processes in the naming of primitive procedures and the wording of error messages, and a collection of application areas (of which the most famous is turtle graphics) that combine inherent interest with open-ended intellectual content.},
 address = {Chichester, UK},
 author = {Harvey, Brian},
 journal = {Byte},
 mendeley-tags = {pedagogy},
 title = {{Why Logo?}},
 year = {1982},
 volume = {7},
 number = {8},
 month = {Aug},
 url = {http://cmkfutures.com/wp-content/uploads/2017/06/Why-Logo-by-Brian-Harvey.pdf},
 pages = {163--195},
}


@inproceedings{helminen2010jype,
abstract = {Based on research into learning programming and a review of program visualization research, we designed an educational software tool that aims to target students' apparent fragile knowledge of elementary programming which manifests as difficulties in tracing and writing even simple programs. Most existing tools build on a single supporting technology and focus on one aspect of learning. For example, visualization tools support the development of a conceptual-level understanding of how programs work, and automatic assessment tools give feedback on submitted tasks. We implemented a combined tool that closely integrates programming tasks with visualizations of program execution and thus lets students practice writing code and more easily transition to visually tracing it in order to locate programming errors. In this paper we present Jype, a web-based tool that provides an environment for visualizing the line-by-line execution of Python programs and for solving programming exercises with support for immediate automatic feedback and an integrated visual debugger. Moreover, the debugger allows stepping back in the visualization of the execution as if executing in reverse. Jype is built for Python, when most research in programming education support tools revolves around Java.},
address = {Salt Lake City, Utah, USA},
author = {Helminen, Juha and Malmi, Lauri},
booktitle = {Proceedings of the 5th International Symposium on Software Visualization, SOFTVIS},
doi = {10.1145/1879211.1879234},
file = {::},
keywords = {Human Factors,pedagogy},
mendeley-tags = {pedagogy},
pages = {153--162},
publisher = {ACM},
title = {{Jype - A Program Visualization and Programming Exercise Tool for Python}},
url = {https://dl.acm.org/citation.cfm?id=1879234},
year = {2010}
}

@phdthesis{hill2008developing,
 abstract = {Many novice programmers find compiling and debugging their programs confusing and frustrating. This is particularly true for older, low level programming languages such as C where many compilers are aimed at the experienced programmer and as such tend to generate generic, technically focused error messages. For the novice these error messages merely compound their frustration as they often do little to indicate exactly what the error encountered is, or how it might be fixed. This project aims to remedy these shortcomings by investigating the most recent tools and developments in compilation and applying them to show what can be achieved to help the novice C programmer.},
 author = {Hill, Richard},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Hill - 2008 - Developing a Teaching Compiler for Students Learning the C Programming Language.pdf:pdf},
 keywords = {empirical,enhancement,pedagogy,pre-guidelines,technical},
 mendeley-tags = {empirical,enhancement,pedagogy,pre-guidelines,technical},
 school = {University of Bath},
 title = {{Developing a Teaching Compiler for Students Learning the C Programming Language}},
 type = {Bachelor of Science Dissertation},
 year = {2008}
}

@inproceedings{wexelblat1976maxims,
 abstract = {Communication with the computer is by artificial languages: programming languages and command languages, as well as ad hoc languages of messages. While many such languages are sufficiently rich to permit proper expression of what must be said, some are so limited or inconsistent that a user must go to needless effort in learning the language and using it to communicate successfully with the computer. As part of the final exam of a course on the design of computer languages for human use, students were asked to suggest what the language designer can do to make the programming process as difficult as possible. This paper contains some of the more popular responses, annotated with examples from current programming languages and systems.1},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Wexelblat - 1976 - Maxims for Malfeasant Designers, or How to Design Languages to Make Programming As Difficult As Possible.pdf:pdf},
 mendeley-tags = {anecdotal,justification,pre-guidelines},
 author = {Wexelblat, Richard L.},
 title = {Maxims for Malfeasant Designers, or How to Design Languages to Make Programming As Difficult As Possible},
 booktitle = {Proceedings of the 2nd International Conference on Software Engineering},
 series = {ICSE '76},
 year = {1976},
 location = {San Francisco, California, USA},
 pages = {331--336},
 url = {http://dl.acm.org/citation.cfm?id=800253.807695},
 acmid = {807695},
 publisher = {IEEE Computer Society Press},
 address = {Los Alamitos, CA, USA},
 keywords = {Programming language design, Programming language structure, Programming languages},
} 

@article{sanchez-stern2018finding,
abstract = {Floating-point arithmetic plays a central role in science, engineering, and finance by enabling developers to approximate real arithmetic. To address numerical issues in large floating-point applications, developers must identify root causes, which is difficult because floating-point errors are generally non-local, non-compositional, and non-uniform. This paper presents Herbgrind, a tool to help developers identify and address root causes in numerical code written in low-level C/C++ and Fortran. Herbgrind dynamically tracks dependencies between operations and program outputs to avoid false positives and abstracts erroneous computations to a simplified program fragment whose improvement can reduce output error. We perform several case studies applying Herbgrind to large, expert-crafted numerical programs and show that it scales to applications spanning hundreds of thousands of lines, correctly handling the low-level details of modern floating point hardware and mathematical libraries, and tracking error across function boundaries and through the heap.},
archivePrefix = {arXiv},
arxivId = {1705.10416},
author = {Sanchez-Stern, Alex and Panchekha, Pavel and Lerner, Sorin and Tatlock, Zachary},
eprint = {1705.10416},
file = {::},
isbn = {9781450356985},
keywords = {debugging,dynamic analysis,floating point,technical},
mendeley-tags = {technical},
pages = {256--269},
title = {{Finding Root Causes of Floating Point Error with Herbgrind}},
url = {https://dl.acm.org/citation.cfm?doid=3192366.3192411},
year = {2017}
}
@inproceedings{venables2001programming,
abstract = {This paper describes the work that has been undertaken to improve the quantity and quality of feedback given to students studying introductory Java programming. An on-line submission program (submit) was developed that specifically addresses the needs of beginning programming students by providing automatic and instant feedback to a student's programming efforts. Traditionally, this feedback was provided by staff in scheduled laboratory sessions, yet the amount of individual attention a particular student received was haphazard. In addition, the introduction of the submit program has reduced the marking and administrative load associated with providing timely feedback to students for participating staff.submit is more than just an on-line letter box for students to post their programs. submit also provides instant feedback which encourages students to improve their programs to meet all given requirements as well as to improve programming style.In order to assess the effectiveness of the submit program over four trials, student responses to questionnaires were collated and support some tentative conclusions as to the effectiveness of submit as a learning aid to students. Staff opinion from those involved in the day-to-day teaching of Java programming was also solicited. These responses have been very positive, especially from the staff that supervise laboratory work.},
address = {Adelaide, Australia},
author = {Venables, Anne and Haywood, Liz},
booktitle = {5th Australasian Conference on Computing Education},
editor = {Greening, Tony and Lister, Raymond},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Venables, Haywood - 2003 - Programming Students NEED Instant Feedback!.pdf:pdf},
isbn = {0909925984},
keywords = {computer aided learning,difficulties,enhancement,online submission},
mendeley-tags = {difficulties,enhancement},
pages = {267--272},
publisher = {Australian Computer Society, Inc.},
title = {{Programming Students NEED Instant Feedback!}},
url = {http://delivery.acm.org/10.1145/860000/858436/p267-venables.pdf?ip=149.170.119.79&id=858436&acc=PUBLIC&key=BF07A2EE685417C5.8670C7C518068584.4D4702B0C3E38B35.4D4702B0C3E38B35&__acm__=1551097149_9ed6c2455620e4183c6caf4b4294f2f7},
volume = {20},
year = {2003}
}

@inproceedings{Gries1974What,
 abstract = {An introductory course (and its successor) in programming should be concerned with three aspects of programming: 1. How to solve problems, 2. How to describe an algorithmic solution to a problem, 3. How to verify that an algorithm is correct. I should like to discuss mainly the first two aspects. The third is just as important, but if the first two are carried out in a systematic fashion, the third is much easier than commonly supposed. (Note that the third step is not debugging, because the word debugging conveys the impression that errors are alright that they are a natural phenomenon which, like flies in a house, must be found and swatted. If debugging was called getting rid of one's mistakes, I'm sure most programmers would change their attitude and work harder at producing a correct program initially.)},
 mendeley-tags = {pedagogy},
 author = {Gries, David},
 title = {What Should We Teach in an Introductory Programming Course?},
 booktitle = {Proceedings of the Fourth SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '74},
 year = {1974},
 pages = {81--89},
 url = {http://doi.acm.org/10.1145/800183.810447},
 doi = {10.1145/800183.810447},
 acmid = {810447},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@article{brown1982my,
abstract = {Brown, P. J. (1982). brown1982my. Software: Practice and Experience, 12, 9194.},
author = {Brown, P. J.},
doi = {10.1002/spe.4380120110},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Brown - 1982 - My System Gives Excellent Error Messages - Or Does It.pdf:pdf},
issn = {00380644},
journal = {Software: Practice and Experience},
keywords = {Compiler,Error message,Pascal,difficulties,empirical,justification},
mendeley-tags = {difficulties,empirical,justification},
month = { Jan},
number = {1},
pages = {91--94},
title = {{My System Gives Excellent Error Messages - Or Does It?}},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380120110 http://doi.wiley.com/10.1002/spe.4380120110},
volume = {12},
year = {1982}
}

@inproceedings{chamillard2003transitioning,
 abstract = {All students attending the U.S. Air Force Academy are required to take an introductory course in computer science. Last year we transitioned to Ada in this course. In this paper we explain our rationale for making this transition and discuss some potential (though not significant) concerns for those considering a similar transition.},
 mendeley-tags = {anecdotal,pre-guidelines},
 author = {Chamillard, A. T. and Hobart,Jr., William C.},
 title = {Transitioning to Ada in an Introductory Course for Non-majors},
 booktitle = {Proceedings of the Conference on TRI-Ada},
 series = {TRI-Ada '97},
 year = {1997},
 isbn = {0-89791-981-5},
 location = {St. Louis, Missouri, USA},
 pages = {37--40},
 url = {http://doi.acm.org/10.1145/269629.269634},
 doi = {10.1145/269629.269634},
 acmid = {269634},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{luxton-reilly2017developing,
 abstract = {Current learning outcomes for introductory programming courses are relatively general, specifying tasks such as designing, implementing, testing and debugging programs that use some fundamental programming constructs. These outcomes impact what we teach, our expectations, and our assessments. Although prior work has demonstrated the utility of single concept assessments, most assessments used in formal examinations combine numerous heterogeneous concepts, resulting in complex and difficult tasks. As a consequence, teachers may not be able to diagnose the actual difficulties faced by students and students are not provided with accurate feedback about their achievements. Such limitations on the nature and quality of feedback to teachers and students alike may contribute to the perceived difficulty and high dropout rates commonly observed in introductory programming courses. In this paper we review the concepts that Computer Science education researchers have identified as important for novice programming. We survey expected learning outcomes for introductory programming courses, and analyse assessments designed for such courses to determine the individual components of syntax and semantics required to complete them. Having recognized the implicit and explicit expectations of novice programming courses, we look at the relationships between components, and progression between concepts. Finally, we demonstrate how some complex assessments can be decomposed into atomic elements that can be assessed independently.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Luxton-Reilly et al. - 2017 - Developing Assessments to Determine Mastery of Programming Fundamentals.pdf:pdf},
 author = {Luxton-Reilly, Andrew and Becker, Brett A. and Cao, Yingjun and McDermott, Roger and Mirolo, Claudio and M\"{u}hling, Andreas and Petersen, Andrew and Sanders, Kate and Simon and Whalley, Jacqueline},
 title = {Developing Assessments to Determine Mastery of Programming Fundamentals},
 booktitle = {Proceedings of the 2017 ITiCSE Conference on Working Group Reports},
 series = {ITiCSE-WGR '17},
 year = {2017},
 isbn = {978-1-4503-5627-5},
 location = {Bologna, Italy},
 pages = {47--69},
 url = {http://doi.acm.org/10.1145/3174781.3174784},
 doi = {10.1145/3174781.3174784},
 acmid = {3174784},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {assessment, compound assessment, concept inventory, cs1, exam, introductory programming, iticse working group, learning, learning objectives, learning outcomes, mastery, novice programming, questions},
} 

@inproceedings{Reis2005Taming,
 abstract = {An important question that must be addressed in a coherent computing curriculum is which programming environments to use across the curriculum. For Java, currently the most widely used language in computing education, a wide variety of professional integrated development environments (IDEs) are available---including the increasingly popular, open-source Eclipse environment. Professional IDEs for Java work well in advanced courses, but they are poorly matched to introductory courses because they deluge beginning students with a complex array of features. In addition, professional IDEs fail to shield students from distracting complications like the Java command line interface and Java console I/O. For this reason, many educators favor using a "pedagogic" IDE such as BlueJ or DrJava to provide a gentle introduction to the mechanics of Java programming.To eliminate the gap between pedagogic and professional IDEs for Java, we have developed a plug-in for Eclipse that supports exactly the same programming interface as DrJava. It features an Interactions pane for evaluating program statements and expressions "on the fly" as in DrJava. With this plug-in, Eclipse is accessible to beginning programmers. In this configuration, Eclipse is a suitable vehicle for teaching introductory programming--enabling Eclipse to be used across the entire spectrum of the computing curriculum.},
 mendeley-tags = {pedagogy},
 author = {Reis, Charles and Cartwright, Robert},
 title = {Taming a Professional IDE for the Classroom},
 booktitle = {Proceedings of the 35th SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '04},
 year = {2004},
 isbn = {1-58113-798-2},
 location = {Norfolk, Virginia, USA},
 pages = {156--160},
 url = {http://doi.acm.org/10.1145/971300.971357},
 doi = {10.1145/971300.971357},
 acmid = {971357},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {DrJava, eclipse, interactions pane, plug-in},
} 

@article{kolling2015lessons,
abstract = {Educational programming systems are booming. More systems of this kind have been published in the last few years than ever before, and interest in this area is growing. With the rise of programming as a school subject in ever-younger age groups, the importance of dedicated educational systems for programming education is increasing. In the past, professional environments were often used in programming teaching; with the shift to younger age groups, this is no longer tenable. New educational systems are currently being designed by a diverse group of developing teams, in industry, in academia, and by hobbyists. In this paper, the author describes his experiences with the design of three systems Blue, BlueJ, and Greenfoot and extract lessons that he hopes may be useful for designers of future systems. He also discusses current developments, and suggests an area of interest where future work might be profitable for many users: the combination of aspects from block-based and text-based programming. The author briefly presents his work in this area frame-based editing and suggest possible future development options.},
author = {K{\"{o}}lling, Michael},
doi = {10.4018/ijpop.2015010102},
file = {::},
issn = {2156-1796},
journal = {International Journal of People-Oriented Programming},
keywords = {pre-guidelines},
mendeley-tags = {pre-guidelines},
number = {1},
pages = {5--32},
title = {{Lessons from the Design of Three Educational Programming Environments: Blue, BlueJ and Greenfoot}},
volume = {4},
year = {2015}
}
@inproceedings{lang2002teaching,
abstract = {The javac compiler does not always produce error message suitable for learners and there are many Java traps which the compiler does not report. This paper describes a tool set which helps students avoid some of these difficulties.},
address = {Dublin, Ireland},
author = {Lang, Bob},
booktitle = {Principles and Practice of Programming in Java, PPPJ},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Lang - Unknown - Teaching New Programmers A Java Tool Set as a Student Teaching Aid.pdf:pdf},
keywords = {enhancement},
mendeley-tags = {enhancement},
pages = {95--100},
publisher = {National University of Ireland},
title = {{Teaching New Programmers: A Java Tool Set as a Student Teaching Aid}},
year = {2002}
}

@unpublished{ben-ari2007compile,
 abstract = {Compilers are notorious for their obscure error messages like not a statement that leave you wondering what they mean. JAVA is the most widely used language for teaching and learning introductory programming, and most students and teachers use the Sun SDK (System Development Kit) either directly or indirectly through a development environment like BlueJ or DrJava. The error messages produced by this compiler are terse and many novices find it difficult to achieve even syntactically correct programs. This document is a guide to understanding and fixing errors in JAVA. Chapter 2 lists the error messages from the compiler and describes typical mistakes that give rise to them. Chapter 3 does the same for runtime exceptions. Chapter 4 is a short discussion of equality and assignment in JAVA, while Chapter 5 presents presents ways of debugging without the use of a debugger.},
 author = {Ben-Ari, Mordechai (Moti)},
 institution = {Department of Science Teaching, Weizmann Institute of Science},
 keywords = {difficulties,justification,technical},
 mendeley-tags = {difficulties,justification,technical},
 title = {{Compile and Runtime Errors in Java}},
 url = {http://www.weizmann.ac.il/sci-tea/benari/sites/sci-tea.benari/files/uploads/softwareAndLearningMaterials/errors.pdf},
 year = {2007}
}

@inproceedings{dsouza2019mixed-methods,
abstract = {The ability to interpret error messages in order to find and fix bugs is an essential skill for novice programmers. Unfortunately, the technical language of most error messages can hinder the progress of CS1 students and can lead to feelings of confusion and frustration. A potential intervention for CS educators is the use of enhanced error messages that utilise natural-language geared towards novice learners, but the current discourse in CS Education regarding benefits of such messages is inconclusive. In this paper, we describe a planned, semi-controlled experiment running parallel to a CS1 course at the University of Toronto Scarborough. The study aims to build upon existing work in quantifying the effects of enhanced error messages by incorporating additional quantitative metrics, usability surveys, student feedback, and semi-structured interviews. The additional methods serve to measure not only the effects on error recovery, but student satisfaction, sense of frustration and overall attitude towards error messages and debugging.},
address = {Calgary, Alberta, Canada},
author = {D'souza, Rachel and Bhayana, Mahima and Ahmadzadeh, Marzieh and Harrington, Brian},
booktitle = {Proceedings of the Western Canadian Conference on Computing Education - WCCCE '19},
doi = {10.1145/3314994.3325090},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/D'souza et al. - 2019 - A Mixed-Methods Study of Novice Programmer Interaction with Python Error Messages.pdf:pdf},
isbn = {9781450367158},
keywords = {CS1,compilation behaviour,debugging,difficulties,enhancement,error messages,justification,usability},
mendeley-tags = {difficulties,enhancement,justification},
pages = {1--2},
publisher = {ACM},
title = {{A Mixed-Methods Study of Novice Programmer Interaction with Python Error Messages}},
url = {http://dl.acm.org/citation.cfm?doid=3314994.3325090},
year = {2019}
}

@inproceedings{denny2011understanding,
 abstract = {Mastering syntax is one of the earliest challenges facing the novice programmer. Problem solving and algorithms are the focus of many first year programming classes, leaving students to learn syntax on their own while they practice writing code. In this paper we investigate the frequency with which students encounter syntax errors during a drill and practice activity. We find that students struggle with syntax to a greater extent than we anticipated, even when writing short fragments of code.},
 mendeley-tags = {empirical},
 author = {Denny, Paul and Luxton-Reilly, Andrew and Tempero, Ewan and Hendrickx, Jacob},
 title = {Understanding the Syntax Barrier for Novices},
 booktitle = {Proceedings of the 16th Annual Joint Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '11},
 year = {2011},
 isbn = {978-1-4503-0697-3},
 location = {Darmstadt, Germany},
 pages = {208--212},
 url = {http://doi.acm.org/10.1145/1999747.1999807},
 doi = {10.1145/1999747.1999807},
 acmid = {1999807},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {assessment, codewrite, constructive evaluation, drill and practice, java, student-generated exercises, syntax},
}

@unpublished{barik2016static_thesis_proposal,
 abstract = {Despite the advanced static analysis tools available within modern integrated development environments (IDEs) for detecting anomalies, the error messages these tools produce to describe these anomalies remain perplexing for developers to comprehend. This thesis postulates that tools can computationally expose their internal reasoning processes to generate assistive error explanations in a way that approximates how developers explain errors to other developers and to themselves. Compared with baseline error messages, these error explanations signi cantly enhance developers' comprehension of the underlying static analysis anomaly. The contributions of this dissertation are: 1) a theoretical frame- work that formalizes explanation theory in the context of static analysis anomalies, 2) a set of experiments that evaluate the extent to which evidence supports the theoretical framework, and 3) a proof-of-concept IDE extension, called Radiance, that applies my identi ed explanationbased design principles and operationalizes these principles into a usable artifact. My work demonstrates that tools stand to signi cantly bene t if they incorporate explanation principles in their design.},
 author = {Barik, Titus},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Barik - 2016 - How should static analysis tools explain anomalies to developers A Communication Theory of Computationally Supporting Dev.pdf:pdf},
 institution = {North Carolina State University},
 keywords = {difficulties,empirical,enhancement,guidelines,justification,pre-guidelines},
 mendeley-tags = {difficulties,empirical,enhancement,guidelines,justification,pre-guidelines},
 title = {{How Should Static Analysis Tools Explain Anomalies to Developers? A Communication Theory of Computationally Supporting Developer Self-Explanations for Static Analysis Anomalies}},
 url = {http://static.barik.net/barik/proposal/barik_proposal_approved.pdf},
 year = {2016}
}

@article{fox1984use,
 abstract = {This paper describes the design of a syntax checker which is being used to provide enhanced access to computing for introductory programming students. Syntax errors are detected on a micro- computer prior to submission of the job to the mainframe for execution. Advantages of this approach for the students, the instructor, and for the computer center are discussed.},
 mendeley-tags = {anecdotal},
 author = {Fox, Christopher and Lancaster, Ronald L.},
 title = {Use of a Syntax Checker to Improve Student Access to Computing},
 booktitle = {Proceedings of the Fifteenth SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGSCE '84},
 year = {1984},
 isbn = {0-89791-126-1},
 pages = {65--68},
 url = {http://doi.acm.org/10.1145/800039.808624},
 doi = {10.1145/800039.808624},
 acmid = {808624},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@article{burch2009jigsaw,
abstract = {This paper introduces a new open-source, cross-platform programming environment designed specifically for Java-based CS1 courses. Jigsaw, as it is called, uses an intentionally simple single-window interface, incorporating several features useful for the classroom context. One such feature is that upon successful compilation, the environment checks the student program for common student errors with Java, such as mistakenly writing "void" as a return type on what is intended as a constructor declaration.},
author = {Burch, Carl},
file = {::},
journal = {Journal of Computing Sciences in Colleges},
keywords = {anecdotal,enhancement},
mendeley-tags = {anecdotal,enhancement},
number = {5},
pages = {37--43},
title = {{Jigsaw, A Programming Environment for Java in CS1}},
url = {http://www.cburch.com/jigsaw/.},
volume = {24},
year = {2009}
}
@article{hawlitschek2019drop-out,
abstract = {Purpose: An ideal learning analytics tool for programming exercises performs the role of a lecturer who monitors the code development, provides customized support and identifies students at risk to drop out. But a reliable prediction and prevention of drop-out is difficult, due to the huge problem space in programming tasks and variety of solutions and programming strategies. The purpose of this paper is to tackle this problem by, first, identifying activity patterns that indicate students at risk; and, second, finding reasons behind specific activity pattern, for identification of instructional interventions that prevent drop-out. Design/methodology/approach: The authors combine two investigation strategies: first, learning analytic techniques (decision trees) are applied on features gathered from students, while completing programming exercises, in order to classify predictors for drop-outs. Second, the authors determine cognitive, motivational and demographic learner characteristics based on a questionnaire. Finally, both parts are related with a correlation analysis. Findings: It was possible to identify generic variables that could predict early and later drop-outs. For students who drop out early, the most relevant variable is the delay time between availability of the assignment and the first login. The correlation analysis indicates a relation with prior programming experience in years and job occupation per week. For students who drop out later in the course, the number of errors within the first assignment is the most relevant predictor, which correlates with prior programming skills. Originality/value: The findings indicate a relation between activity patterns and learner characteristics. Based on the results, the authors deduce instructional interventions to support students and to prevent drop-outs.},
author = {Hawlitschek, Anja and K{\"{o}}ppen, Veit and Dietrich, Andr{\'{e}} and Zug, Sebastian},
doi = {https://doi.org/10.1108/JARHE-02-2019-0035},
journal = {Journal of Applied Research in Higher Education},
keywords = {difficulties,drop-out,empirical,errors-only,justification,learning analytics,motivation,performance,programming course},
mendeley-tags = {difficulties,empirical,errors-only,justification,performance},
number = {4},
title = {{Drop-out in programming courses prediction and prevention}},
volume = {11},
year = {2019}
}

@inproceedings{ginat2013constructive,
 abstract = {We developed an approach of learning from errors in CS1, taught in OOP. The approach is based on a set of principles, which include: cognitive conflict, constructivist characteristics, error attribution, self explanation, reflection, and refinement of concept images of fundamental OOP terms and mechanisms. The approach is presented, and some of its activities are illustrated. The developed activities aim at erroneous OOP conceptions that we have observed in a previous study. We applied the approach with CS1 college students, and conducted a comparative study, with an experiment group and a control group. We display a summary of the study's results, together with the students' opinions about the applied approach.},
 mendeley-tags = {errors-only,pedagogy},
 author = {Ginat, David and Shmalo, Ronit},
 title = {Constructive Use of Errors in Teaching CS1},
 booktitle = {Proceeding of the 44th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '13},
 year = {2013},
 isbn = {978-1-4503-1868-6},
 location = {Denver, Colorado, USA},
 pages = {353--358},
 url = {http://doi.acm.org/10.1145/2445196.2445300},
 doi = {10.1145/2445196.2445300},
 acmid = {2445300},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {OOP, constructivism, learning from errors},
}

@inproceedings{phothilimthana2017high,
 abstract = {In massive programming courses, automated hint generation offers the promise of zero-cost, zero-latency assistance for students who are struggling to make progress on solving a program. While a more robust hint generation approach based on path construction requires tremendous engineering effort to build, another easier-to-build approach based on program mutations suffers from low coverage. This paper describes a robust hint generation system that extends the coverage of the mutation-based approach using two complementary techniques. A syntax checker detects common syntax misconception errors in individual sub-expressions to guide students to partial solutions that can be evaluated for the semantic correctness. A mutation-based approach is then used to generate hints for almost-correct programs. If the mutation-based approach fails, a case analyzer detects missing program branches to guide students to partial solutions with reasonable structures. After analyzing over 75,000 program submissions and 8,789 hint requests, we found that using all three techniques together could offer hints for any program, no matter how far it was from a correct solution. Furthermore, our analysis shows that hints contributed to students' progress while still encouraging the students to solve problems by themselves.},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Phothilimthana, Sridhara - 2017 - High-Coverage Hint Generation for Massive Courses Do Automated Hints Help CS1 Students.pdf:pdf},
 mendeley-tags = {enhancement,justification,pre-guidelines},
 author = {Phothilimthana, Phitchaya Mangpo and Sridhara, Sumukh},
 title = {High-Coverage Hint Generation for Massive Courses: Do Automated Hints Help CS1 Students?},
 booktitle = {Proceedings of the 2017 ACM Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '17},
 year = {2017},
 isbn = {978-1-4503-4704-4},
 location = {Bologna, Italy},
 pages = {182--187},
 url = {http://doi.acm.org/10.1145/3059009.3059058},
 doi = {10.1145/3059009.3059058},
 acmid = {3059058},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automated tutor, computer-aided education, program analysis, program synthesis},
}

@inproceedings{sadowski2015tricorder,
 abstract = {Static analysis tools help developers find bugs, improve code readability, and ensure consistent style across a project. However, these tools can be difficult to smoothly integrate with each other and into the developer workflow, particularly when scaling to large codebases. We present Tricorder, a program analysis platform aimed at building a data-driven ecosystem around program analysis. We present a set of guiding principles for our program analysis tools and a scalable architecture for an analysis platform implementing these principles. We include an empirical, in-situ evaluation of the tool as it is used by developers across Google that shows the usefulness and impact of the platform.},
 mendeley-tags = {empirical,guidelines},
 author = {Sadowski, Caitlin and van Gogh, Jeffrey and Jaspan, Ciera and S\"{o}derberg, Emma and Winter, Collin},
 title = {Tricorder: Building a Program Analysis Ecosystem},
 booktitle = {Proceedings of the 37th International Conference on Software Engineering - Volume 1},
 series = {ICSE '15},
 year = {2015},
 isbn = {978-1-4799-1934-5},
 location = {Florence, Italy},
 pages = {598--608},
 url = {http://dl.acm.org/citation.cfm?id=2818754.2818828},
 acmid = {2818828},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 keywords = {program analysis, static analysis},
}

@inproceedings{prather2019first,
 abstract = {When solving programming problems, novices are often not aware of where they are in the problem-solving process. For instance, students who misinterpret the problem prompt will most likely not form a valid conceptual model of the task and fail to make progress towards a working solution. Avoiding such errors, and recovering from them once they occur, requires metacognitive skills that enable students to reflect on their problem-solving processes. For these reasons, developing metacognitive awareness is crucially important for novice students. Previous research has shown that explicitly teaching key steps of programming problem-solving, and having students reflect on where they are in the problem-solving process, can help students complete future programming assignments. Such metacognitive awareness training can be done through personal tutoring, but can be difficult to implement without a high ratio of instructors to students. We explore a more scalable approach, making use of an automated assessment tool, and conduct a controlled experiment to see whether scaffolding the problem-solving process would increase metacognitive awareness and improve student performance. We collected all code submissions by students in both control and experimental groups, as well as data from direct observation using a think-aloud protocol. We found that students who received the intervention showed a higher degree of understanding of the problem prompt and were more likely to complete the programming task successfully},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Prather et al. - 2019 - First Things First Providing Metacognitive Scaffolding for Interpreting Problem Prompts.pdf:pdf},
 mendeley-tags = {justification,pedagogy},
 author = {Prather, James and Pettit, Raymond and Becker, Brett A. and Denny, Paul and Loksa, Dastyni and Peters, Alani and Albrecht, Zachary and Masci, Krista},
 title = {First Things First: Providing Metacognitive Scaffolding for Interpreting Problem Prompts},
 booktitle = {Proceedings of the 50th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '19},
 year = {2019},
 isbn = {978-1-4503-5890-3},
 location = {Minneapolis, MN, USA},
 pages = {531--537},
 url = {http://doi.acm.org/10.1145/3287324.3287374},
 doi = {10.1145/3287324.3287374},
 acmid = {3287374},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automated assessment tools, cs1, metacognitive awareness},
}

@inproceedings{watson2011learning,
abstract = {In this paper we address common issues faced by students in programming courses by combining implicit and explicit feedback measures to provide real-time assistance in coding tasks. We also introduce our concept vi-sualisation technique, which aims to visually convey programming concepts and information on the execution state to students. The mapping between game content construction actions and actual source code forms an implicit example-based learning environment, allowing programming concepts to be more clearly conveyed than in conventional integrated development environment (IDE) or static lecture materials. An experimental evaluation of a prototype system suggests the potential of this approach for programming education by scoring highly in terms of both user satisfaction and potential pedagogical capability.},
author = {Watson, Christopher and Li, Frederick W B and Lau, Rynson W H},
booktitle = {International Conference on Web-Based Learning},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Watson, Li, Lau - 2011 - Learning Programming Languages through Corrective Feedback and Concept Visualisation.pdf:pdf},
keywords = {Concept Visualization,Corrective Feedback,Programming Education,anecdotal,difficulties,enhancement},
mendeley-tags = {anecdotal,difficulties,enhancement},
pages = {11--20},
title = {{Learning Programming Languages through Corrective Feedback and Concept Visualisation}},
year = {2011}
}
@techreport{moore2005intelligent,
abstract = {We present the case for an intelligent interactive online tutor to teach computer languages, with a particular focus on the Verilog hardware description language. This system allows the detailed syntactic and semantic components to be presented in byte sized chunks with the student's understanding checked and reinforced via problem solving. A key challenge has been the provision of human like feedback to erroneous solutions to encourage and assist the learning process.},
author = {Moore, Simon and Taylor, Kate},
file = {::},
institution = {Higher Education Academy for Information and Computer Sciences},
keywords = {Context sensitive error messages,Interactive Tutor,On-line learning,Prolog,State machines,Verilog,enhancement},
mendeley-tags = {enhancement},
title = {{Intelligent Interactive Online Tutor for Computer Language Teaching}},
url = {http://www.cl.cam.ac.uk/users/swm11http://www.cl.cam.ac.uk/users/ksw1000},
year = {2005}
}

@article{kopec2007description,
 abstract = {To date there has been considerable investigation into the study of novice programmer errors. The research has analyzed both syntactic and semantic errors. However, the next level of programmers, who make more sophisticated errors, the internmediate level programmers, have been somewhat neglected. In this paper, we focus on the nature of the errors which intermediate level programmers make. The basis of our study is the semantic approach. Here, we the study problems which require more difficult program constructs such as nested loops, arrays, recursion, and functions.},
 annote = {The paper is about logical errors but we can probably adapt some guidelines.},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Kopec, Yarmish, Cheung - 2007 - A Description and Study of Intermediate Student Programmer Errors.pdf:pdf},
 mendeley-tags = {anecdotal,pedagogy},
 author = {Kopec, Danny and Yarmish, Gavriel and Cheung, Patrick},
 title = {A Description and Study of Intermediate Student Programmer Errors},
 journal = {SIGCSE Bull.},
 issue_date = {June 2007},
 volume = {39},
 number = {2},
 month = Jun,
 year = {2007},
 issn = {0097-8418},
 pages = {146--156},
 url = {http://doi.acm.org/10.1145/1272848.1272899},
 doi = {10.1145/1272848.1272899},
 acmid = {1272899},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {advanced novice programmers, intermediate programmers, plans and goals, programmer errors, semantic analysis},
}

@article{shneiderman1979syntactic,
abstract = {This paper presents a cognitive framework for describing behaviors involved in program composition, comprehension, debugging, modification, and the acquisition of new programming concepts, skills, and knowledge. An information processing model is presented which includes a long-term store of semantic and syntactic knowledge, and a working memory in which problem solutions are constructed. New experimental evidence is presented to support the model of syntactic/semantic interaction.},
annote = {2.2.4 (final paragraph): mentions diagnostic messages briefly as being tied to "language-specific syntactic information" that is "This information is highly detailed, learned by repeated experience, and easily forgotten."},
author = {Shneiderman, Ben and Mayer, Richard},
file = {::},
journal = {International Journal of Computer and Information Sciences},
keywords = {Programming,cognitive models,debugging,difficulties,education,information processing,learning,modification,program composition,program comprehension,programming languages},
mendeley-tags = {difficulties},
number = {3},
title = {{Syntactic/Semantic Interactions in Programmer Behavior: A Model and Experimental Results}},
volume = {8},
year = {1979}
}

@inproceedings{helminen2013recording,
 abstract = {In this paper, we report on the analysis of a novel type of automatically recorded detailed programming session data collected on a university-level web programming course. We present a method and an implementation of collecting rich data on how students learning to program edit and execute code and explore its use in examining learners' behavior. The data collection instrument is an in-browser Python program- ming environment that integrates an editor, an execution environment, and an interactive Python console and is used to deliver programming assignments with automatic feed- back. Most importantly, the environment records learners' interaction within it. We have implemented tools for view- ing these traces and demonstrate their potential in learning about the programming processes of learners and of benefiting computing education research and the teaching of programming.},
 mendeley-tags = {difficulties,empirical},
 author = {Helminen, Juha and Ihantola, Petri and Karavirta, Ville},
 title = {Recording and Analyzing In-browser Programming Sessions},
 booktitle = {Proceedings of the 13th Koli Calling International Conference on Computing Education Research},
 series = {Koli Calling '13},
 year = {2013},
 isbn = {978-1-4503-2482-3},
 location = {Koli, Finland},
 pages = {13--22},
 url = {http://doi.acm.org/10.1145/2526968.2526970},
 doi = {10.1145/2526968.2526970},
 acmid = {2526970},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Python, computer science education, computing education research, programming assignment, programming session, web based programming environment},
} 

@inproceedings{stefik2014programming,
 abstract = {The discipline of computer science has a long and complicated history with computer programming languages. Historically, inventors have created language products for a wide variety of reasons, from attempts at making domain specific tasks easier or technical achievements, to economic, social, or political reasons. As a consequence, the modern programming language industry now has a large variety of incompatible programming languages, each of which with unique syntax, semantics, toolsets, and often their own standard libraries, lifetimes, and costs. In this paper, we suggest that the programming language wars, a term which describes the broad divergence and impact of language designs, including often pseudo-scientific claims made that they are good or bad, may be negatively impacting the world. This broad problem, which is almost completely ignored in computer science, needs to be acted upon by the community.},
 mendeley-tags = {difficulties},
 author = {Stefik, Andreas and Hanenberg, Stefan},
 title = {The Programming Language Wars: Questions and Responsibilities for the Programming Language Community},
 booktitle = {Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
 series = {Onward! 2014},
 year = {2014},
 isbn = {978-1-4503-3210-1},
 location = {Portland, Oregon, USA},
 pages = {283--299},
 url = {http://doi.acm.org/10.1145/2661136.2661156},
 doi = {10.1145/2661136.2661156},
 acmid = {2661156},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {evidence standards, stability of the academic literature, the programming language wars},
}

@inproceedings{laucius2006issues,
abstract = {The programming environment has an essential role in the curriculum of programming. This paper presents the main features determining an environment's methodical suitability for teaching programming. It is based on our recent experience of selection of environments when we had decided to replace the obsolete Turbo Pascal system in our schools. Our solution to adapt the Free Pascal compiler for teaching purposes according to prearranged requirements may be treated as success story. The paper presents the main features of Free Pascal and the main tasks necessary for its adaptation: the development of an integrated development environment and the localization of compiler as well.},
address = {Vilnius, Lithuania},
author = {Laucius, Rimgaudas},
booktitle = {Informatics Education -- The Bridge between Using and Understanding Computers},
doi = {10.1007/11915355_16},
editor = {Mittermeir, Roland T.},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Laucius - 2006 - Issues of Selecting a Programming Environment for a Programming Curriculum in General Education.pdf:pdf},
keywords = {enhancement},
mendeley-tags = {enhancement},
pages = {169----178},
publisher = {Springer},
title = {{Issues of Selecting a Programming Environment for a Programming Curriculum in General Education}},
year = {2006}
}
@article{vanhaaster2017teaching,
abstract = {BlueJ is a programming environment that has been used to teach object-oriented introductory programming since 1999 in two consecutive first year units at Monash University. An earlier evaluation of its effectiveness in helping students to learn OO programming in the first unit was inconclusive, although most students who participated in the study believed that it did help them to learn Java. It was hoped at that time that students would show positive effects of using BlueJ more in the second unit than in the first. This paper reports on a later evaluation study, when the BlueJ environment had become more stable and easier to install. It examines the reactions and results of students in the second of the two units. It also introduces a set of criteria for evaluating environments designed for novice programmers.},
annote = {Discussion of BlueJ's approach to error messages on p. 466.},
author = {{Van Haaster}, Kelsey and Hagan, Dianne},
doi = {10.28945/752},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Van Haaster, Hagan - 2017 - Teaching and Learning with BlueJ an Evaluation of a Pedagogical Tool.pdf:pdf},
issn = {1547-5840},
journal = {Issues in Informing Science and Information Technology},
keywords = {empirical,enhancement},
mendeley-tags = {empirical,enhancement},
pages = {455--470},
title = {{Teaching and Learning with BlueJ: an Evaluation of a Pedagogical Tool}},
volume = {1},
year = {2017}
}

@inproceedings{moreno2014defining,
 abstract = {A review of the practical uses of errors in education reveals three contexts where errors have been shown to help: teaching conceptual knowledge, changing students' attitudes and promoting learning skills. Conflictive animations form a novel approach to teaching programming that follows a long tradition on research and development on program animation tools. Conflictive animations link the benefits of errors with program animation tools and programming education. This approach involves presenting to the students conflictive animations that do not animate faithfully the programs or concepts taught. Conflictive animations are versatile enough to cover the fundamental building blocks of programs such as operators, expressions and statements. With conflictive animations a novel set of learning activities can be introduced to computer science classes. This conflictive dimension of activities augments an engagement taxonomy for animation tools at all levels. They are an example of activities that promote critical thinking. A particular implementation of conflictive animations has been empirically evaluated aiming for ecological validity rather than statistical significance. Results indicate that students using conflictive animations improve their metacognitive skills, and, when compared to a control group, their conceptual knowledge improves at a better rate.},
 mendeley-tags = {enhancement,pedagogy},
 author = {Moreno, Andr{\'e}s and Sutinen, Erkki and Joy, Mike},
 title = {Defining and Evaluating Conflictive Animations for Programming Education: The Case of {Jeliot ConAn}},
 booktitle = {Proceedings of the 45th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '14},
 year = {2014},
 isbn = {978-1-4503-2605-6},
 location = {Atlanta, Georgia, USA},
 pages = {629--634},
 url = {http://doi.acm.org/10.1145/2538862.2538888},
 doi = {10.1145/2538862.2538888},
 acmid = {2538888},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {animation, conflictive animation, constructivism, cs1, programming},
}

@inproceedings{lewis1998comparison,
 abstract = {A locally built Modula-2 compiler has been used for number of years in our School. The messages that are emitted from the compiler when run by first and final year students have been logged. Over the last two years we have been improving the usefulness of these messages. This paper presents an analysis of these results.},
 mendeley-tags = {empirical,pedagogy,technical},
 author = {Lewis, Stuart and Mulley, Gaius},
 title = {A Comparison Between Novice and Experienced Compiler Users in a Learning Environment},
 booktitle = {Proceedings of the 6th Annual Conference on the Teaching of Computing and the 3rd Annual Conference on Integrating Technology into Computer Science Education: Changing the Delivery of Computer Science Education},
 series = {ITiCSE '98},
 year = {1998},
 isbn = {1-58113-000-7},
 location = {Dublin City Univ., Ireland},
 pages = {157--161},
 url = {http://doi.acm.org/10.1145/282991.283106},
 doi = {10.1145/282991.283106},
 acmid = {283106},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Modula-2, compiler, learning environment},
}

@inproceedings{engelmann1985rules,
abstract = {Tools for the implementation of fourth generation languages are now available (SCHA83). These tools facilitate the production of interactive systems. A language is defined by a formal grammar in which the semantic actions are embedded (MEI83).},
address = {Helsinki, Finland},
author = {Engelmann, U. and Meinzer, H. P.},
booktitle = {Medical Informatics Europe 85},
doi = {10.1007/978-3-642-93295-3_48},
editor = {Roger, F. H. and Gr{\"{o}}nroos, P. and Tervo-Pellikka, R. and O'Moore, R.},
file = {::},
isbn = {978-3-642-93295-3},
keywords = {guidelines},
mendeley-tags = {guidelines},
pages = {240--245},
publisher = {Springer, Berlin, Heidelberg},
title = {{Rules for the Design of End User Languages}},
year = {1985}
}
@inproceedings{fellows2016designing,
abstract = {Error messages are the only form of response that programmers get from malfunctioning programs. More experienced programmers often develop intuition about what error messages actually mean, but novices only have the content of the error message. Our research focuses on two functional programming languages in the Lisp family, their current or potential use in introductory CS classes, and specifically on the quality of their error messages for beginner CS students. The languages we will be comparing are a subset of Racket called beginning student language , and Clojure. Beginning student language is a language designed for introductory students using the How to Design Programs 2 curriculum, with error messages that are designed for novices. Clojure is a Lisp built on top of the Java programming language which better supports concurrent and parallel programming and has been rapidly gaining popularity in industry. However, Clojure was not developed with beginner programmers in mind: its native error messages are often just Java error messages that dont make sense to programmers without Java background. Our previous work with Clojure has built an alternative error messages system that we think may be more useful to beginner CS students. Our work is a part of the ClojurEd project which aims to use Clojure to teach an introductory CS course. One of the project goals is to provide introductory students with understandable error messages. The current stage of the project is to evaluate how well the new messages work for beginner programmers. We have designed a usability study comparing the proposed and standard Clojure error messages to each other and to Racket error messages. In this paper we present the details of the study and the approaches to developing code samples that allow us to compare error messages systems. We also present and discuss preliminary results of the usability study.},
annote = {If the follow up paper to this was ever published, it would be really useful},
author = {Fellows, Henry and Hagen, Thomas and Stockholm, Sean and Machkasova, Elena},
booktitle = {Midwest Instruction and Computing Symposium, MICS 2016},
file = {::},
keywords = {enhancement},
mendeley-tags = {enhancement},
pages = {1--12},
title = {{Designing a Comparative Usability Study of Error Messages}},
year = {2016}
}
@article{radosevic2009verificator,
abstract = {The paper introduces Verificator, our learning programming interface aimed for learning programming in C++ at the university beginners' level. In teaching programming some specific problems concerning the teaching itself as well as the organization of the teaching process need to be considered. One of the biggest problems is that students tend to adopt certain bad programming habits in their attempt to more easily deal with their examinations, such as trying to write programs without any syntax and logical checking. It is very hard to help them correct those errors once they are deeply rooted. Our students' web questionnaire and its results show that the majority of problems in learning programming among our students arise from the gap between the understanding of programming language syntax and problem-solving algorithms. Verificator prevents students from making a lot of errors they are likely to make in learning programming and helps them to learn programming language syntax and adopt good programming habits.},
annote = {Rado{\v{s}}evi{\'{c}}, Danijel and Orehova{\v{c}}ki, Tihomir and Lovren{\v{c}}i{\'{c}}, Alen, Verificator: Educational Tool for Learning Programming (2009). Rado{\v{s}}evi{\'{c}}, D., Orehova{\v{c}}ki, T., Lovren{\v{c}}i{\'{c}}, A:"Verificator: Educational Tool for Learning Programming", INFORMATICS IN EDUCATION, Vol. 8, No. 2, pg. 261-280, ISSN 1648-5831, Institute of Mathematics and Informatics, Vilnius, Lithuania, 2009.. Available at SSRN:Â https://ssrn.com/abstract=2505746},
author = {{Radosevic, Danijel and Orehova{\v{c}}ki, Tihomir and Lovrencic}, Alen},
file = {::},
journal = {Informatics in Education},
keywords = {Verificator,difficulties,empirical,learning programming,teaching software},
mendeley-tags = {difficulties,empirical},
number = {2},
pages = {261--280},
title = {{Verificator: Educational Tool for Learning Programming}},
url = {https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2505746},
volume = {8},
year = {2009}
}

@inproceedings{luxton-reilly2018introductory,
 abstract = {As computing becomes a mainstream discipline embedded in the school curriculum and acts as an enabler for an increasing range of academic disciplines in higher education, the literature on introductory programming is growing. Although there have been several reviews that focus on specific aspects of introductory programming, there has been no broad overview of the literature exploring recent trends across the breadth of introductory programming. This paper is the report of an ITiCSE working group that conducted a systematic review in order to gain an overview of the introductory programming literature. Partitioning the literature into papers addressing the student, teaching, the curriculum, and assessment, we explore trends, highlight advances in knowledge over the past 15 years, and indicate possible directions for future research.},
 mendeley-tags = {difficulties,justification,pedagogy},
 author = {Luxton-Reilly, Andrew and Simon and Albluwi, Ibrahim and Becker, Brett A. and Giannakos, Michail and Kumar, Amruth N. and Ott, Linda and Paterson, James and Scott, Michael James and Sheard, Judy and Szabo, Claudia},
 title = {Introductory Programming: A Systematic Literature Review},
 booktitle = {Proceedings Companion of the 23rd Annual ACM Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '18},
 year = {2018},
 isbn = {978-1-4503-6223-8},
 location = {Larnaca, Cyprus},
 pages = {55--106},
 url = {http://doi.acm.org/10.1145/3293881.3295779},
 doi = {10.1145/3293881.3295779},
 acmid = {3295779},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, ITiCSE working group, SLR, introductory programming, literature review, novice programming, overview, review, systematic literature review, systematic review},
}

@inproceedings{mciver2002evaluating,
abstract = {Although debate rages strongly over which programming language is the best for any particular application (especially for teaching introductory programming), there is a lack of objective data informing the discussions. There is a similar lack of data on appropriate development environments for introductory programming courses. This paper discusses an existing method of comparing and evaluating programming languages, and how that method can be adapted to compare and evaluate integrated development environments, with a particular focus on environments for novice programmers.},
address = {Uxbridge UK},

author = {McIver, Linda},
booktitle = {Proceedings of the 14th Annual Workshop of the Psychology of Programming Interest Group (PPIG '02)},
doi = {10.1371/journal.pone.0088941},
editor = {{J Kuljis, L Baldwin}, R Scoble},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/McIver - 2002 - Evaluating Languages and Environments for Novice Programmers.pdf:pdf},
keywords = {POP-IB choice of language,POP-IIA novice programmers,POP-IIID editors and debuggers,difficulties,justification},
mendeley-tags = {difficulties,justification},
pages = {100--110},
publisher = {Brunel University},
title = {{Evaluating Languages and Environments for Novice Programmers}},
url = {https://pdfs.semanticscholar.org/93de/0009c82cdeccb9a207c5dc733efce1ecf183.pdf?_ga=2.202377171.37866984.1558384667-1718405484.1558384667},
year = {2002}
}
@article{kolling2003bluej,
 abstract = {Many teachers experience serious problems when teaching object-orientation to beginners or professionals. Many of these problems could be overcome or reduced through the use of more appropriate tools. In this paper, we introduce BlueJ, an integrated development environment designed for teaching object-orientation, and discuss how the use of this tool can change the approach to teaching},
 author = {K{\"{o}}lling, Michael and Quig, Bruce and Patterson, Andrew and Rosenberg, John},
 doi = {10.1076/csed.13.4.249.17496},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/K{\"{o}}lling et al. - 2003 - The BlueJ System and its Pedagogy(2).pdf:pdf},
 issn = {0899-3408},
 journal = {Computer Science Education},
 keywords = {tool},
 mendeley-tags = {tool},
 month = {Dec},
 number = {4},
 pages = {249--268},
 title = {{The BlueJ System and its Pedagogy}},
 url = {https://www.tandfonline.com/doi/full/10.1076/csed.13.4.249.17496},
 volume = {13},
 year = {2003}
}

@inproceedings{price2017isnap,
 abstract = {Programming environments intentionally designed to support novices have become increasingly popular, and growing research supports their efficacy. While these environments offer features to engage students and reduce the burden of syntax errors, they currently offer little support to students who get stuck and need expert assistance. Intelligent Tutoring Systems (ITSs) are computer systems designed to play this role, helping and guiding students to achieve better learning outcomes. We present iSnap, an extension to the Snap programming environment which adds some key features of ITSs, including detailed logging and automatically generated hints. We share results from a pilot study of iSnap, indicating that students are generally willing to use hints and that hints can create positive outcomes. We also highlight some key challenges encountered in the pilot study and discuss their implications for future work.},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Price, Dong, Lipovac - 2017 - iSnap Towards Intelligent Tutoring in Novice Programming Environments.pdf:pdf},
 mendeley-tags = {errors-only},
 author = {Price, Thomas W. and Dong, Yihuan and Lipovac, Dragan},
 title = {{iSnap}: Towards Intelligent Tutoring in Novice Programming Environments},
 booktitle = {Proceedings of the 2017 ACM SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '17},
 year = {2017},
 isbn = {978-1-4503-4698-6},
 location = {Seattle, Washington, USA},
 pages = {483--488},
 url = {http://doi.acm.org/10.1145/3017680.3017762},
 doi = {10.1145/3017680.3017762},
 acmid = {3017762},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {data-driven, hints, intelligent tutoring systems, logging, novice programming, snap},
}

@article{karachalias2015gadts,
abstract = {For ML and Haskell, accurate warnings when a function definition has redundant or missing patterns are mission critical. But today's compilers generate bogus warnings when the programmer uses guards (even simple ones), GADTs, pattern guards, or view patterns. We give the first algorithm that handles all these cases in a single, uniform framework, together with an implementation in GHC, and evidence of its utility in practice.},
author = {Karachalias, Georgios and Schrijvers, Tom and Vytiniotis, Dimitrios and Jones, Simon Peyton},
doi = {10.1145/2858949.2784748},
file = {::},
isbn = {9781450336697},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {enhancement,generalized algebraic data,haskell,o utside i n,pattern matching,types,x},
mendeley-tags = {enhancement},
number = {9},
pages = {424--436},
title = {{GADTs meet their match: pattern-matching warnings that account for GADTs, guards, and laziness}},
volume = {50},
year = {2015}
}
@article{dillig2007static,
abstract = {Inconsistency checking is a method for detecting software errors that relies only on examining multiple uses of a value.We propose that inconsistency inference is best understood as a variant of the older and better understood problem of type inference. Using this insight, we describe a precise and formal framework for discover- ing inconsistency errors. Unlike previous approaches to the prob- lem, our technique for finding inconsistency errors is purely se- mantic and can deal with complex aliasing and path-sensitive con- ditions. We have built a null dereference analysis of C programs based on semantic inconsistency inference and have used it to find hundreds of previously unknown null dereference errors in widely used C programs.},
author = {Dillig, Isil and Dillig, Thomas and Aiken, Alex},
doi = {10.1145/1273442.1250784},
file = {::},
isbn = {9781595936332},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {error detection,inconsis-,satisfiability,static analysis,technical},
mendeley-tags = {technical},
number = {6},
pages = {435},
title = {{Static error detection using semantic inconsistency inference}},
volume = {42},
year = {2007}
}

@article{hundhausen2017idebased,
 abstract = {In recent years, learning process data have become increasingly easy to collect through computer-based learning environments. This has led to increased interest in the field of learning analytics, which is concerned with leveraging learning process data in order to better understand, and ultimately to improve, teaching and learning. In computing education, the logical place to collect learning process data is through integrated development environments (IDEs), where computing students typically spend large amounts of time working on programming assignments. While the primary purpose of IDEs is to support computer programming, they might also be used as a mechanism for delivering learning interventions designed to enhance student learning. The possibility of using IDEs both to collect learning process data, and to strategically intervene in the learning process, suggests an exciting design space for computing education research: that of IDE-based learning analytics. In order to facilitate the systematic exploration of this design space, we present an IDE-based data analytics process model with four primary activities: (1) Collect data, (2) Analyze data, (3) Design intervention, and (4) Deliver intervention. For each activity, we identify key design dimensions and review relevant computing education literature. To provide guidance on designing effective interventions, we describe four relevant learning theories, and consider their implications for design. Based on our review, we present a call-to-action for future research into IDE-based learning analytics.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Hundhausen, Olivares, Carter - 2017 - IDE-Based Learning Analytics for Computing Education A Process Model, Critical Review, and Researc.pdf:pdf},
 journal = {ACM Transactions on Computing Education},
 mendeley-tags = {guidelines,pre-guidelines},
 author = {Hundhausen, C. D. and Olivares, D. M. and Carter, A. S.},
 title = {IDE-Based Learning Analytics for Computing Education: A Process Model, Critical Review, and Research Agenda},
 issue_date = {August 2017},
 volume = {17},
 number = {3},
 month = aug,
 year = {2017},
 issn = {1946-6226},
 pages = {11:1--11:26},
 articleno = {11},
 numpages = {26},
 url = {http://doi.acm.org/10.1145/3105759},
 doi = {10.1145/3105759},
 acmid = {3105759},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Learning analytics, learning interventions, learning process data},
}

@inproceedings{dy2010detector,
 abstract = {Novice programmers typically have problems diagnosing errors in their programs. This difficulty may be attributed in part to non-literal error messages, i.e. compiler-reported errors that do not match the actual error. Through the analysis of compilation logs, we determined the errors frequently committed by novice programmers. We then developed a detector that checks novice student code for these non-literal errors and produces more informative error reports.},
 annote = {They enhance the error messages, but this part is not described in details. I assume Col 1 in Tables 2-6 is the enhanced error message.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Dy, Rodrigo - 2010 - A Detector for Non-literal Java Errors.pdf:pdf},
 mendeley-tags = {empirical,enhancement,technical,tool},
 author = {Dy, Thomas and Rodrigo, Ma. Mercedes},
 title = {A Detector for Non-literal Java Errors},
 booktitle = {Proceedings of the 10th Koli Calling International Conference on Computing Education Research},
 series = {Koli Calling '10},
 year = {2010},
 isbn = {978-1-4503-0520-4},
 location = {Koli, Finland},
 pages = {118--122},
 url = {http://doi.acm.org/10.1145/1930464.1930485},
 doi = {10.1145/1930464.1930485},
 acmid = {1930485},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {BlueJ, Java, non-literal errors, novice programmers},
}

@article{coull2011innovations,
 abstract = {The problems associated with learning and teaching first year University Computer Science (CS1) programming classes are summarized showing that various support tools and techniques have been developed and evaluated. From this review of applicable support the paper derives ten requirements that a support tool should have in order to improve CS1 student success rate with respect to learning and understanding.},
 annote = {Online journal; published online Dec 2015.},
 author = {Coull, Natalie J. and Duncan, Ishbel M.M.},
 doi = {10.11120/ital.2011.10010078},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Coull, Duncan - 2011 - Emergent requirements for supporting introductory programming.pdf:pdf},
 issn = {14737507},
 journal = {Innovations in Teaching and Learning in Information and Computer Sciences {(ITaLICS)}},
 keywords = {Design,Human factors,Introductory programming,Learning,Theory,anecdotal,difficulties,pre-guidelines},
 mendeley-tags = {anecdotal,difficulties,pre-guidelines},
 number = {1},
 pages = {78--85},
 title = {{Emergent Requirements for Supporting Introductory Programming}},
 url = {https://www.tandfonline.com/doi/full/10.11120/ital.2011.10010078},
 volume = {10},
 year = {2011}
}
@inproceedings{tamada2011framework,
abstract = {This paper proposes a framework to support programming education intended for novice programmers at universities. This proposed framework entails a collection of compile errors and source codes of a student at the time such errors occur, as well as storing the learning history of the student. Programming processes can be measured and a degree of understanding can be estimated by retaining the editing history of source codes. Furthermore, the implementation of the proposed framework, which resulted in the early identification of students with problems, is presented and evaluated.},
author = {Tamada, Haruaki and Ogino, Akihiro and Ueda, Hirotada},
booktitle = {Proceedings - Joint Conference of the 21st International Workshop on Software Measurement, IWSM 2011 and the 6th International Conference on Software Process and Product Measurement, MENSURA 2011},
doi = {10.1109/IWSM-MENSURA.2011.23},
file = {::},
isbn = {9780769544977},
keywords = {Learning programming,Netboot,Novice programmers,Teaching programming,The C language,difficulties,empirical,pedagogy},
mendeley-tags = {difficulties,empirical,pedagogy},
pages = {233--238},
title = {{A Framework for Programming Process Measurement and Compiling Error Interpretation for Novice Programmers}},
year = {2011}
}

@article{eastmond2010scratch,
 abstract = {Scratch is a visual programming environment that allows users (primarily ages 8 to 16) to learn computer programming while working on personally meaningful projects such as animated stories and games. A key design goal of Scratch is to support self-directed learning through tinkering and collaboration with peers. This article explores how the Scratch programming language and environment support this goal.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Eastmond et al. - 2010 - The Scratch Programming Language and Environment.pdf:pdf},
 journal = {ACM Transactions on Computing Education},
 author = {Maloney, John and Resnick, Mitchel and Rusk, Natalie and Silverman, Brian and Eastmond, Evelyn},
 title = {The Scratch Programming Language and Environment},
 issue_date = {November 2010},
 volume = {10},
 number = {4},
 month = nov,
 year = {2010},
 issn = {1946-6226},
 pages = {16:1--16:15},
 articleno = {16},
 numpages = {15},
 url = {http://doi.acm.org/10.1145/1868358.1868363},
 doi = {10.1145/1868358.1868363},
 acmid = {1868363},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Scratch, programming environment, programming language, visual programming language},
}

@article{stefik2018evidence,
  abstract = {The report documents the program and outcomes of Dagstuhl Seminar 18061 "Evidence About Programmers for Programming Language Design". The seminar brought together a diverse group of researchers from the fields of computer science education, programming languages, software engineering, human-computer interaction, and data science. At the seminar, participants discussed methods for designing and evaluating programming languages that take the needs of programmers directly into account. The seminar included foundational talks to introduce the breadth of perspectives that were represented among the participants; then, groups formed to develop research agendas for several subtopics, including novice programmers, cognitive load, language features, and love of programming languages. The seminar concluded with a discussion of the current SIGPLAN artifact evaluation mechanism and the need for evidence standards in empirical studies of programming languages.},
  file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Stefik et al. - 2018 - Evidence About Programmers for Programming Language Design (Dagstuhl Seminar 18061).pdf:pdf},
  mendeley-tags = {justification},
  author =	{Andreas Stefik and Bonita Sharif and Brad. A. Myers and Stefan Hanenberg},
  title =	{{Evidence About Programmers for Programming Language Design (Dagstuhl Seminar 18061)}},
  pages =	{1--25},
  journal =	{Dagstuhl Reports},
  ISSN =	{2192-5283},
  year =	{2018},
  volume =	{8},
  number =	{2},
  editor =	{Andreas Stefik and Bonita Sharif and Brad A. Myers and Stefan Hanenberg},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2018/9288},
  URN =		{urn:nbn:de:0030-drops-92887},
  doi =		{10.4230/DagRep.8.2.1},
  keywords = {programming language design, computer science education, empirical software engineering, eye tracking, evidence standards}
}

@inproceedings{pears2007survey,
 abstract = {Three decades of active research on the teaching of introductory programming has had limited effect on classroom practice. Although relevant research exists across several disciplines including education and cognitive science, disci- plinary differences have made this material inaccessible to many computing educators. Furthermore, computer science instructors have not had access to a comprehensive survey of research in this area. This paper collects and classifies this literature, identifies important work and mediates it to computing educators and professional bodies. We identify research that gives well-supported advice to computing academics teaching introductory programming. Limitations and areas of incomplete coverage of existing re- search efforts are also identified. The analysis applies publication and research quality metrics developed by a previous ITiCSE working group [74].},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Pears et al. - 2007 - A survey of literature on the teaching of introductory programming.pdf:pdf},
 mendeley-tags = {difficulties,justification},
 author = {Pears, Arnold and Seidman, Stephen and Malmi, Lauri and Mannila, Linda and Adams, Elizabeth and Bennedsen, Jens and Devlin, Marie and Paterson, James},
 title = {A Survey of Literature on the Teaching of Introductory Programming},
 booktitle = {Proceedings of the 2007 ITiCSE Working Group Reports},
 series = {ITiCSE-WGR '07},
 year = {2007},
 location = {Dundee, Scotland},
 pages = {204--223},
 url = {http://doi.acm.org/10.1145/1345443.1345441},
 doi = {10.1145/1345443.1345441},
 acmid = {1345441},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {bibliography, computing education research, introductory programming, literature survey, teaching},
} 


@article{shute2008focus,
abstract = {This article reviews the corpus of research on feedback, with a focus on for- mative feedback defined as information communicated to the learner that is intended to modify his or her thinking or behavior to improve learning. According to researchers, formative feedback should be nonevaluative, sup- portive, timely, and specific. Formative feedback is usually presented as infor- mation to a learner in response to some action on the learner's part. It comes in a variety of types (e.g., verification of response accuracy, explanation of the correct answer, hints, worked examples) and can be administered at various times during the learning process (e.g., immediately following an answer, after some time has elapsed). Finally, several variables have been shown to inter- act with formative feedback's success at promoting learning (e.g., individual characteristics of the learner and aspects of the task). All of these issues are discussed. This review concludes with guidelines for generating formative feedback.},
author = {Shute, Valerie J.},
doi = {10.3102/0034654307313795},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Shute - 2008 - Focus on Formative Feedback.pdf:pdf},
issn = {0034-6543},
journal = {Review of Educational Research},
keywords = {pedagogy},
mendeley-tags = {pedagogy},
month = {Mar},
number = {1},
pages = {153--189},
title = {{Focus on Formative Feedback}},
url = {http://journals.sagepub.com/doi/10.3102/0034654307313795},
volume = {78},
year = {2008}
}

@phdthesis{harrington1984effect,
 abstract = {To investigate the effect of enhanced high-level computer programming language error messages on naive programmer performance, 39 subjects without prior programming experience were assigned randomly to three levels of error messages. Level One represented Applesoft BASIC's standard messages. Levels Two and Three provided additional parsing to identifying and describe the error more specifically. Subjects learned the rudiments of Applesoft BASIC in a 4-hour tutorial; no data was collected. Subjects then completed two experimental sessions consisting of one debugging and one original programming task. Transcripts of the experimental sessions were analyzed for number of errors made, average number of attempts made to correct an error, and success on the task. Latency between the printing of a message an an attempt to correct it was recorded within the computer and extracted at the end of each task. Prior to beginning sessions on the computer, subjects completed a standardized test for programmer aptitude. The data were subjected to multivariate analysis of covariance, using the aptitude score as the covariate and error message level as the between group factor. Though significant results were present for the effect of error message level on task success, examination of the group means did not show the expected pattern of increasing scores from Level One to Three. The data were divided into three aptitude groups. The MANOVA were re-run without a covariate using both error message level and aptitude group as between group factors. The task success measures demonstrated significant Fs for both aptitude group (p < .001) and error message level (p = .003). The error message level effect was again the result of poor performance by Level Two subjects. On the other hand, group means for aptitude group indicated rising success scores from low to high aptitude. This study substantiated the belief that individual aptitude in large measure determines how well someone will succeed at learning to program. It also indicated that merely increasing the specificity of error message texts will not necessarily decrease debugging effort or increase ultimate success.},
 author = {Harrington, Jan Lee},
 file = {::;::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Unknown - Unknown - Thesis Approval Form.pdf:pdf},
 keywords = {empirical,enhancement},
 mendeley-tags = {empirical,enhancement},
 school = {Drexel University},
 title = {{The Effect of Error Messages on Learning Computer Programming by Individuals Without Prior Programming Experience}},
 type = {PhD Thesis},
 year = {1984}
}

@article{qian2017students,
 abstract = {Efforts to improve computer science education are underway, and teachers of computer science are challenged in introductory programming courses to help learners develop their understanding of programming and computer science. Identifying and addressing students' misconceptions is a key part of a computer science teacher's competence. However, relevant research on this topic is not as fully developed in the computer science education field as it is in mathematics and science education. In this article, we first review relevant literature on general definitions of misconceptions and studies about students' misconceptions and other difficulties in introductory programming. Next, we investigate the factors that contribute to the difficulties. Finally, strategies and tools to address difficulties including misconceptions are discussed. Based on the review of literature, we found that students exhibit various misconceptions and other difficulties in syntactic knowledge, conceptual knowledge, and strategic knowledge. These difficulties experienced by students are related to many factors including unfamiliarity of syntax, natural language, math knowledge, inaccurate mental models, lack of strategies, programming environments, and teachers' knowledge and instruction. However, many sources of students' difficulties have connections with students' prior knowledge. To better understand and address students' misconceptions and other difficulties, various instructional approaches and tools have been developed. Nevertheless, the dissemination of these approaches and tools has been limited. Thus, first, we suggest enhancing the dissemination of existing tools and approaches and investigating their long-term effects. Second, we recommend that computing education research move beyond documenting misconceptions to address the development of students' (mis)conceptions by integrating conceptual change theories. Third, we believe that developing and enhancing instructors' pedagogical content knowledge (PCK), including their knowledge of students' misconceptions and ability to apply effective instructional approaches and tools to address students' difficulties, is vital to the success of teaching introductory programming.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Qian, Lehman - 2017 - Students' Misconceptions and Other Difficulties in Introductory Programming.pdf:pdf},
 mendeley-tags = {difficulties,justification,pedagogy},
 author = {Qian, Yizhou and Lehman, James},
 title = {Students\&\#x2019; Misconceptions and Other Difficulties in Introductory Programming: A Literature Review},
 journal = {ACM Transactions on Computing Education},
 issue_date = {December 2017},
 volume = {18},
 number = {1},
 month = oct,
 year = {2017},
 issn = {1946-6226},
 pages = {1:1--1:24},
 articleno = {1},
 numpages = {24},
 url = {http://doi.acm.org/10.1145/3077618},
 doi = {10.1145/3077618},
 acmid = {3077618},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Misconceptions, conceptual change, constructivism, difficulties, introductory programming},
}

@phdthesis{mccall2016novice,
 abstract = {All programmers make errors when writing program code, and for novices the difficulty of repairing errors can be frustrating and demoralising. It is widely recognised that compiler error diagnostics can be inaccurate, imprecise, or otherwise difficult for novices to comprehend, and many approaches to mitigating the difficulty of dealing with errors are centered around the production of diagnostic messages with improved accuracy and precision, and revised wording considered more suitable for novices. These efforts have shown limited success, partially due to uncertainty surrounding the types of error that students actually have the most difficulty with-which has most commonly been assessed by categorising them according to the diagnostic message already produced-and a traditional approach to the error diagnosis process which has known limitations. In this thesis we detail a systematic and thorough approach both to analysing which errors that are most problematic for students, and to automated diagnosis of errors. We detail a methodology for developing a category schema for errors and for classifying individual errors in student programs according to such a schema. We show that this classification results in a different picture of the distribution of error types when compared to a classification according to diagnostic messages. We formally define the severity of an error type as a product of its frequency and difficulty, and by using repair time as an indicator of difficulty we show that error types rank differently via severity than they do by frequency alone. Having developed a ranking of errors according to severity, we then investigate the contextual information within source code that experienced programmers can use to more accurately and precisely classify errors than compiler tools typically do. We show that, for a number of more severe errors, these techniques can be applied in an automated tool to provide better diagnostics than are provided by traditional compilers. II},
 author = {Mccall, Davin},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Mccall - 2016 - Novice Programmer Errors-Analysis and Diagnostics.pdf:pdf},
 keywords = {difficulties,guidelines},
 mendeley-tags = {difficulties,guidelines},
 school = {The University of Kent},
 title = {{Novice Programmer Errors-Analysis and Diagnostics}},
 url = {https://kar.kent.ac.uk/id/eprint/61340},
 year = {2016}
}

@article{brown2017novice,
 abstract = {Teaching is the process of conveying knowledge and skills to learners. It involves preventing misunderstandings or correcting misconceptions that learners have acquired. Thus, effective teaching relies on solid knowledge of the discipline, but also a good grasp of where learners are likely to trip up or misunderstand. In programming, there is much opportunity for misunderstanding, and the penalties are harsh: failing to produce the correct syntax for a program, for example, can completely prevent any progress in learning how to program. Because programming is inherently computer-based, we have an opportunity to automatically observe programming behaviour  more closely even than an educator in the room at the time. By observing students' programming behaviour, and surveying educators, we can ask: do educators have an accurate understanding of the mistakes that students are likely to make? In this study, we combined two years of the Blackbox dataset (with more than 900 thousand users and almost 100 million compilation events) with a survey of 76 educators to investigate which mistakes students make while learning to program Java, and whether the educators could make an accurate estimate of which mistakes were most common. We find that educators' estimates do not agree with one another or the student data, and discuss the implications of these results.},
 mendeley-tags = {difficulties,empirical},
 author = {Brown, Neil C. C. and Altadmri, Amjad},
 title = {Novice Java Programming Mistakes: Large-Scale Data vs. Educator Beliefs},
 journal = {ACM Transactions on Computing Education},
 issue_date = {June 2017},
 volume = {17},
 number = {2},
 month = may,
 year = {2017},
 issn = {1946-6226},
 pages = {7:1--7:21},
 articleno = {7},
 numpages = {21},
 url = {http://doi.acm.org/10.1145/2994154},
 doi = {10.1145/2994154},
 acmid = {2994154},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Programming mistakes, blackbox, educators, java},
}

@article{doukidis1989developing,
abstract = {The Pascal tutoring aid is designed to assist novice programmers in their understanding of Pascal, essentially by providing advice on the debugging of programs. This paper describes our development of the system, from the initial needs analysis to the implementation. The Pascal tutoring aid takes the form of an expert system, where the knowledge required to assist the students is maintained within a knowledge base and operated on by an inference engine. The features of the inference engine are discussed and the process of constructing the knowledge base is described in detail. The system has been evaluated and future developments are outlined. {\textcopyright} 1989.},
author = {Doukidis, Georgios I. and Rogers, Roderick A. and Angelides, Marios C.},
doi = {10.1016/0360-1315(89)90053-5},
file = {::},
issn = {03601315},
journal = {Computers and Education},
keywords = {enhancement},
mendeley-tags = {enhancement},
number = {4},
pages = {367--378},
title = {{Developing a Pascal Tutoring Aid}},
volume = {13},
year = {1989}
}
@article{shneiderman1982designing,
abstract = {In our use of interactive computer systems and studies of their users, we have become increasingly aware of the importance of system messages. Novice users are unimpressed with CPU speeds, disk storage capabilities, or elegant file structures. For them, the system appears only in the form of the messages on their screens or printers. So when novices encounter violent messages such as FATAL ERROR, RUN ABORTED, vague phases like ILLEGAL CMD, or obscure codes such as OC7 or IEH2191, they are understandably shaken, confused, dismayed, and discouraged from continuing. The negative image that computer systems sometimes generate is, we believe, largely due to the difficulties users experience when they make mistakes or are unsure about what to do next.},
author = {Shneiderman, Ben},
doi = {10.1145/358628.358639},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Shneiderman - 1982 - Designing Computer System Messages.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {guidelines},
mendeley-tags = {guidelines},
number = {9},
pages = {610--611},
title = {{Designing Computer System Messages}},
volume = {25},
year = {1982}
}

@article{stefik2013empirical,
 abstract = {Recent studies in the literature have shown that syntax remains a significant barrier to novice computer science students in the field. While this syntax barrier is known to exist, whether and how it varies across programming languages has not been carefully investigated. For this article, we conducted four empirical studies on programming language syntax as part of a larger analysis into the, so called, programming language wars. We first present two surveys conducted with students on the intuitiveness of syntax, which we used to garner formative clues on what words and symbols might be easy for novices to understand. We followed up with two studies on the accuracy rates of novices using a total of six programming languages: Ruby, Java, Perl, Python, Randomo, and Quorum. Randomo was designed by randomly choosing some keywords from the ASCII table (a metaphorical placebo). To our surprise, we found that languages using a more traditional C-style syntax (both Perl and Java) did not afford accuracy rates significantly higher than a language with randomly generated keywords, but that languages which deviate (Quorum, Python, and Ruby) did. These results, including the specifics of syntax that are particularly problematic for novices, may help teachers of introductory programming courses in choosing appropriate first languages and in helping students to overcome the challenges they face with syntax. systems on the three kinds of tasks used in this experiment. From the exploratory analysis, we conclude that developers using a dynamic type system tend to look at different files more frequently when doing programming tasks which is a potential reason for the observed differences in time.},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Stefik, Siebert - 2013 - An Empirical Investigation into Programming Language Syntax.pdf:pdf},
 journal = {ACM Transactions on Computing Education},
 mendeley-tags = {difficulties,pre-guidelines},
 author = {Stefik, Andreas and Siebert, Susanna},
 title = {An Empirical Investigation into Programming Language Syntax},
 issue_date = {November 2013},
 volume = {13},
 number = {4},
 month = nov,
 year = {2013},
 issn = {1946-6226},
 pages = {19:1--19:40},
 articleno = {19},
 numpages = {40},
 url = {http://doi.acm.org/10.1145/2534973},
 doi = {10.1145/2534973},
 acmid = {2534973},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Novice Programmers, Programming Languages, Syntax},
}

@inproceedings{chin1988development,
abstract = {This study is a part of a research effort to develop the Questionnaire for User Interface Satisfaction (QUIS). Participants, 150 PC user group members, rated familiar software products. Two pairs of software categories were compared: 1) software that was liked and disliked, and 2) a standard command line system (CLS) and a menu driven application (MDA). The reliability of the questionnaire was high, Cronbach's alpha=.94. The overall reaction ratings yielded significantly higher ratings for liked software and MDA over disliked software and a CLS, respectively. Frequent and sophisticated PC users rated MDA more satisfying, powerful and flexible than CLS. Future applications of the QUIS on computers are discussed.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Chin, John P. and Diehl, Virginia A. and Norman, Kent L.},
booktitle = {Annual Conference on Human Factors in Computing Systems, SIGCHI},
doi = {10.1145/57167.57203},
eprint = {arXiv:1011.1669v3},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Chin, Diehl, Norman - 1988 - Development of an Instrument Measuring User Satisfaction of the Human-Computer Interface.pdf:pdf},
isbn = {0201142376},
issn = {1098-6596},
keywords = {difficulties,guidelines,justification,pre-guidelines},
mendeley-tags = {difficulties,guidelines,justification,pre-guidelines},
pages = {213--218},
pmid = {25246403},
title = {{Development of an Instrument Measuring User Satisfaction of the Human-Computer Interface}},
url = {http://portal.acm.org/citation.cfm?doid=57167.57203},
year = {1988}
}

@article{gulwani2018automated,
 author = {Gulwani, Sumit and Radi\v{c}ek, Ivan and Zuleger, Florian},
 title = {Automated Clustering and Program Repair for Introductory Programming Assignments},
 booktitle = {Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '18},
 year = {2018},
 isbn = {978-1-4503-5698-5},
 location = {Philadelphia, PA, USA},
 pages = {465--480},
 numpages = {16},
 url = {http://doi.acm.org/10.1145/3192366.3192387},
 doi = {10.1145/3192366.3192387},
 acmid = {3192387},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {MOOC, clustering, dynamic analysis, program repair, programming education},
} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Semi-Systematic Papers
%%NO PAPERS SHOULD BE ADDED TO THIS SECTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@inproceedings{Hicks2007,
author = {Hicks, Boniface and King, Dave and McDaniel, Patrick},
doi = {10.1145/1255329.1255331},
file = {::},
keywords = {enhancement,guidelines},
mendeley-tags = {enhancement,guidelines},
title = {{Jifclipse}},
year = {2007}
}
@article{Chen2014Counter-Factual,
abstract = {Changing a program in response to a type error plays an important part in modern software development. However, the generation of good type error messages remains a problem for highly expressive type systems. Existing approaches often suffer from a lack of precision in locating errors and proposing remedies. Specifically, they either fail to locate the source of the type error consistently, or they report too many potential error locations. Moreover, the change suggestions offered are often incorrect. This makes the debugging process tedious and ineffective. We present an approach to the problem of type debugging that is based on generating and filtering a comprehensive set of type-change suggestions. Specifically, we generate all (program-structure- preserving) type changes that can possibly fix the type error. These suggestions will be ranked and presented to the programmer in an iterative fashion. In some cases we also produce suggestions to change the program. In most situations, this strategy delivers the correct change suggestions quickly, and at the same time never misses any rare suggestions. The computation of the potentially huge set of type-change suggestions is efficient since it is based on a variational type inference algorithm that type checks a program with variations only once, efficiently reusing type information for shared parts. We have evaluated our method and compared it with previous approaches. Based on a large set of examples drawn from the literature, we have found that our method outperforms other approaches and provides a viable alternative. {\textcopyright} 2014 ACM.},
author = {Chen, Sheng and Erwig, Martin},
doi = {10.1145/2535838.2535863},
file = {::},
isbn = {9781450325448},
journal = {POPL '14 Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
keywords = {change suggestions,choice types,enhancement,error localization,type error messages,type inference,type-error debugging},
mendeley-tags = {enhancement},
pages = {583--594},
title = {{Counter-factual typing for debugging type errors}},
year = {2014}
}
@article{MÃ¸ller2011HTML,
abstract = {We present an algorithm that generalizes HTML validation of individual documents to work on context-free sets of documents. Together with a program analysis that soundly approximates the output of Java Servlets and JSP web applications as context-free languages, we obtain a method for statically checking that such web applications never produce invalid HTML at runtime. Experiments with our prototype implementation demonstrate that the approach is useful: On 6 open source web applications consisting of a total of 104 pages, our tool finds 64 errors in less than a second per page, with 0 false positives. It produces detailed error messages that help the programmer locate the sources of the errors. After manually correcting the errors reported by the tool, the soundness of the analysis ensures that no more validity errors exist in the applications.},
author = {M{\o}ller, Anders and Schwarz, Mathias},
doi = {10.1007/978-3-642-19805-2_29},
file = {::},
isbn = {9783642198045},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {errors-only},
mendeley-tags = {errors-only},
number = {274},
pages = {426--440},
title = {{HTML validation of context-free languages}},
volume = {6604 LNCS},
year = {2011}
}
@article{Siau2005,
abstract = {Technical communicators can and should play an important role in the development of information systems to improve the usability of the systems. Besides writing user guides and training material, technical communicators can engage in four other tasks to add value to information systems development: acting as user advocate, writing online help, writing system and error messages, and providing advice on interface design. We assert that technical communicators' involvement in systems development should not be tied to a particular development methodology. Instead, they should be associated with four general tasks in systems development: system investigation, analysis, design, and implementation. We then discuss some notable human factors and their impacts on the tasks performed by technical communicators. Three cognitive mapping techniques-causal mapping, semantic mapping, and concept mapping-are introduced as a means to elicit an individual's belief system regarding a problem domain. These cognitive mapping techniques have great potential for overcoming some behavioral and cognitive problems as well as facilitating understanding among stakeholders in the development of information systems. We discuss how technical communicators can apply various cognitive mapping techniques to improve the usability of the resulting information systems. The use of these techniques is illustrated using a case study.},
author = {Siau, Keng and Tan, Xin},
doi = {10.1109/TPC.2005.853933},
file = {::},
issn = {03611434},
journal = {IEEE Transactions on Professional Communication},
keywords = {Cognitive mapping,Information systems development,Technical communication,gen-lit},
mendeley-tags = {gen-lit},
number = {3},
pages = {269--284},
title = {{Technical communication in information systems development: The use of cognitive mapping}},
volume = {48},
year = {2005}
}

@inproceedings{luecke2009importance,
 abstract = {The ability of system software to detect and issue error messages that help programmers quickly fix serial and parallel run-time errors is an important productivity criterion for developing and maintaining application programs. Over ten thousand run-time error tests and a run-time error detection (RTED) evaluation tool has been developed for the automatic evaluation of run-time error detection capabilities for serial errors and for parallel errors in MPI, OpenMP and UPC programs. Evaluation results, tests and the RTED evaluation tool are freely available at http://rted.public.iastate.edu. Many compilers, tools and run-time systems scored poorly on these tests. The authors make recommendations for providing better RTED in the future.},
 author = {Luecke, Glenn R and Coyle, James and Hoekstra, James and Kraeva, Marina and Xu, Ying},
 doi = {10.1007/978-3-642-11261-4},
 file = {::},
 isbn = {9783642112614},
 booktitle = {Tools for High Performance Computing 2009},
 keywords = {runtime-errors,technical},
 mendeley-tags = {runtime-errors,technical},
 number = {January},
 title = {{The Importance of Run-time Error Detection}},
 year = {2009},
 pages="145--155",
}

@inproceedings{niebler2007proto,
 abstract = {A Domain-Specific Embedded Language (DSEL) is a miniature language-within-a-language for solving problems in a particular domain. One technique for creating efficient and expressive DSELs in C++ is to use expression templates, but this technique is not for the faint of heart. Such libraries are difficult to write and maintain due to the esoteric nature of template meta-programming, and difficult to use because of the often impenetrable compiler error messages they generate. Existing tools help somewhat, but do not provide the support that language designers have come to expect: something like BNF for defining the language's grammar and associated semantic actions. This paper describes Proto, a C++ library that implements a compiler construction toolkit for embedded languages. The benefits of grammar-based DSELs are shown by contrasting them to other existing approaches to DSEL design. The nature of embedded languages with constrained grammars and their implications for a embedded compiler construction toolkit is briefly explored. Some examples are shown where library interfaces can be made more expressive through the use of grammar-based DSELs.},
 mendeley-tags = {technical},
 author = {Niebler, Eric},
 title = {Proto: A Compiler Construction Toolkit for DSELs},
 booktitle = {Proceedings of the 2007 Symposium on Library-Centric Software Design},
 series = {LCSD '07},
 year = {2007},
 isbn = {978-1-60558-086-9},
 location = {Montreal, Canada},
 pages = {42--51},
 url = {http://doi.acm.org/10.1145/1512762.1512767},
 doi = {10.1145/1512762.1512767},
 acmid = {1512767},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{Chen2014a,
abstract = {Current C++ implementations typecheck templates in two phases: Before instantiation, those parts of the template are checked that do not depend on template parameters, while the checking of the remaining parts is delayed until template instantiation time when the template arguments become available. This approach is problematic because it causes two major usability problems. First, it prevents library developers to provide guarantees about the type correctness for modules involving templates. Second, it can lead, through the incorrect use of template functions, to inscrutable error messages. Moreover, errors are often reported far away from the source of the program fault. To address this problem, we have developed a type system for Garcia's type-reflective calculus that allows a more precise characterization of types and thus a better utilization of type information within template definitions. This type system allows the static detection of many type errors that could previously only be detected after template instantiation. The additional precision and earlier detection time is achieved through the use of so-called "choice types" and corresponding typing rules that support the static reasoning about underspecified template types. The main contribution of this paper is a guarantee of the type safety of C++ templates (general definitions with specializations) since we can show that well-typed templates only generate well-typed object programs. Categories and Subject Descriptors F.3.3 [Logics and Meanings of Programs]: Studies of Program Constructs-Type structure; D.3.1 [Programming Languages]: Formal Definition and Theory.},
author = {Chen, Sheng and Erwig, Martin},
doi = {10.1145/2543728.2543731},
file = {::},
keywords = {gen-lit},
mendeley-tags = {gen-lit},
title = {{Early detection of type errors in C++ templates}},
year = {2014}
}
@article{sutton2013emulating,
abstract = {A library for the emulation of C++0x concepts developed using the emerging C++11 programming language is presented. The library integrates existing techniques for concept checking and template metaprogramming to provide a uniform interface to defining and using concepts. The purpose of this work is to establish a concrete foundation for experimentation of design techniques for concepts and to motivate and evaluate language design. The viability of the approach is demonstrated by applying it to characterize a number of previously identified usability problems with concepts in the proposed C++0x language. In particular, issues related to the use of explicit and automatic concepts in generic library design from the perspective of this experiment are examined. Issues related to concept refinement, default implementations of requirements, and the generation of error messages are also discussed.},
author = {Sutton, Andrew and Maletic, Jonathan I},
file = {::},
journal = {Science of Computer Programming},
keywords = {c,concepts,generic libraries,technical},
mendeley-tags = {technical},
number = {9},
pages = {1449--1469},
title = {{Emulating C++ 0x Concepts}},
volume = {78},
year = {2013}
}
@article{ulloa1983survey,
author = {Ulloa, Miguel},
doi = {10.1145/1045078.1045081},
file = {::},
issn = {01635735},
journal = {ACM SIGCUE Outlook},
keywords = {empirical,runtime-errors},
mendeley-tags = {empirical,runtime-errors},
number = {3},
pages = {21--25},
title = {{A survey of run-time and logic errors in a classroom environment}},
volume = {17},
year = {1983}
}
@article{seidel2016dynamic,
abstract = {Static type errors are a common stumbling block for newcomers to typed functional languages. We present a dynamic approach to explaining type errors by generating counterexample witness inputs that illustrate how an ill-typed program goes wrong. First, given an ill-typed function, we symbolically execute the body to synthesize witness values that make the program go wrong. We prove that our procedure synthesizes general witnesses in that if a witness is found, then for all inhabited input types, there exist values that can make the function go wrong. Second, we show how to extend this procedure to produce a reduction graph that can be used to interactively visualize and debug witness executions. Third, we evaluate the coverage of our approach on two data sets comprising over 4,500 ill-typed student programs. Our technique is able to generate witnesses for around 85% of the programs, our reduction graph yields small counterexamples for over 80% of the witnesses, and a simple heuristic allows us to use witnesses to locate the source of type errors with around 70% accuracy. Finally, we evaluate whether our witnesses help students understand and fix type errors, and find that students presented with our witnesses show a greater understanding of type errors than those presented with a standard error message.},
author = {Seidel, Eric L. and Jhala, Ranjit and Weimer, Westley},
doi = {10.1145/3022670.2951915},
file = {::},
isbn = {9781450342193},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {debugging,enhancement,technical,testing,tool,type errors},
mendeley-tags = {enhancement,technical,tool},
number = {9},
pages = {228--242},
title = {{Dynamic witnesses for static type errors (or, ill-typed programs usually go wrong)}},
volume = {51},
year = {2016}
}
@inproceedings{medeiros2016parsing,
abstract = {Parsing Expression Grammars (PEGs) are a formalism for specify-ing the syntax of programming languages which can be viewed as a description of a recursive descent parser for the language it de-scribes. An issue that users of PEG-based parsers face is poor re-porting of syntax errors on the part of PEG-based parsers. Labeled failures are an extension to PEGs that aims to address this issue by annotating a PEG with labels corresponding to syntax errors, im-proving the quality of error messages generated by a PEG-based parser. An alternative formulation of PEGs gives the meaning of a PEG by translation into a program of a virtual parsing machine. In this paper, we present an updated semantics for PEGs with labeled fail-ures, and we show how to extend the parsing machine to support them. We also prove the correctness of the translation from PEGs with labels to programs of this extended parsing machine, and we evaluate the use of labeled failures on PEG-based parsers which implement their own ad-hoc error reporting strategy.},
author = {Medeiros, S{\'{e}}rgio and Mascarenhas, Fabio},
booktitle = {Proceedings of the 31st Annual ACM Symposium on Applied Computing},
doi = {10.1145/2851613.2851750},
file = {::},
isbn = {9781450337397},
keywords = {enhancement,technical},
mendeley-tags = {enhancement,technical},
pages = {1960--1967},
title = {{A parsing machine for parsing expression grammars with labeled failures}},
year = {2016}
}
@article{Takikawa2016Is,
abstract = {Programmers have come to embrace dynamically-typed languages for prototyping and delivering large and complex systems. When it comes to maintaining and evolving these systems, the lack of explicit static typing becomes a bottleneck. In response, researchers have explored the idea of gradually-typed programming languages which allow the incremental addition of type annotations to software written in one of these untyped languages. Some of these new, hybrid languages insert run-time checks at the boundary between typed and untyped code to establish type soundness for the overall system. With sound gradual typing, programmers can rely on the language implementation to provide meaningful error messages when type invariants are violated. While most research on sound gradual typing remains theoretical, the few emerging implementations suffer from performance overheads due to these checks. None of the publications on this topic comes with a comprehensive performance evaluation. Worse, a few report disastrous numbers. In response, this paper proposes a method for evaluating the performance of gradually-typed programming languages. The method hinges on exploring the space of partial conversions from untyped to typed. For each benchmark, the performance of the different versions is reported in a synthetic metric that associates runtime overhead to conversion effort. The paper reports on the results of applying the method to Typed Racket, a mature implementation of sound gradual typing, using a suite of real-world programs of various sizes and complexities. Based on these results the paper concludes that, given the current state of implementation technologies, sound gradual typing faces significant challenges. Conversely, it raises the question of how implementations could reduce the overheads associated with soundness and how tools could be used to steer programmers clear from pathological cases.},
author = {Takikawa, Asumu and Feltey, Daniel and Greenman, Ben and New, Max S. and Vitek, Jan and Felleisen, Matthias},
doi = {10.1145/2914770.2837630},
file = {::},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {errors-only,gradual typing,performance evaluation},
mendeley-tags = {errors-only},
number = {1},
pages = {456--468},
title = {{Is sound gradual typing dead?}},
volume = {51},
year = {2016}
}
@article{Asperti2012,
abstract = {The paper describes the refinement algorithm for the Calculus of (Co)Inductive Constructions (CIC) implemented in the interactive theorem prover Matita. The refinement algorithm is in charge of giving a meaning to the terms, types and proof terms directly written by the user or generated by using tactics, decision procedures or general automation. The terms are written in an "external syntax" meant to be user friendly that allows omission of information, untyped binders and a certain liberal use of user defined sub-typing. The refiner modifies the terms to obtain related well typed terms in the internal syntax understood by the kernel of the ITP. In particular, it acts as a type inference algorithm when all the binders are untyped. The proposed algorithm is bi-directional: given a term in external syntax and a type expected for the term, it propagates as much typing information as possible towards the leaves of the term. Traditional mono-directional algorithms, instead, proceed in a bottom-up way by inferring the type of a sub-term and comparing (unifying) it with the type expected by its context only at the end. We propose some novel bi-directional rules for CIC that are particularly effective. Among the benefits of bi-directionality we have better error message reporting and better inference of dependent types. Moreover, thanks to bi-directionality, the coercion system for sub-typing is more effective and type inference generates simpler unification problems that are more likely to be solved by the inherently incomplete higher order unification algorithms implemented. Finally we introduce in the external syntax the notion of vector of placeholders that enables to omit at once an arbitrary number of arguments. Vectors of placeholders allow a trivial implementation of implicit arguments and greatly simplify the implementation of primitive and simple tactics.},
author = {Asperti, Andrea and Ricciotti, Wilmer and Coen, Claudio Sacerdoti and Tassi, Enrico},
doi = {10.2168/LMCS-8},
file = {::},
issn = {18605974},
journal = {Logical Methods in Computer Science},
keywords = {Calculus of inductive constructions,Interactive theorem prover,Matita,Refiner,Type inference,enhancement},
mendeley-tags = {enhancement},
number = {2 SPEC. ISS.},
pages = {1--49},
title = {{A bi-directional refinement algorithm for the calculus of (Co)inductive constructions}},
volume = {8},
year = {2012}
}
@article{Gross2013,
abstract = {Syntactic mistakes and misconceptions in programming can have a negative impact on students' learning gains, and thus require par- ticular attention in order to help students learn programming. In this pa- per, we propose embedding a discourse on syntactic issues and student's misconceptions into a dialogue between a student and an intelligent tu- tor. Based on compiler (error) messages, the approach aims to determine the cause for the error a student made (carelessness, misconception, or lack of knowledge) by requesting explanations for the violated syntactic construct. Depending on that cause, the proposed systemadapts dialogue behaviours to student's needs by asking her to reflect on her knowledge in a self-explanation process, providing error-specific explanations, and enabling her to fix the error herself. This approach is designed to encour- age students to develop a deeper understanding of syntactic concepts in programming.},
author = {Gross, Sebastian and Strickroth, Sven and Pinkwart, Niels and Le, Nguyen Thinh},
file = {::},
issn = {16130073},
journal = {CEUR Workshop Proceedings},
keywords = {Dialogue-based tutoring,Intelligent tutoring systems,Programming,empirical,enhancement},
mendeley-tags = {empirical,enhancement},
pages = {11--19},
title = {{Towards deeper understanding of syntactic concepts in programming}},
volume = {1009},
year = {2013}
}
@article{Allwood1991training,
abstract = {The present study reports on the effects of providing novices in Pascal one hour of training in the debugging of their own programs. The training presented subjects with results from previous research on novices' debugging as well as fairly detailed instructions on how to debug a program. Furthermore, the instructions included explanations of common error messages from the computer. The debugging performed by the eleven subjects who received training was compared with the debugging performed by ten control subjects who programmed on their own during the training hour. The results show that the subjects who received training debugged a significantly larger proportion of their errors compared with subjects who received no training. The results suggest that especially the semantic programming errors were easier to debug for the trained group. No differences in detailed debugging behaviour were found between the groups. {\^{A}}{\textcopyright} 1991.},
author = {Allwood, C. M. and Bj{\"{o}}rhag, C. G.},
doi = {10.1016/0001-6918(91)90008-N},
file = {::},
journal = {Acta Psychologica},
keywords = {gen-lit},
mendeley-tags = {gen-lit},
number = {1-3},
pages = {137--150},
title = {{Training of Pascal novices' error handling ability}},
volume = {78},
year = {1991}
}
@article{bachelet2017designing,
abstract = {Concepts are likely to be introduced in a future C++ standard. They can be used for constraining tem- plate parameters, which enables checking requirements on template parameters sooner in the compilation process, and thus providing more intelligible error messages to the user. They can also be used in the specialization of templates, thus leading to a better control over the selection of the most appropriate version of a template for a given instantiation. This latter aspect offers new possibilities in the design of template libraries, as it enhances the specialization mechanism of templates, and set it up as a solid alternative to inheritance when static binding can replace dynamic binding. This report addresses the design of expression templates (i.e. templates that represent expressions and are usually built through operator overloading) that are useful to develop an embedded domain specific lan- guage (EDSL), and can speed up the evaluation of an expression by delaying the evaluation of intermediate operations to avoid unnecessary temporary objects. We propose to use concept-based template specialization to parse expression templates in order to ease the design of an EDSL. This approach is a static variant of the well-known visitor design pattern that replaces the overridden methods in the double dispatch of the original design pattern by template special- izations based on concepts. An example of EDSL for linear programming developed with our solution demonstrates that a concept-based design helps producing concise and reliable code.},
author = {Bachelet, Bruno and Yon, Lo{\"{i}}c and Bachelet, Bruno and Yon, Lo{\"{i}}c and Expression, Designing and Software, Concepts},
file = {::},
keywords = {concept-based specialization,expression templates,generic programming,technical,template metaprogramming,template specialization},
mendeley-tags = {technical},
number = {11},
pages = {1521--1537},
title = {{Designing Expression Templates with Concepts}},
volume = {47},
year = {2017}
}
@article{epstein2007error,
author = {Epstein, David},
doi = {10.1145/242719.242725},
file = {::},
issn = {10617264},
journal = {ACM SIGPLAN Fortran Forum},
keywords = {technical},
mendeley-tags = {technical},
number = {2},
pages = {15--18},
title = {{Error messages in F}},
volume = {15},
year = {2007}
}
@inproceedings{lerner2006seminal,
abstract = {We present a new way to generate type-error messages in a poly- morphic, implicitly, and strongly typed language (specifically Caml). Our method separates error-message generation from type- checking by taking a fundamentally new approach: we present to programmers small term-level modifications that cause an ill-typed program to become well-typed. This approach aims to improve feedback to programmers with no change to the underlying type- checker nor the compilation of well-typed programs. We have added a prototype implementation of our approach to the Objective Caml system by intercepting type-checker error mes- sages and using the type-checker on candidate changes to see if they succeed. This novel front-end architecture naturally decom- poses into (1) enumerating local changes to the abstract syntax tree that may remove type errors, (2) searching for places to try the changes, (3) using the type-checker to evaluate the changes, and (4) ranking teh changes and presenting them to the user.},
author = {Lerner, Benjamin and Grossman, Dan and Chambers, Craig},
file = {::},
isbn = {1595934839},
keywords = {Error Messages,Ob- jective Caml,Seminal,Type-Checking,Type-Inference,technical},
mendeley-tags = {technical},
title = {{SEMINAL: Searching for ML Type-Error Messages}},
year = {2006}
}
@article{Zhan2019A,
abstract = {In this paper, a controlled natural language (CNL) based program synthesis system for the Lego Mindstorms EV3 (EV3) is introduced. The system is developed with the intention of helping middle and high school Lego robotics enthusiasts and non-programmers to learn the necessary skills for programming and engineering the robot with less effort. The system generates the resulting code in Microsoft Small Basic that controls the EV3 Intelligent Brick with supports for all EV3 sensors and motors. Preliminary results show that our approach is capable of generating functional, executable code based on the users' controlled natural language specifications. Detailed error messages are also given when confronted with unimplementable sentences.},
author = {Zhan, Yue and Hsiao, Michael},
doi = {10.1109/AIVR.2018.00043},
isbn = {9781538692691},
journal = {Proceedings - 2018 IEEE International Conference on Artificial Intelligence and Virtual Reality, AIVR 2018},
keywords = {Lego Mindstorms EV3,Natural language,Program synthesis,runtime-errors},
mendeley-tags = {runtime-errors},
pages = {191--192},
title = {{A natural language programming application for lego mindstorms EV3}},
year = {2019}
}
@article{lilis2013integrated,
author = {Lilis, Yannis and Savidis, Anthony},
doi = {10.5381/jot.2013.12.3.a1},
file = {::},
issn = {16601769},
journal = {Journal of Object Technology},
keywords = {Compile-time metaprogramming,Error messages.,Metaprograms,Run-time metaprogramming,Source-level debugging,Staged languages,technical},
mendeley-tags = {technical},
number = {3},
pages = {1--26},
title = {{An integrated approach to source level debugging and compile error reporting in metaprograms}},
volume = {12},
year = {2013}
}

@inproceedings{Eilers2011,
address = {New York, New York, USA},
author = {Eilers, Dan R. and Koskinen, Tero},
booktitle = {Proceedings of the 2011 ACM annual international conference on Special interest group on the ada programming language - SIGAda '11},
doi = {10.1145/2070337.2070361},
file = {::},
isbn = {9781450310284},
keywords = {gen-lit},
mendeley-tags = {gen-lit},
pages = {75},
publisher = {ACM Press},
title = {{Making the non-executable ACATS tests executable}},
url = {http://dl.acm.org/citation.cfm?doid=2070337.2070361},
year = {2011}
}

@article{Fisher1999,
 abstract = {System status and error messages are the most frequently occurring forms of communication between an information system and a user. These messages often communicate critical information and yet they are regularly not written in the most accessible way. The construction, display and style of the messages will impact ultimately on the usability and costs of a system. This paper reports on research, which identified problems with the current approach to the development and writing of system and error message text and proposes that using specialist communication expertise, users will be happier and will interact more effectively with information systems.},
 keywords = {Human factors,IS development,guidelines,justification,user attitudes,user satisfaction},
 mendeley-tags = {guidelines,justification},
 year = {1999},
 author = {Fisher, Julie},
 month = {Nov},
 pages = {118-123},
 title = {The Importance of User Message Text and Why Professional Writers Should Be Involved.},
 volume = {31},
 journal = {Australian Computer Journal}
}

@inproceedings{serrano2016type,
abstract = {In the functional programming world, it is common to embed a domain specific language (DSL) in a general purpose language. Unfor- tunately, the extra abstraction layer provided by the DSL is lost when a type error occurs, and internals leak to users of the DSL. This paper presents specialized type rules, a way to influence which part of the program is blamed and how the particular error message is worded. These type rules match part of the programming language abstract syntax tree (AST) and guide the type checker in order to pro- vide custom diagnostics. Our goal is to enable DSL writers to keep their high-level abstractions throughout the whole development experience. Specialized type rules have already been considered in the literature: we enhance them by providing a mechanism to allow type rules to depend on partial type information. The technique presented in this paper can be readily applied to any type engine which uses constraints to perform its duty. We refine the workings of the type engine by including a second gathering pass in case an error is found. In that second pass, partial type information can be used to select a type rule. In particular, we have implemented our tech- niques in a type engine based on the OutsideIn(X) framework, which underlies the Haskell GHC compiler since version 7.},
address = {New York, NY, USA},
author = {Serrano, Alejandro and Hage, Jurriaan},
booktitle = {Proceedings of the 25th European Symposium on Programming Languages and Systems - Volume 9632},
doi = {10.1007/978-3-662-49498-1_26},
file = {::},
isbn = {978-3-662-49497-4},
issn = {16113349},
keywords = {enhancement,technical},
mendeley-tags = {enhancement,technical},
pages = {672--698},
publisher = {Springer-Verlag New York, Inc.},
title = {{Type Error Diagnosis for Embedded DSLs by Two-Stage Specialized Type Rules}},
url = {https://doi.org/10.1007/978-3-662-49498-1_26},
year = {2016}
}
@article{eremondi2019framework,
abstract = {Dependently-typed programming languages provide a powerful tool for establishing code correctness. However, it can be hard for newcomers to learn how to employ the advanced type system of such languages effectively. For simply-typed languages, several techniques have been devised to generate helpful error messages and suggestions for the programmer. We adapt these techniques to dependently-typed languages, to facilitate their more widespread adoption. In particular, we modify a higher-order unification algorithm that is used to resolve and type-check implicit arguments. We augment this algorithm with replay graphs, allowing for a global heuristic analysis of a unification problem-set, error-tolerant typing, which allows type-checking to continue after errors are found, and counter-factual unification, which makes error messages less affected by the order in which types are checked. A formalization of our algorithm is presented with an outline of its correctness. We implement replay graphs, and compare the generated error messages to those from existing languages, highlighting the improvements we achieved.},
author = {Eremondi, Joseph and Swierstra, Wouter and Hage, Jurriaan},
doi = {10.1515/comp-2019-0001},
file = {::},
journal = {Open Computer Science},
keywords = {counter-factual typing,higher-order unification,technical,type error diagnosis,type-inference},
mendeley-tags = {technical},
number = {1},
pages = {1--32},
title = {{A framework for improving error messages in dependently-typed languages}},
volume = {9},
year = {2019}
}
@article{Wagner1973Common,
abstract = {A method for saving storage space for text strings, such as compiler diagnostic messages, is described. The method relies on hand selection of a set of text strings which are common to one or more messages. These phrases are then stored only once. The storage technique gives rise to a mathematical optimization problem: determine how each message should use the available phrases to minimize its storage requirement. This problem is nontrivial when phrases which overlap exist. However, a dynamic programming algorithm is presented which solves the problem in time which grows linearly with the number of characters in the text. Algorithm 444 applies to this paper.},
author = {Wagner, Robert A.},
doi = {10.1145/361972.361982},
file = {::},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {diagnostic messages,dynamic programming,error,errors-only,messages,minimum space,optimization,storage,text},
mendeley-tags = {errors-only},
number = {3},
pages = {148--152},
title = {{Common phrases and minimum-space text storage}},
volume = {16},
year = {1973}
}
@article{Barton2010Dynamic,
abstract = {Breakpoints are perhaps the quintessential feature of a de-bugger: they allow a developer to stop time and study the program state. Breakpoints are typically specified by selecting a line of source code. For large, complex, web pages with multiple developers, ...},
author = {Barton, John J. and Odvarko, Jan},
doi = {10.1145/1772690.1772700},
file = {::},
isbn = {9781605587998},
keywords = {debugging,dynamic debugger html,errors-only,firebug,javascript},
mendeley-tags = {errors-only},
pages = {81},
title = {{Dynamic and graphical web page breakpoints}},
year = {2010}
}
@inproceedings{Elazhary2009,
abstract = {High-level languages and very high-level languages have been developed to simplify programming. However, programming is still not an easy task for everyone. This paper discusses the concept of facile programming, where programming languages should be made as easy as possible to be easily learnt, remembered, and used by people from different disciplines. This is achieved by trying to figure out all the difficulties that face such programmers and trying to tackle them. The paper addresses one difficulty, which is that not every programmer is given the chance to program in his natural language or at least a language like his natural language. Thus, it is hard for programmers who do not speak English to learn, remember, and use English-like programming languages and understand the English compilation error messages. Unfortunately, there are very few attempts in the literature to address this problem and these attempts do not handle common programming languages and thus, have not been accepted. To tackle this problem, we developed an Arabic version of Lisp, namely Arabic Lisp. We also developed Arabic Lispizer, which not only translates Arabic Lisp to Lisp (and vice versa for portability), but also detects syntax errors and produces corresponding error messages in Arabic.},
author = {Elazhary, Hanan},
booktitle = {Proceedings of the 21st International Conference on Software Engineering and Knowledge Engineering, SEKE 2009},
file = {::},
isbn = {1891706241},
keywords = {pedagogy},
mendeley-tags = {pedagogy},
pages = {382--385},
title = {{Arabic lisp}},
year = {2009}
}

@book{devai2013edsls,
 abstract = {Embedded Domain Specific Languages make language design and implementation easier, because lexical and syntactical analysis and part of the semantic checks can be completed by the compiler of the host language. On the other hand, by the nature of embedding, EDSL compilers have to work with a syntax tree that stores no information about the source file processed and the location of the program entities within the source file. This makes it hard to produce user-friendly error messages and connect the generated target code with the source code for debug- ging and profiling purposes. This lecture note presents this problem in detail and shows possi- ble solutions. The first, lightweight solution uses macro preprocessing. The second one is based on syntax tree transformations to add missing source-related information. This is more powerful, but also more heavy- weight. The last technique avoids the problem by turning the embedded language implementation to a standalone one (with own parser) after the experimental phase of the language development process: It turns out that most of the embedded implementation can be reused in the standalone one},
 address = {Cham},
 author={D{\'e}vai, Gergely and Lesk{\'o}, D{\'a}niel and Tejfel, M{\'a}t{\'e}},
 doi = {10.1007/978-3-319-15940-9_7},
 url = {https://doi.org/10.1007/978-3-319-15940-9_7},
 OPTeditor = {Zs{\'{o}}k, Vikt{\'{o}}ria and Horv{\'{a}}th, Zolt{\'{a}}n and Plasmeijer, Rinus},
 file = {::},
 isbn = {978-3-642-32095-8},
 keywords = {guidelines,technical},
 mendeley-tags = {guidelines,technical},
 pages = {300--335},
 publisher = {Springer},
 series = {In: Zs\'{o}k V., Horv\'{a}th Z., Csat\'{o} L. (eds) Central European Functional Programming School. CEFP 2013. Lecture Notes in Computer Science},
 title = {{The EDSL's Struggle for Their Sources}},
 volume = {8606},
 year = {2013}
}

@article{maidl2013exception,
author = {Maidl, Andr{\'{e}} Murbach and Mascarenhas, Fabio and Ierusalimschy, Roberto},
doi = {10.1007/978-3-642-40922-6_1},
file = {::},
isbn = {9783642409219},
issn = {16113349},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {error reporting,packrat parsing,parser combinators,parsing,parsing expression grammars,technical},
mendeley-tags = {technical},
pages = {1--15},
title = {{Exception handling for error reporting in parsing expression grammars}},
volume = {8129 LNCS},
year = {2013}
}
@inproceedings{ureel2019automated,
author = {{Ureel II}, Leo C. and Wallace, Charles},
booktitle = {Proceedings of the 50th ACM Technical Symposium on Computer Science Education},
doi = {10.1145/3287324.3287463},
file = {::},
isbn = {9781450358903},
keywords = {CS1,all or part of,autograder,by the national science,critiquing syste,critiquing systems,cs1,design patterns,foundation under grant due-1504860,or,or hard copies of,pedagogy,permission to make digital,technical,this work for personal,this work is supported},
mendeley-tags = {pedagogy,technical},
pages = {738--744},
title = {{Automated Critique of Early Programming Antipatterns}},
year = {2019}
}
@article{loncaric2016practical,
abstract = {{\textcopyright} 2016 ACM. Many languages have support for automatic type inference. But when inference fails, the reported error messages can be unhelpful, highlighting a code location far from the source of the problem. Several lines of work have emerged proposing error reports derived from correcting sets: a set of program points that, when fixed, produce a well-typed program. Unfortunately, these approaches are tightly tied to specific languages; targeting a new language requires encoding a type inference algorithm for the language in a custom constraint system specific to the error reporting tool. We show how to produce correcting set-based error reports by leveraging existing type inference implementations, easing the burden of adoption and, as type inference algorithms tend to be efficient in practice, producing error reports of comparable quality to similar error reporting tools orders of magnitude faster. Many type inference algorithms are already formulated as dual phases of type constraint generation and solving; rather than (re)implementing type inference in an error explanation tool, we isolate the solving phase and treat it as an oracle for solving typing constraints. Given any set of typing constraints, error explanation proceeds by iteratively removing conflicting constraints from the initial constraint set until discovering a subset on which the solver succeeds; the constraints removed form a correcting set. Our approach is agnostic to the semantics of any particular language or type system, instead leveraging the existing type inference engine to give meaning to constraints.},
author = {Loncaric, Calvin and Chandra, Satish and Schlesinger, Cole and Sridharan, Manu},
doi = {10.1145/3022671.2983994},
file = {::},
isbn = {9781450344449},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {technical},
mendeley-tags = {technical},
number = {10},
pages = {781--799},
title = {{A practical framework for type inference error explanation}},
volume = {51},
year = {2016}
}
@article{Srisopa2008A,
abstract = {We have noticed that the beginning programming students often make programming errors such as leaving out mandatory opening and/or closing curly braces, leaving out a mandatory semicolon, putting in an extraneous semicolon, and misspelling a keyword. Also, the error messages generated by the standard Java compiler in such situations do not state the exact problem. As a result, it is difficult for the students to identify and fix their errors. Therefore, we have developed a software tool that can be used to write Java programs and it has a language analysis component that can detect the common programming errors and report their causes more precisely. Our tool also provides two unique types of exercises with the goal of helping the students build up their problem-solving skills so that they can write code from scratch. It also allows the user to review lecture notes in an easy-to-view manner while they are doing the exercises using this tool. The lecture notes and the exercises can be easily downloaded and updated or incorporated into our tool through our friendly user interface. The tool can be used by students in introductory programming courses either in or outside the classroom.},
author = {Srisopa, Grittigon and Suranauwarat, Sukanya},
file = {::},
journal = {nternational Conference on Knowledge-Based and Intelligent Information and Engineering Systems},
keywords = {ambiguous or misleading error,compiler and java,educational tool,enhancement,especially beginning programming students,for,messages that confuse the,testing and assessment,tool,user},
mendeley-tags = {enhancement},
title = {{A Software Tool for an Introductory Java Programming Course}},
year = {2008}
}

@article{Coyle2013,
abstract = {Unified Parallel C (UPC) is a language used to write parallel programs for distributed memory parallel computers. UPC-CHECK (http://hpcgroup.public. iastate.edu/UPC-CHECK/) is a scalable tool developed to automatically detect argument errors in UPC functions and deadlocks in UPC programs at run-time and issue high quality error messages to help programmers quickly fix those errors. The run-time complexity of all detection techniques used are optimal, i.e. O(1) except for deadlocks involving locks where it is theoretically known to be linear in the number of threads. The tool is easy to use, and involves merely replacing the compiler command with upc-check. Error messages issued by UPC-CHECK were evaluated using the UPC RTED test suite for argument errors in UPC functions and deadlocks. Results of these tests show that the error messages issued by UPC-CHECK for these tests are excellent. {\textcopyright} 2012 Springer-Verlag.},
author = {Coyle, James and Roy, Indranil and Kraeva, Marina and Luecke, Glenn R.},
doi = {10.1007/s00450-012-0214-4},
file = {::},
issn = {18652034},
journal = {Computer Science - Research and Development},
keywords = {Distributed deadlock detection,Partitioned global address space,Run-time error detection,UPC,errors-only,performance},
mendeley-tags = {errors-only,performance},
number = {2-3},
pages = {203--209},
title = {{UPC-CHECK: A scalable tool for detecting run-time errors in Unified Parallel C}},
volume = {28},
year = {2013}
}

@article{TIRRONEN2015,
abstract = {This article presents an overview of student difficulties in an introductory functional programming (FP) course taught in Haskell. The motivation for this study stems from our belief that many student difficulties can be alleviated by understanding the underlying causes of errors and by modifying the educational approach and, possibly, the teaching language accordingly. We analyze students' exercise submissions and categorize student errors according to compiler error messages and then manually according to the observed underlying cause. Our study complements earlier studies on the topic by applying computer and manual analysis while focusing on providing descriptive statistics of difficulties specific to FP languages. We conclude that the majority of student errors, regardless of cause, are reported by three different compiler error messages that are not well understood by students. In addition, syntactic features, such as precedence, the syntax of function application, and deeply nested statements, cause difficulties throughout the course.},
author = {TIRRONEN, VILLE and UUSI-M{\"{A}}KEL{\"{A}}, SAMUEL and ISOM{\"{O}}TT{\"{O}}NEN, VILLE},
doi = {10.1017/s0956796815000179},
file = {::},
issn = {0956-7968},
journal = {Journal of Functional Programming},
keywords = {difficulties,empirical,justification},
mendeley-tags = {difficulties,empirical,justification},
title = {{Understanding beginners' mistakes with Haskell}},
volume = {25},
year = {2015}
}
@article{ernst2017natural,
abstract = {A powerful, but limited, way to view software is as source code alone. Treating a program as a sequence of instructions enables it to be formalized and makes it amenable to mathematical techniques such as abstract interpretation and model checking. A program consists of much more than a sequence of instructions. Developers make use of test cases, documentation, variable names, program structure, the version control repository, and more. I argue that it is time to take the blinders off of software analysis tools: tools should use all these artifacts to deduce more powerful and useful information about the program. Researchers are beginning to make progress towards this vision. This paper gives, as examples, four results that find bugs and generate code by applying natural language processing techniques to software artifacts. The four techniques use as input error messages, variable names, procedure documentation, and user questions. They use four different NLP techniques: document similarity, word semantics, parse trees, and neural networks. The initial results suggest that this is a promising avenue for future work. 1 Introduction What is software? A reasonable definition-and the one most often adopted by the programming language community-is: a sequence of instructions that perform some task. This definition accommodates the programmer's view of source code and the machine instructions that the CPU executes. Furthermore, this definition enables formalisms: the execution model of the machine, and the meaning of every instruction, can be mathematically defined, for example via denotational semantics or operational semantics. By combining the meanings of each instruction, the meaning of a program can be induced. This perspective leads to powerful static analyses, such as symbolic analysis, abstract interpretation, dataflow analysis, type checking, and model checking. Equally important and challenging theoretically-and probably more important in practice-are dynamic analyses that run the program and observe its behavior. These are at the heart of techniques such as testing, error detection and localization, debugging, profiling, tracing, and optimization. Despite the successes of viewing a program as a sequence of instructions-essentially, of treating a program as no more than an AST (abstract syntax tree)-this view is limited and foreign to working programmers, who should be the focus of research in programming.},
author = {Ernst, Michael D.},
doi = {10.4230/LIPIcs.SNAPL.2017.4},
file = {::},
isbn = {9783959770323},
issn = {18688969},
journal = {2nd Summit on Advances in Programming Languages (SNAPL'17)},
keywords = {anecdotal,lipics,phrases natural language,processing,program analysis,snapl,software development,tool},
mendeley-tags = {anecdotal,tool},
number = {4},
pages = {1--14},
title = {{Natural language is a programming language: Applying natural language processing to software development}},
url = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-85019618182&doi=10.4230%2FLIPIcs.SNAPL.2017.4&partnerID=40&md5=c9b1d770c6dfbd1b47d735f637714abc},
volume = {71},
year = {2017}
}
@article{Epstein2007a,
author = {Epstein, David},
doi = {10.1145/274104.274110},
file = {::},
issn = {10617264},
journal = {ACM SIGPLAN Fortran Forum},
keywords = {difficulties,justification},
mendeley-tags = {difficulties,justification},
number = {3},
pages = {12--16},
title = {{Error messages in F, take two}},
volume = {16},
year = {2007}
}
@article{Gimpel2014,
abstract = {The article examines some fascinating insights into the growth, technology, and impact of the very widely used static analyzer PC-lint in the never-ending battle against the bug. Lint was a well-known utility in the Unix world. It was written by Steve Johnson, who also wrote the portable C compiler and invented Yet Another Compiler Compiler (YACC). Some programmers do not like the concept of a separate lint tool, having the mindset that the compiler should do that task. Most compilers allow the programmer to suppress messages by warning level, but this was a rather crude tool. In the first version, one could suppress by individual error message such as -e473 to suppress message 473. This is in sharp contrast to the typical compiler or lint diagnostic, where it is sufficient to merely point to the code that triggered the complaint. But when the complaint has to do with values that originate in code locations many lines from where the problem is discovered, it is vitally important to reveal as much information as possible.},
author = {Gimpel, James},
doi = {10.1109/ms.2014.13},
file = {::},
issn = {0740-7459},
journal = {IEEE Software},
keywords = {gen-lit},
mendeley-tags = {gen-lit},
title = {{Software That Checks Software: The Impact of PC-lint}},
year = {2014}
}
@article{Liu2019,
abstract = {Students learning to program often rely on feedback from the compiler and from instructor-provided test cases to help them identify errors in their code. This feedback focuses on functional correctness, and the output, which is often phrased in technical language, may be difficult to for novices to understand or effectively use. Static analyses may be effective as a complementary aid, as they can highlight common errors that may be potential sources of problems. In this paper, we introduce PyTA, a wrapper for pylint that provides custom checks for common novice errors as well as improved messages to help students fix the errors that are found. We report on our experience integrating PyTA into an existing online system used to deliver programming exercises to CS1 students and evaluate it by comparing exercise submissions collected from the integrated system to previously collected data. This analysis demonstrates that, for students who chose to read the PyTA output, we observed a decrease in time to solve errors, occurrences of repeated errors, and submissions to complete a programming problem. This suggests that PyTA, and static analyses in general, may help students identify functional issues in their code not highlighted by compiler feedback and that static analysis output may help students more quickly identify debug their code.},
author = {Liu, David and Petersen, Andrew},
doi = {10.1145/3287324.3287503},
file = {::},
isbn = {9781450358903},
keywords = {difficulties,empirical,enhancement,performance},
mendeley-tags = {difficulties,empirical,enhancement,performance},
pages = {666--671},
title = {{Static Analyses in Python Programming Courses}},
year = {2019}
}
@article{Molich1990Improving,
 abstract = {A survey of seventy-seven highly motivated industrial designers and programmers indicates that the identification of specific, potential problems in a human-computer dialogue design is difficult.},
 author = {Molich, Rolf and Nielsen, Jakob},
 title = {Improving a Human-computer Dialogue},
 journal = {Commun. ACM},
 issue_date = {March 1990},
 volume = {33},
 number = {3},
 month = mar,
 year = {1990},
 issn = {0001-0782},
 pages = {338--348},
 url = {http://doi.acm.org/10.1145/77481.77486},
 doi = {10.1145/77481.77486},
 acmid = {77486},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Consistency, dialogue design, error messages, feedback, guidelines, industrial designers, industrial programmers, interaction accelerators, iterative design, memory load, prevention of errors, user exits, user interfaces},
}

@article{Gissurarson2018Suggesting,
abstract = {Type systems allow programmers to communicate a partial specification of their program to the compiler using types, which can then be used to check that the implementation matches the specification. But can the types be used to aid programmers during development? In this experience report I describe the design and implementation of my lightweight and practical extension to the typed-holes of GHC that improves user experience by adding a list of valid hole fits and refinement hole fits to the error message of typed-holes. By leveraging the type checker, these fits are selected from identifiers in scope such that if the hole is substituted with a valid hole fit, the resulting expression is guaranteed to type check},
author = {Gissurarson, Matth{\'{i}}as P{\'{a}}ll},
doi = {10.1145/3299711.3242760},
file = {::},
isbn = {9781450358354},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {enhancement,suggesting valid hole fits,suggestions,typed-holes,valid hole fits},
mendeley-tags = {enhancement},
number = {7},
pages = {179--185},
title = {{Suggesting valid hole fits for typed-holes (experience report)}},
volume = {53},
year = {2018}
}
@article{Xia2017,
abstract = {{\textcopyright} 2017, Springer Science+Business Media New York. Developers commonly make use of a web search engine such as Google to locate online resources to improve their productivity. A better understanding of what developers search for could help us understand their behaviors and the problems that they meet during the software development process. Unfortunately, we have a limited understanding of what developers frequently search for and of the search tasks that they often find challenging. To address this gap, we collected search queries from 60 developers, surveyed 235 software engineers from more than 21 countries across five continents. In particular, we asked our survey participants to rate the frequency and difficulty of 34 search tasks which are grouped along the following seven dimensions: general search, debugging and bug fixing, programming, third party code reuse, tools, database, and testing. We find that searching for explanations for unknown terminologies, explanations for exceptions/error messages (e.g., HTTP 404), reusable code snippets, solutions to common programming bugs, and suitable third-party libraries/services are the most frequent search tasks that developers perform, while searching for solutions to performance bugs, solutions to multi-threading bugs, public datasets to test newly developed algorithms or systems, reusable code snippets, best industrial practices, database optimization solutions, solutions to security bugs, and solutions to software configuration bugs are the most difficult search tasks that developers consider. Our study sheds light as to why practitioners often perform some of these tasks and why they find some of them to be challenging. We also discuss the implications of our findings to future research in several research areas, e.g., code search engines, domain-specific search engines, and automated generation and refinement of search queries.},
author = {Xia, Xin and Bao, Lingfeng and Lo, David and Kochhar, Pavneet Singh and Hassan, Ahmed E. and Xing, Zhenchang},
doi = {10.1007/s10664-017-9514-4},
file = {::},
issn = {15737616},
journal = {Empirical Software Engineering},
keywords = {Empirical study,Search task,Survey,Understanding,justification},
mendeley-tags = {justification},
number = {6},
pages = {3149--3185},
title = {{What do developers search for on the web?}},
volume = {22},
year = {2017}
}
@article{Carlisle1998,
abstract = {We have recently transitioned the programming language in our Introduction to Computer Science course at the U.S. Air Force Academy from Pascal to Ada. Providing an intuitive and straightforward Integrated Development Environment (IDE) for Ada that is suitable for freshman use has been one of our greatest challenges. Although we recognize that a number of Ada IDEs are available, these IDEs do not seem to be designed for beginning programmers. Most of them are either too expensive for students to purchase or are designed for development of large programming projects, carrying significant overhead for the small programs we require in our freshman course. Error messages tend to be fairly complicated, assuming a relatively thorough understanding of the language syntax and semantics. Finally, both commercial and free IDEs can have extensive lead time for bug fix development and are not readily extensible.These concerns led us to develop a Windows 95 Ada IDE that is free to the students, contains the appropriate level of functionality for our freshman course, has a minimal, lead time for bug fix development (since we maintain the code in-house), and can be easily extended to contain additional help for the students. Because we implemented this environment in Ada we can also demonstrate to our students that Ada is applicable to real, large projects, and its usefulness is not limited to the small programs they create in the freshman course. This paper describes our preliminary experience with this environment.The next section briefly describes the IDE and the third section lists a number of issues we have faced trying to interface to Windows 95. The fourth and fifth sections discuss student and faculty reaction to and use of the environment. The final section presents our conclusions and our plans for future enhancements to the IDE.},
author = {Carlisle, Martin C. and Chamillard, A. T.},
file = {::},
journal = {Ada Letters},
keywords = {difficulties,hci},
mendeley-tags = {difficulties,hci},
number = {2},
pages = {42--52},
title = {{AdaGIDE: A Friendly Introductory Programming Environment for a Freshman Computer Science Course}},
volume = {XVIII},
year = {1998}
}
@article{wu2017learning,
 abstract = {Type inference is convenient by allowing programmers to elide type annotations, but this comes at the cost of often generating very confusing and opaque type error messages that are of little help to fix type errors. Though there have been many successful attempts at making type error messages better in the past thirty years, many classes of errors are still difficult to fix. In particular, current approaches still generate imprecise and uninformative error messages for type errors arising from errors in grouping constructs like parentheses and brackets. Worse, a recent study shows that these errors usually take more than 10 steps to fix and occur quite frequently (around 45\% to 60\% of all type errors) in programs written by students learning functional programming. We call this class of errors, nonstructural errors. We solve this problem by developing Learnskell, a type error debugger that uses machine learning to help diagnose and deliver high quality error messages, for programs that contain nonstructural errors. While previous approaches usually report type errors on typing constraints or on the type level, Learnskell generates suggestions on the expression level. We have performed an evaluation on more than 1,500 type errors, and the result shows that Learnskell is quite precise. It can correctly capture 86\% of all nonstructural errors and locate the error cause with a precision of 63\%/87\% with the first 1/3 messages, respectively. This is several times more than the precision of state-of-the-art compilers and debuggers. We have also studied the performance of Learnskell and found out that it scales to large programs.},
 mendeley-tags = {enhancement,technical,tool},
 author = {Wu, Baijun and Campora III, John Peter and Chen, Sheng},
 title = {Learning User Friendly Type-error Messages},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {October 2017},
 volume = {1},
 number = {OOPSLA},
 month = oct,
 year = {2017},
 issn = {2475-1421},
 pages = {106:1--106:29},
 articleno = {106},
 numpages = {29},
 url = {http://doi.acm.org/10.1145/3133930},
 doi = {10.1145/3133930},
 acmid = {3133930},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Type error debugging, concrete messages, machine learning, structure- changing errors},
}

@inproceedings{pavlinovic2015practical,
abstract = {Compilers for statically typed functional programming languages are notorious for generating confusing type error messages. When the compiler detects a type error, it typically reports the program location where the type checking failed as the source of the error. Since other error sources are not even considered, the actual root cause is often missed. A more adequate approach is to consider all possible error sources and report the most useful one subject to some usefulness criterion. In our previous work, we showed that this approach can be formulated as an optimization problem related to satisfiability modulo theories (SMT). This formulation cleanly separates the heuristic nature of usefulness criteria from the underlying search problem. Unfortunately, algorithms that search for an optimal error source cannot directly use principal types which are crucial for dealing with the exponential-time complexity of the decision problem of polymorphic type checking. In this paper, we present a new algorithm that efficiently finds an optimal error source in a given ill-typed program. Our algorithm uses an improved SMT encoding to cope with the high complexity of polymorphic typing by iteratively expanding the typing constraints from which principal types are derived. The algorithm preserves the clean separation between the heuristics and the actual search. We have implemented our algorithm for OCaml. In our experimental evaluation, we found that the algorithm reduces the running times for optimal type error localization from minutes to seconds and scales better than previous localization algorithms.},
address = {Vancouver, BC, Canada},
author = {Pavlinovic, Zvonimir and King, Tim and Wies, Thomas},
booktitle = {ICFP 2015 Proceedings of the 20th ACM SIGPLAN International Conference on Functional Programming},
doi = {10.1145/2858949.2784765},
file = {::},
isbn = {9781450336697},
issn = {03621340},
keywords = {Polymorphic Types,Satisfiability Modulo Theories,Type Error Localization,technical},
mendeley-tags = {technical},
number = {9},
pages = {412--423},
publisher = {ACM},
title = {{Practical SMT-based type error localization}},
volume = {50},
year = {2015}
}
@article{Yoo2015C-languaage,
abstract = {This study describes a prototype system that creates a rulebase by capturing compiler error messages and uses them as a means for building a decision tree. The rulebase is then used to assist novice programmers with cryptic C-language compiler error messages. The system, called the C-Compiler Error Message Interpreter (C-CEMI), generates a data file which is used by an inductive learning system known as C4.5 to discover the rules. The rulebase is incorporated into a dynamic C-language grading system called Ceilidh.},
author = {Yoo, Jungsoon and Smith, Doug and Yoo, Sung and Cheatham, Thomas},
doi = {10.1145/2817460.2817469},
file = {::},
journal = {ACM-SE 35 Proceedings of the 35th Annual Southeast Regional Conference},
keywords = {enhancement},
mendeley-tags = {enhancement},
pages = {36--40},
title = {{C-language syntax tutoring using machine learning techniques}},
year = {1997}
}
@article{loginov2001debugging,
author = {Loginov, A. and Yong, S. H. and Horwitz, S. and Reps, T.},
file = {::},
keywords = {technical},
mendeley-tags = {technical},
pages = {217--232},
title = {{Debugging via Run-Time Type Checking}},
year = {2001}
}
@article{Radosevic2011,
abstract = {Tutor is part of a C++ learning programming interface named Verificator. It explains to students the causes of syntactic and certain logical incorrectness in their programs. In order to be helpful, tutor messages need to be more intuitive and clear in relation to the existing compiler error messages and warnings. The research presented in this paper analyses the frequencies of different kinds of error-related messages in students ' programs, as well as their mutual correlations. It has been shown that tutor messages are more strongly related to error messages than to standard compiler warnings.},
author = {Radosevic, Danijel and Orehovacki, Tihomir},
file = {::},
isbn = {978-953-7138-21-9},
issn = {1330-1012},
journal = {Proceedings of the ITI 2011, 33rd International Conference on Information Technology Interfaces},
keywords = {Errors and Warnings Analysis,Teaching Programming,Tutor,Verificator,difficulties,empirical},
mendeley-tags = {difficulties,empirical},
number = {June 2011},
pages = {325--330},
title = {{An analysis of novice compilation behavior using Verificator}},
year = {2011}
}
@article{jenkins2018spine-local,
abstract = {We present spine-local type inference, a partial type inference system for inferring omitted type annotations for System F terms based on local type inference. Local type inference relies on bidirectional inference rules to propagate type information into and out of adjacent nodes of the AST and restricts type-argument inference to occur only within a single node. Spine-local inference relaxes the restriction on type-argument inference by allowing it to occur only within an application spine and improves upon it by using contextual type-argument inference. As our goal is to explore the design space of local type inference, we show that, relative to other variants, spine-local type inference enables desirable features such as first-class curried applications, partial type applications, and the ability to infer types for some terms not otherwise possible. Our approach enjoys usual properties of a bidirectional system of having a specification for our inference algorithm and predictable requirements for typing annotations, and in particular maintains some the advantages of local type inference such as a relatively simple implementation and a tendency to produce good-quality error messages when type inference fails.},
archivePrefix = {arXiv},
arxivId = {1805.10383},
author = {Jenkins, Christopher and Stump, Aaron},
eprint = {1805.10383},
file = {::},
isbn = {9781450371438},
keywords = {bidirectional typechecking,polymorphism,spine-local type inference,stump,technical,type err,type errors},
mendeley-tags = {technical},
title = {{Spine-local Type Inference}},
url = {http://arxiv.org/abs/1805.10383},
year = {2018}
}
@inproceedings{alikhashashneh2019using,
author = {Alikhashashneh, Enas A. and Raje, Rajeev R. and Hill, James H.},
booktitle = {Proceedings of IEEE/ACS International Conference on Computer Systems and Applications, AICCSA},
doi = {10.1109/AICCSA.2018.8612819},
file = {::},
isbn = {9781538691205},
issn = {21615330},
keywords = {Feature Selection,K-Nearest Neighbor,Machine Learning,Random Forests,Software Engineering Metrics,Static Code Analysis,Support Vector Machine,errors-only,technical},
mendeley-tags = {errors-only,technical},
pages = {1--8},
publisher = {IEEE},
title = {{Using Machine Learning Techniques to Classify and Predict Static Code Analysis Tool Warnings}},
volume = {2018-Novem},
year = {2019}
}
@article{chen2017exploting,
abstract = {Producing precise and helpful type error messages has been a challenge for the implementations of functional programming languages for over 3 decades now. Many different approaches and methods have been tried to solve this thorny problem, but current type-error reporting tools still suffer from a lack of precision in many cases. Based on the observation that different approaches work well in different situations, we have studied the question of whether a combination of tools that exploits their diversity can lead to improved accuracy. Specifically, we have studied Helium, a Haskell implementation particularly aimed at producing good type error messages, and Lazy Typing, an approach developed previously by us to address the premature-error-commitment problem in type checkers. By analyzing the respective strengths and weaknesses of the two approaches we were able to identify a strategy to combine both tools that could markedly improve the accuracy of reported errors. Specifically, we report an evaluation of 1069 unique ill-typed programs out of a total of 11,256 Haskell programs that reveals that this combination strategy enjoys a correctness rate of 82%, which is an improvement of 25%/20% compared to using Lazy Typing/Helium alone. In addition to describing this particular case study, we will also report insights we gained into the combination of error-reporting tools in general.},
author = {Chen, Sheng and Erwig, Martin and Smeltzer, Karl},
doi = {10.1016/j.jvlc.2016.07.001},
file = {::},
issn = {1045926X},
journal = {Journal of Visual Languages and Computing},
keywords = {Tool combining,Type-error diagnosing,difficulties,empirical,justification,technical},
mendeley-tags = {difficulties,empirical,justification,technical},
pages = {10--21},
publisher = {Elsevier Ltd},
title = {{Exploiting diversity in type checkers for better error messages}},
url = {http://dx.doi.org/10.1016/j.jvlc.2016.07.001},
volume = {39},
year = {2017}
}
@inproceedings{schilling2012constraint,
author = {Schilling, Thomas},
booktitle = {International Symposium on Trends in Functional Programming},
doi = {10.1007/978-3-642-32037-8_1},
file = {::},
keywords = {technical,tool},
mendeley-tags = {technical,tool},
pages = {1--16},
title = {{Constraint-Free Type Error Slicing}},
year = {2012}
}
@incollection{Nagao2003,
abstract = {The programming is one of the most important factors in the education of computer literacy. However, in the initial learning of the programming, many students often have faced simple problems, like syntax-error by careless or miss typing. We propose the support system for the C language programming on the UNIX by using agent technology. This system monitors the error message from the compiler. It analyzes, rewrites the acquired message, and reports to the student and the teacher. The teacher can improve the teaching way by finding category of error. The student customizes these messages, and they can use the suitable one at each level. Moreover, these messages send to other students by communication line of each agent. Students can select the most preferable message from the collection of the agent. In the preliminary experiment; the improvement of efficiency to the complication work was confirmed.},
author = {Nagao, Kazuhiko and Ishii, Naohiro},
booktitle = {International Conference on Knowledge-Based and Intelligent Information and Engineering Systems},
doi = {10.1007/978-3-540-45226-3_74},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Nagao, Ishii - 2003 - Evaluation of Learning Support System for Agent-Based C Programming.pdf:pdf},
keywords = {empirical,enhancement,performance},
mendeley-tags = {empirical,enhancement,performance},
pages = {540--546},
title = {{Evaluation of Learning Support System for Agent-Based C Programming}},
url = {http://link.springer.com/10.1007/978-3-540-45226-3_74},
year = {2003}
}

@inproceedings{gupta2017deepfix,
 abstract = {The problem of automatically fixing programming errors is a very active research topic in software engineering. This is a challenging problem as fixing even a single error may require analysis of the entire program. In practice, a number of errors arise due to programmer's inexperience with the programming language or lack of attention to detail. We call these common programming errors. These are analogous to grammatical errors in natural languages. Compilers detect such errors, but their error messages are usually inaccurate. In this work, we present an end-to-end solution, called DeepFix, that can fix multiple such errors in a program without relying on any external tool to locate or fix them. At the heart of DeepFix is a multi-layered sequence-to-sequence neural network with attention which is trained to predict erroneous program locations along with the required correct statements. On a set of 6971 erroneous C programs written by students for 93 programming tasks, DeepFix could fix 1881 (27\%) programs completely and 1338 (19\%) programs partially.},
 mendeley-tags = {enhancement},
 author = {Gupta, Rahul and Pal, Soham and Kanade, Aditya and Shevade, Shirish},
 title = {DeepFix: Fixing Common C Language Errors by Deep Learning},
 booktitle = {Proceedings of the Thirty-First AAAI Conference on Artificial Intelligence},
 series = {AAAI'17},
 year = {2017},
 location = {San Francisco, California, USA},
 pages = {1345--1351},
 url = {http://dl.acm.org/citation.cfm?id=3298239.3298436},
 acmid = {3298436},
 publisher = {AAAI Press},
}

@inproceedings{hage2006heuristics,
 abstract = {The subject of this paper is functional program transformation in the so-called point-free style. By this we mean first translating programs to a form consisting only of categorically-inspired combinators, algebraic\n data types defined as fixed points of functors, and implicit recursion through the use of type-parameterized recursion patterns.\n This form is appropriate for reasoning about programs equationally, but difficult to actually use in practice for programming.\n In this paper we present a collection of libraries and tools developed at Minho with the aim of supporting the automatic conversion\n of programs to point-free (embedded in Haskell), their manipulation and rule-driven simplification, and the (limited) automatic application of fusion for program transformation.},
 author = {Hage, Jurriaan and Heeren Bastiaan},
 booktitle = {18th International Conference on Implementation and Application of Functional Languages},
 SERIES = {IFL '06},
 file = {::},
 keywords = {enhancement,technical},
 mendeley-tags = {enhancement,technical},
 pages = {199--216},
 title = {{Heuristics for Type Error Discovery and Recovery}},
 url = {https://link.springer.com/chapter/10.1007/978-3-540-74130-5_12},
 year = {2006},
 abstract="Type error messages that are reported for incorrect functional programs can be difficult to understand. The reason for this is that most type inference algorithms proceed in a mechanical, syntax-directed way, and are unaware of inference techniques used by experts to explain type inconsistencies. We formulate type inference as a constraint problem, and analyze the collected constraints to improve the error messages (and, as a result, programming efficiency). A special data structure, the type graph, is used to detect global properties of a program, and furthermore enables us to uniformly describe a large collection of heuristics which embed expert knowledge in explaining type errors. Some of these also suggest corrections to the programmer. Our work has been fully implemented and is used in practical situations, showing that it scales up well. We include a number of statistics from actual use of the compiler showing us the frequency with which heuristics are used, and the kind and number of suggested corrections.",
 isbn="978-3-540-74130-5"
}

@inproceedings{Chen2014,
 abstract = {Producing precise and helpful type error messages has been a challenge for the implementations of functional programming languages for over 3 decades now. Many different approaches and methods have been tried to solve this thorny problem, but current type-error reporting tools still suffer from a lack of precision in many cases. Based on the rather obvious observation that different approaches work well in different situations, we have studied the question of whether a combination of tools that exploits their diversity can lead to improved accuracy. Specifically, we have studied Helium, a Haskell implementation particularly aimed at producing good type error messages, and Lazy Typing, an approach developed previously by us to address the premature-error-commitment problem in type checkers. By analyzing the respective strengths and weaknesses of the two approaches we were able to identify a strategy to combine both tools that could markedly improve the accuracy of reported errors. Specifically, we report an evaluation of 1069 unique ill-typed programs out of a total of 11256 Haskell programs that reveals that this combination strategy enjoys a correctness rate of 79\%, which is an improvement of 22\%/17\% compared to using Lazy Typing/Helium alone. In addition to describing this particular case study, we will also report insights we gained into the combination of error-reporting tools in general. {\textcopyright} 2014 IEEE.},
 author = {Chen, Sheng and Erwig, Martin and Smeltzer, Karl},
 booktitle = {Proceedings of IEEE Symposium on Visual Languages and Human-Centric Computing},
 series = {VLHCC '14},
 doi = {10.1109/VLHCC.2014.6883038},
 file = {::},
 isbn = {9781479940356},
 issn = {19436106},
 keywords = {empirical,enhancement,pre-guidelines},
 mendeley-tags = {empirical,enhancement,pre-guidelines},
 title = {{Let's hear both sides: On combining type-error reporting tools}},
 year = {2014}
}

@article{rahli2015skalpel,
 abstract = {Compilers for languages with type inference algorithms produce confusing type error messages and give a single error location which is often far away from the real location of the type error. Attempts at solving this problem 1) fail to include the multiple program points which make up the type error, 2) often report tree fragments which do not correspond to any place in the user program, and 3) give incorrect type information/diagnosis which can be highly confusing. We present Skalpel, a type error slicing tool which solves these problems by giving the programmer all and only the information involved with a type error to significantly aid in diagnosis and repair of type errors. Skalpel consists of a sophisticated new constraint generator which is linear in size and a new constraint solver which is terminating.},
 author = {Rahli, Vincent and Wells, Joe and Pirie, John and Kamareddine, Fairouz},
 doi = {10.1016/j.entcs.2015.04.012},
 file = {::},
 issn = {15710661},
 journal = {Electronic Notes in Theoretical Computer Science},
 keywords = {Automated Error Diagnosis, Automated Type Inference, Improved Error Reports, pre-guidelines,technical},
 mendeley-tags = {pre-guidelines,technical},
 pages = {197--213},
 publisher = {Elsevier B.V.},
 title = {{Skalpel: A Type Error Slicer for Standard ML}},
 url = {http://dx.doi.org/10.1016/j.entcs.2015.04.012},
 volume = {312},
 year = {2015}
}

@inproceedings{Turner2014Looking,
 abstract = {Looking Glass (https://github.com/sturner84/LookingGlass) is a library designed to support the testing of students' C++ code through reflection. Instructors can design tests that compile even if there are mismatches between the instructor's and student's code (like misspelled function names or parameters that do not have the expected types). Using the automatically generated metadata, instructors can search for and call functions or methods in the student code, including the main function, while providing feedback (rather than a compile error) if the required code is not found. Although not suitable for all C++ programs, Looking Glass was designed to support instructors in introductory and intermediate classes and to be transparent to the students.},
 mendeley-tags = {enhancement},
 author = {Turner, Scott},
 title = {Looking Glass: A C++ Library for Testing Student Programs Through Reflection (Abstract Only)},
 booktitle = {Proceedings of the 45th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '14},
 year = {2014},
 isbn = {978-1-4503-2605-6},
 location = {Atlanta, Georgia, USA},
 pages = {721--722},
 url = {http://doi.acm.org/10.1145/2538862.2544299},
 doi = {10.1145/2538862.2544299},
 acmid = {2544299},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {C++, instructor tests, reflection, unit testing},
}

@inproceedings{heeran2003scripting,
 mendeley-tags = {pre-guidelines,technical},
 author = {Heeren, Bastiaan and Hage, Jurriaan and Swierstra, S. Doaitse},
 title = {Scripting the Type Inference Process},
 booktitle = {Proceedings of the 8th ACM SIGPLAN International Conference on Functional Programming},
 series = {ICFP '03},
 year = {2003},
 isbn = {1-58113-756-7},
 location = {Uppsala, Sweden},
 pages = {3--13},
 url = {http://doi.acm.org/10.1145/944705.944707},
 doi = {10.1145/944705.944707},
 acmid = {944707},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {constraints, directives, domain-specific programming, type errors, type inference},
}

@techreport{hanus2016parser,
abstract = {A programming language is usually taught by starting with a small kernel that is continuously extended to the full set of language features. Unfortunately, the existence of advanced language features might confuse students if they accidentally use them and get incomprehensible error messages. To avoid these problems, one should group the language features into different levels so that beginners start with a simple level and advance to higher levels with more features if they become more experienced. In order to support such a concept for arbitrary programming languages, we present a parser generator system, called Levels, for level-based programming languages. With a level-based language, one can stepwise increase the language level in order to match the experience of the students. Furthermore, one can implement level-specific semantic analyses in order to provide comprehensible error messages. Our Levels system generates level-specific parsers from a unified syntax description and provides an infrastructure to implement level-specific semantic analyses as well as program editors to develop level-specific programs.},
author = {Hanus, Michael and Tikovsky, Jan Rasmus},
file = {::},
keywords = {pedagogy},
mendeley-tags = {pedagogy},
title = {{A Parser Generator System for Level-based Programming Languages 1}},
url = {http://www.haskell.org/happy/},
year = {2016}
}
@article{Jiang2016Data,
abstract = {In this paper, we take a new look at the problem of analyzing course evaluations. We examine ten years of undergraduate course evaluations from a large Engineering faculty. To the best of our knowledge, our data set is an order of magnitude larger than those used by previous work on this topic, at over 250,000 student evaluations of over 5,000 courses taught by over 2,000 distinct instructors. We build linear regression models to study the factors affecting course and instructor appraisals, and we perform a novel information-theoretic study to determine when some classmates rate a course and/or its instructor highly but others poorly. In addition to confirming the results of previous regression studies, we report a number of new observations that can help improve teaching and course quality.},
author = {Jiang, Yuheng Helen and Javaad, Sohail Syed and Golab, Lukasz},
doi = {10.15388/infedu.2016.05},
file = {::},
issn = {16485831},
journal = {Informatics in Education},
keywords = {Course evaluation,Entropy,Regression},
number = {3},
pages = {85--102},
title = {{Data mining of undergraduate course evaluations}},
volume = {15},
year = {2016}
}

@inproceedings{elboustani2010corrective,
 mendeley-tags = {enhancement,pre-guidelines,technical},
 author = {El Boustani, Nabil and Hage, Jurriaan},
 title = {Corrective Hints for Type Incorrect Generic Java Programs},
 booktitle = {Proceedings of the 2010 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
 series = {PEPM '10},
 year = {2010},
 isbn = {978-1-60558-727-1},
 location = {Madrid, Spain},
 pages = {5--14},
 url = {http://doi.acm.org/10.1145/1706356.1706360},
 doi = {10.1145/1706356.1706360},
 acmid = {1706360},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compilers, error correcting, error reporting, heuristics, java generics, type checking},
}

@article{ramsey2005eliminating,
author = {Ramsey, N.},
doi = {10.1093/comjnl/42.5.360},
file = {::},
issn = {0010-4620},
journal = {The Computer Journal},
keywords = {technical},
mendeley-tags = {technical},
number = {5},
pages = {360--372},
title = {{Eliminating Spurious Error Messages Using Exceptions, Polymorphism, and Higher-Order Functions}},
volume = {42},
year = {2005}
}
@inproceedings{huck2015checking,
abstract = {Operator overloading allows the semantic extension of existing code without the need for sweeping code changes. For example, automatic differentiation tools in C++ commonly use this feature to enhance the code with additional derivative computation. To this end, a floating point data type is changed to a complex user-defined type. While conceptually straightforward, this type change often leads to compilation errors that can be tedious to decipher and resolve. This is due to the fact that the built-in floating point types in C++ are treated differently than user-defined types, and code constructs that are legal for floating point types can be a violation of the C++ standard for complex user-defined types. We identify and classify such problematic code constructs and suggest how the code can be changed to avoid these errors, while still allowing the use of operator overloading. To automatically flag such occurrences, we developed a Clang-based tool for the static analysis of C++ code based on our assessment of constructs problematic in operator overloading for numeric types. It automatically finds instances of problematic code locations and prints Lint-like warning messages. To showcase the relevance of this topic and the usefulness of our tool, we consider the basic routines of the OpenFOAM CFD software package, consisting of 1,476 C++ source and header files, for a total of over 150,000 lines of code. Altogether, we found 74 distinct occurrences of problematic code constructs in 21 files. As some of these files are included in over 400 different locations in the OpenFOAM base, errors in these files create a torrent of error messages that often are difficult to comprehend. In summary, the classification of problematic instances aids developers in writing numerical code that is fit for operator overloading and the tool helps programmers that augment legacy code in spotting problematic code constructs.},
author = {Huck, Alexander and Bischof, Christian and Utke, Jean},
booktitle = {5th International Working Conference on Source Code Analysis and Manipulation, SCAM 2015 - Proceedings},
doi = {10.1109/SCAM.2015.7335405},
file = {::},
isbn = {9781467375290},
keywords = {technical,tool},
mendeley-tags = {technical,tool},
pages = {91--100},
title = {{Checking C++ codes for compatibility with operator overloading}},
year = {2015}
}
@article{Allwood1990,
abstract = {In this study an analysis was made of novices debugging their own Pascal programs. Eight novices verbalized their thoughts aloud while attempting to solve a programming task. Novices' debugging is seen as taking place in negative evaluation episodes (henceforth: evaluation episodes). During the three hour programming session, the novices spent 51% of the time in evaluation episodes. This percentage would presumably have been higher if the subjects had been given more time for the session. Evaluation episodes were found to be triggered in four different contexts: Reaction to an error message (67% of the total time spent in any evaluation episode), Reaction to the resulting value of a test run (23%), Hint from the experimenter (4%) and Other (6%). When related to results presented by Gray and Anderson (1987), our results indicate that novices perform the substantial part of their debugging after they have compiled the program, or part of it, for the first time. Despite the information given in the computer's error messages, the percentage of errors eliminated in episodes triggered by such messages was not higher than could be expected from the time spent in these episodes. Our results indicate that the importance of activity oriented towards understanding one's program during debugging depends on: (1) whether the error elicits an error message from the computer or not; and (2) the general programming strategy used by the subject. {\textcopyright} 1990 Academic Press Limited.},
author = {Allwood, Carl Martin and Bj{\"{o}}rhag, Carl Gustav},
doi = {10.1016/S0020-7373(05)80070-7},
file = {::},
issn = {00207373},
journal = {International Journal of Man-Machine Studies},
keywords = {difficulties,empirical},
mendeley-tags = {difficulties,empirical},
title = {{Novices' debugging when programming in Pascal}},
year = {1990}
}
@inproceedings{Nagao2002,
abstract = {Programming is one of the most important factors in the education of computer literacy. However, in the initial learning of programming, many students often have faced a simple problem, like syntax-errors by carelessness or mis-typing. Therefore, they feel that programming is too hard. The most important problem is the student can't take advantage of the error messages displayed by the computer. These messages are difficult to understand for beginners because the message only indicates a syntactic error and where it occurred. The authors propose a support system for C language programming on UNIX by using agent technology. This system monitors the error messages from the compiler. It analyzes, rewrites the acquired message, and reports to the student and the teacher on the network. The teacher can improve the teaching method by finding the category of error. The student customizes these messages, and they can use the suitable one at each level. Moreover, these messages are sent to other students by the communication line of each agent. Consequently, many students are able to use these useful messages; they can select the most preferable message from the collection of the agent. The authors executed a preliminary experiment and the improvement of efficiency to the complication work was confirmed.},
author = {Nagao, K. and Ishii, N.},
booktitle = {International Conference on Computers in Education, 2002. Proceedings.},
doi = {10.1109/CIE.2002.1186058},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Nagao, Ishii - 2002 - A concept of user agent for user interface of C compiler.pdf:pdf},
isbn = {0-7695-1509-6},
keywords = {enhancement,pedagogy},
mendeley-tags = {enhancement,pedagogy},
pages = {722--726},
publisher = {IEEE Comput. Soc},
title = {{A concept of user agent for user interface of C compiler}},
url = {http://ieeexplore.ieee.org/document/1186058/},
volume = {1},
year = {2002}
}
@article{Bernot1986Abstract,
abstract = {In this paper, a new semantics for exception handling in algebraic specifications is provided. Our formalism allows all forms of exception and error handling (several error messages, implict error propagation rule, exception recovery policy), while preserving the existence of initial models. The main concepts of our approach are: the distinction between exception and error, and the introduction of exception labelling allowing to formalize various error messages. This formalism allows use of congruences in a similar manner as in the classical abstract data type theory. Moreover, we show how a functorial semantics of enrichment can be carried over to our framework, and we show how hierarchical consistency and sufficient completeness can be redefined. Then, we briefly sketch out how abstract implementations can be extended in order to include exception handling. Indeed, abstract implementation of specifications including exception handling was one of main motivations for the work reported here.},
author = {Bernot, G and Bidoit, M and Choppy, C},
file = {::},
journal = {Theoretical Computer Science},
keywords = {abstract data types,errors-only,exception algebras,exception handling,exception recovery,implementation,initial model,structured specifications},
mendeley-tags = {errors-only},
number = {1},
pages = {13--46},
title = {{Abstract Data Types with Exception Handling: An initial approach}},
volume = {46},
year = {1986}
}
@inproceedings{pavlinovic2014finding,
abstract = {Automatic type inference is a popular feature of functional programming languages. If a program cannot be typed, the compiler typically reports a single program location in its error message. This location is the point where the type inference failed, but not necessarily the actual source of the error. Other potential error sources are not even considered. Hence, the compiler often misses the true error source, which increases debugging time for the programmer. In this paper, we present a general framework for automatic localization of type errors. Our algorithm finds all minimum error sources, where the exact definition of minimum is given in terms of a compiler-specific ranking criterion. Compilers can use minimum error sources to produce more meaningful error reports, and for automatic error correction. Our approach works by reducing the search for minimum error sources to an optimization problem that we formulate in terms of weighted maximum satisfiability modulo theories (MaxSMT). The reduction to weighted MaxSMT allows us to build on SMT solvers to support rich type systems and at the same time abstract from the concrete criterion that is used for ranking the error sources. We have implemented an instance of our framework targeted at Hindley-Milner type systems and evaluated it on existing OCaml benchmarks for type error localization. Our evaluation shows that our approach has the potential to significantly improve the quality of type error reports produced by state of the art compilers.},
address = {Portland, Oregon},
author = {Pavlinovic, Zvonimir and King, Tim and Wies, Thomas},
booktitle = {OOPSLA '14 Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages & Applications},
doi = {10.1145/2714064.2660230},
file = {::;::},
isbn = {9781450325851},
issn = {03621340},
keywords = {diagnostics,satisfiability modulo,technical,type errors},
mendeley-tags = {technical},
number = {10},
pages = {525--542},
title = {{Finding minimum type error sources}},
volume = {49},
year = {2014}
}
@incollection{hazan1993location,
address = {Berlin/Heidelberg},
author = {Hazan, Jonathan E. and Morgan, Richard G.},
booktitle = {AADEBUG '93 Proceedings of the First International Workshop on Automated and Algorithmic Debugging},
doi = {10.1007/BFb0019406},
file = {::},
isbn = {3-540-57417-4},
keywords = {enhancement,technical},
mendeley-tags = {enhancement,technical},
pages = {135--152},
publisher = {Springer-Verlag},
title = {{The location of errors in functional programs}},
url = {http://www.springerlink.com/index/10.1007/BFb0019406},
year = {1993}
}
@article{Chawla2018,
abstract = {The question of what a spoonerism was called before Dr Spooner named it is examined. Wordsworth is not certain of the answer.},
author = {Chawla, Dalmeet Singh},
doi = {10.1111/j.1740-9713.2018.01101.x},
file = {::},
issn = {17409713},
journal = {Significance},
keywords = {begin-,error message design,ner-friendly ides,novice programmers,user-studies},
number = {1},
pages = {6--7},
title = {{Mind your language}},
volume = {15},
year = {2018}
}
@inproceedings{neubauer2003discriminative,
abstract = {We propose a type system for locating the source of type errors in an applied lambda calculus with ML-style polymorphism. The system is based on discriminative sum types---known from work on soft typing---with annotation subtyping and recursive types. This way, type clashes can be registered in the type for later reporting. The annotations track the potential producers and consumers for each value so that clashes can be traced to their cause.Every term is typeable in our system and type inference is decidable. A type derivation in our system describes all type errors present in the program, so that a principal derivation yields a principal description of all type errors present. Error messages are derived from completed type derivations. Thus, error messages are independent of the particular algorithm used for type inference, provided it constructs such a derivation.},
address = {Uppsala, Sweden},
author = {Neubauer, Matthias and Thiemann, Peter},
booktitle = {ICFP '03 Proceedings of the eighth ACM SIGPLAN international conference on Functional programming},
doi = {10.1145/944746.944708},
file = {::},
isbn = {1581137567},
issn = {03621340},
keywords = {polymorphism,technical,type errors,type inference},
mendeley-tags = {technical},
number = {9},
pages = {15--26},
publisher = {ACM},
title = {{Discriminative sum types locate the source of type errors}},
volume = {38},
year = {2003}
}
@inproceedings{tsushima2018common,
abstract = {{\textcopyright} 2018, Springer International Publishing AG, part of Springer Nature. Many different approaches to type error debugging were developed independently. In this paper, we describe a new common framework for several type error debugging approaches. For this purpose, we introduce expected types from the outer context and propose a method for obtaining them. Using expected types, we develop three type error debugging approaches: enumeration of type error messages, type error slicing and (improved) interactive type error debugging. Based on our idea we implemented prototypes and confirm that the framework works well for type debugging.},
author = {Tsushima, Kanae and Chitil, Olaf},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-90686-7_15},
file = {::},
isbn = {9783319906850},
issn = {16113349},
keywords = {enhancement,technical},
mendeley-tags = {enhancement,technical},
title = {{A common framework using expected types for several type debugging approaches}},
year = {2018}
}
@article{azab2008automatic,
author = {Azab, Karl and Pennemann, Karl-Heinz},
file = {::},
keywords = {modelling,multi-forma,simulation,systems theory,technical},
mendeley-tags = {technical},
title = {{Type Checking C++ Template Instantiation by Graph Programs}},
volume = {10},
year = {2008}
}

@article{rahli2017skalpelconstraint,
abstract = {Compilers for languages with type inference algorithms often produce confusing type error messages and give a single error location which is sometimes far away from the real location of the error. Attempts at solving this problem often (1) fail to include the multiple program points which make up the type error; (2) report tree fragments which do not correspond to any place in the user program; and (3) give incorrect type information/diagnosis which can be highly confusing. We present Skalpel, a type error slicing tool which solves these problems by giving the programmer all and only the information involved with a type error to significantly aid in diagnosis and repair of type errors. Skalpel relies on a simple and general constraint system, a sophisticated constraint generator which is linear in program size, and a constraint solver which is terminating. Skalpel's constraint system can elegantly and efficiently handle intricate features such as SML's open. We also show that the Skalpel tool is general enough to deal not only with one source code file and one single error, but highlights all and only the possible locations of the error(s) in all affected files and produces all the culprit multiple program slices.},
annote = {PDF IS WRONG!!},
author = {Rahli, Vincent and Wells, Joe and Pirie, John and Kamareddine, Fairouz},
doi = {10.1016/j.jsc.2016.07.013},
issn = {07477171},
journal = {Journal of Symbolic Computation},
keywords = {Automated error diagnosis,Automated type inference,Constraint-based type inference,Improved error reports,Type error slicing,technical},
mendeley-tags = {technical},
month = {May},
pages = {164--208},
title = {{Skalpel: A Constraint-based Type Error Slicer for Standard ML}},
url = {https://linkinghub.elsevier.com/retrieve/pii/S0747717116300505},
volume = {80},
year = {2017}
}

@article{richter1985noncorrecting,
abstract = {A parser must be able to continue parsing after encountering a syntactic error to check the remainder of the input. To achieve this, it is not necessary to perform corrections on either the input text or the stack contents. A formal framework is provided in which noncorrecting syntax error recovery concepts are defined and investigated. The simplicity of these concepts allows the statement of provable properties, such as the absence of spurious error messages or the avoidance of skipping input text. These properties are due to the fact that no assumptions about the nature of the errors need be made to continue parsing.},
author = {Richter, Helmut},
doi = {10.1145/3916.4019},
file = {::},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {technical},
mendeley-tags = {technical},
title = {{Noncorrecting syntax error recovery}},
year = {1985}
}
@article{sippu1983syntax,
author = {Sippu, Seppo and Soisalon-Soininen, Eljas},
doi = {10.1145/69575.357232},
file = {::},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {empirical,technical},
mendeley-tags = {empirical,technical},
title = {{A Syntax-Error-Handling Technique and Its Experimental Analysis}},
year = {1983}
}
@article{hemel2011static,
abstract = {Modern web application development frameworks provide web application developers with high-level abstractions to improve their productivity. However, their support for static verification of applications is limited. Inconsistencies in an application are often not detected statically, but appear as errors at run-time. The reports about these errors are often obscure and hard to trace back to the source of the inconsistency. A major part of this inadequate consistency checking can be traced back to the lack of linguistic integration of these frameworks. Parts of an application are defined with separate domain-specific languages, which are not checked for consistency with the rest of the application. Examples include regular expressions, query languages and XML-based languages for definition of user interfaces. We give an overview and analysis of typical problems arising in development with frameworks for web application development, with Ruby on Rails, Lift and Seam as representatives.To remedy these problems, in this paper, we argue that domain-specific languages should be designed from the ground up with static verification and cross-aspect consistency checking in mind, providing linguistic integration of domain-specific sub-languages. We show how this approach is applied in the design of WebDSL, a domain-specific language for web applications, by examining how its compiler detects inconsistencies not caught by web frameworks, providing accurate and clear error messages. Furthermore, we show how this consistency analysis can be expressed with a declarative rule-based approach using the Stratego transformation language. {\textcopyright} 2010 Elsevier Ltd.},
author = {Hemel, Zef and Groenewegen, Danny M. and Kats, Lennart C.L. and Visser, Eelco},
doi = {10.1016/j.jsc.2010.08.006},
file = {::},
issn = {07477171},
journal = {Journal of Symbolic Computation},
keywords = {Consistency checking,Domain-specific language,Linguistic integration,Static analysis,Verification,Web application development,technical},
mendeley-tags = {technical},
number = {2},
pages = {150--182},
publisher = {Elsevier Ltd},
title = {{Static Consistency Checking of Web Applications with WebDSL}},
url = {http://dx.doi.org/10.1016/j.jsc.2010.08.006},
volume = {46},
year = {2011}
}
@techreport{bruce1998unification,
 abstract = {Traditional type-inference and type-checking algorithms work well with cor- rectly typed programs, but their results when given programs containing type-errors can be unpredictable. This leads to a problemwith implementations oftype-checkers: they are often inaccurate when announcing the apparent locations of mistakes in programs, tending to notice problems towards the end of the the program even if the source occurs much earlier. This is a particular problem with programming lan- guages with Hindley-Milner type-systems such as used in Standard ML. A common technique in type-inference and type-checking is unification. Unify- ing types creates a substitution which is applied to a type-environment. The substi- tutions which have been applied to the type-environment can influence the detection of type-errors in different subexpressions of the program. This paper defines the operation of unifying substitutions and shows how type- inference algorithms can be modified to use this operation to delay the application of substitutions to the type-environment. This removes the bias to detecting errors to- wards the end of the program. Two different type-inference algorithms for Hindley- Milner type-inference are modified in this way and the potential for improved error reporting is shown.},
 author = {McAdam, Bruce J.},
 mendeley-tags = {enhancement,technical},
 pages = {1--23},
 year = {1998},
 title={On the Unification of Substitutions in Type Inference},
 url={http://www.lfcs.inf.ed.ac.uk/reports/98/ECS-LFCS-98-384/ECS-LFCS-98-384.pdf}
}

@inproceedings{laurent2017red,
 abstract = {Red Shift is a new design pattern for implementing parsers. The pattern draws ideas from traditional shift-reduce parsing as well as procedural PEG parsers. Red Shift parsers behaves like shift-reduce parsers, but eliminate ambiguity by always prioritizing reductions over shifts. To compensate the resulting lack of expressivity, reducers are not simple reduction rules but full-blown procedures written in a general-purpose host language. I found many advantages to this style of parser. In particular, we can generate high-quality error messages more easily; and compose different style of parsers. I also speculate about how Red Shift parsers may improve partial compilation in the context of an IDE.},
 mendeley-tags = {gen-lit,technical},
 author = {Laurent, Nicolas},
 title = {Red Shift: Procedural Shift-reduce Parsing (Vision Paper)},
 booktitle = {Proceedings of the 10th ACM SIGPLAN International Conference on Software Language Engineering},
 series = {SLE '17},
 year = {2017},
 isbn = {978-1-4503-5525-4},
 location = {Vancouver, BC, Canada},
 pages = {38--42},
 url = {http://doi.acm.org/10.1145/3136014.3136036},
 doi = {10.1145/3136014.3136036},
 acmid = {3136036},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {parsers, parsing, pattern},}
@article{Jansen1986High-Accuracy,
abstract = {The program package ACRITH (High Accuracy Arithmetic Subroutine Library) provides FORTRAN subroutines for the solution of several standard mathematical problems. The routines use floating point operations with extended precision and interval arithmetic and are designated especially for the solution of ill-conditioned problems. Test results for most of the routines are presented with emphasis on the practical usability of the package. It turns out that not all routines are of equal high quality and reliability; in the documentation, hints to the implemented numerical algorithms are completely missing, and the error messages are not always concise. Some possible alternatives like symbolic algebra systems or multiple precision packages are mentioned.},
author = {Jansen, Paul and Weidner, Peter},
doi = {10.1145/5960.5962},
file = {::},
issn = {00983500},
journal = {ACM Transactions on Mathematical Software},
keywords = {and phrases,high-accuracy,technical},
mendeley-tags = {technical},
number = {1},
pages = {62--70},
title = {{High-accuracy arithmetic software---some tests of the ACRITH problem-solving routines}},
volume = {12},
year = {1986}
}
@article{Efe1987A,
abstract = {A simple "lets talk about it" strategy is developed that enables users to explore lower level error messages through dialogue.},
author = {Efe, Kemal},
doi = {10.1145/32206.32210},
file = {::},
journal = {Communications of the ACM},
keywords = {enhancement},
mendeley-tags = {enhancement},
number = {11},
pages = {948--955},
title = {{A proposed solution to the problem of levels in error-message generation}},
volume = {30},
year = {1987}
}

@inproceedings{Luecke2010a,
 abstract = {The ability of system software to detect run-time errors and issue messages that help programmers quickly fix these errors is an important productivity criterion for developing and maintaining application programs. To evaluate this capability for Unified Parallel C (UPC), over two thousand run-time error tests and a run-time error detection (RTED) evaluation tool have been developed. For each error message issued, the RTED evaluation tool assigns a score from 0 to 5 based on the usefulness of the information in the message to help a programmer quickly fix the error. The RTED evaluation tool calculates averages over each error category and then prints the results. All tests and the RTED evaluation tool are freely available at the RTED web site http://rted.public.iastate.edu/ UPC. The Cray, Berkeley, HP and GNU UPC compilers have been evaluated and results posted on this same web site. {\textcopyright} 2009 ACM.},
 mendeley-tags = {empirical,guidelines,runtime-errors,technical,tool},
 author = {Luecke, Glenn R. and Coyle, James and Hoekstra, James and Kraeva, Marina and Xu, Ying and Kleiman, Elizabeth and Weiss, Olga},
 title = {Evaluating Error Detection Capabilities of UPC Run-time Systems},
 booktitle = {Proceedings of the Third Conference on Partitioned Global Address Space Programing Models},
 series = {PGAS '09},
 year = {2009},
 isbn = {978-1-60558-836-0},
 location = {Ashburn, Virginia, USA},
 pages = {7:1--7:4},
 numpages = {4},
 articleno = {7},
 url = {http://doi.acm.org/10.1145/1809961.1809971},
 doi = {10.1145/1809961.1809971},
 acmid = {1809971},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@article{burke1987practical,
abstract = {This paper presents a powerful, practical, and essentially language-independent syntactic error diagnosis and recovery method that is applicable within the frameworks of LR and LL parsing. The method generally issues accurate diagnoses even where multiple errors occur within close proximity, yet seldom issues spurious error messages. It employs a new technique, parse action deferral, that allows the most appropriate recovery in cases where this would ordinarily be precluded by late detection of the error. The method is practical in that it does not impose substantial space or time overhead on the parsing of correct programs, and in that its time efficiency in processing an error allows for its incorporation in a production compiler. The method is language independent, but it does allow for tuning with respect to particular languages and implementations through the setting of language-specific parameters.},
author = {Burke, Michael G. and Fisher, Gerald A.},
doi = {10.1145/22719.22720},
file = {::},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {technical,tool},
mendeley-tags = {technical,tool},
number = {2},
pages = {164--197},
title = {{A practical method for LR and LL syntactic error diagnosis and recovery}},
volume = {9},
year = {1987}
}
@article{elazhary2012facile,
abstract = {High-level languages and very high-level languages have been developed to simplify programming. But, programming is still hard for many people especially those from disciplines that are not computer-related. Facile programming implies the modification of programming languages to be easily learnt, remembered, and used by programmers from different disciplines. This is achieved by studying and trying to tackle the practical difficulties that face such programmers. The paper addresses the difficulty of learning, remembering, using, and understanding compilation error messages of common English-like programming languages by programmers who are not fluent in English. To tackle this problem, we developed Arabic versions of LISP and SQL in an attempt to figure out whether developing versions, of common programming languages, that are like natural languages of programmers would improve their programming capability. Syntax errors in the Arabic versions can be detected and the corresponding error messages are produced in Arabic. To encourage the use of these Arabic versions, we also developed translators that can translate programs between the corresponding Arabic and English versions of these programming languages for portability. This paper explains the Arabic version of SQL, but reports results from our experience with the Arabic versions of both LISP and SQL. [ABSTRACT FROM AUTHOR]},
author = {Elazhary, Hanan},
file = {::},
issn = {16833198},
journal = {International Arab Journal of Information Technology},
keywords = {Arabic SQL,Arabic programming,Programming languages,SQL,empirical,enhancement,tool},
mendeley-tags = {empirical,enhancement,tool},
number = {3},
pages = {256--261},
title = {{Facile programming}},
volume = {9},
year = {2012}
}
@article{Peijnenburg2017Type,
abstract = {Falco Peijnenburg Jurriaan Hage Alejandro Serrano},
author = {Peijnenburg, Falco and Hage, Jurriaan and Serrano, Alejandro},
doi = {10.1145/3064899.3064907},
file = {::},
isbn = {9781450347679},
journal = {IFL 2016 Proceedings of the 28th Symposium on the Implementation and Application of Functional Programming Languages},
keywords = {acm reference format,elm,embedded domain speci c,enhancement,languages,type classes,type error diagnosis,type graphs},
mendeley-tags = {enhancement},
pages = {1--12},
title = {{Type Directives and Type Graphs in Elm}},
year = {2017}
}
@article{kulzer1988minimal,
abstract = {The requirement for some sort of centralized error handler package resulted from earlier work involving coding of Ada compilation units. It became apparent during the coding of these other units that, in many cases, the same type of error messages were being written for exception handlers included in the various Ada compilation units. It was decided that a central repository of these recurring error messages would be desirable to have. Further analysis indicated that this central repository could be made more general purpose if the error messages were written in a more generic fashion. There is a loss of information content and specificity when one writes general purpose error messages. It is pointed out that it is possible that the general purpose messages could still be useful in indicating a starting place to look when investigating the cause of a raised exception.},
annote = {cited By 0},
author = {Kulzer, Randy D},
file = {::},
journal = {Journal of Pascal, Ada & Modula-2},
keywords = {pre-guidelines,technical},
mendeley-tags = {pre-guidelines,technical},
number = {6},
pages = {8--20},
title = {{Minimal error handler package written in Ada}},
url = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-0024108048&partnerID=40&md5=80bff497e65ee89f670b09b8e8d8378d},
volume = {7},
year = {1988}
}

@misc{wilska2004nonfatal,
 abstract = {"Memory requests for some applications may be denied." "Error 404: File not found." "Invalid entry. Check your info and resubmit." "Fatal error. Procedure aborted." It's often easy to identify what kinds of error messages don't help users, but it can be tricky to avoid them, and even more of a challenge to create the opposite: error messages that give users a clear indication of the problem, offer information to help them fix it, and provide tips on haw to avoid the same situation in the future. This paper details the steps involved in creating understandable, helpful error messages, and suggests ways of communicating the value of good error messages to managers and executives.},
 author = {Wilska, Emily},
 keywords = {guidelines},
 mendeley-tags = {guidelines},
 title = {{Non-Fatal Errors : Creating Usable , Effective Error Messages}},
 year = {2004},
 howpublished = {\url{http://www.writersua.com/articles/message/index.html}}
}

@article{Tzeng2004,
abstract = {While it is difficult to create completely error-free interactions in software design, the issue of how to make users feel better when they encounter errors is critical to the concept of user-centered design. Neilsen argued for offering a slightly apologetic statement before an error message provided by web servers, but the notion of a computer apologizing to its users inevitably triggers a debate about the appropriateness of providing humanized messages to users. To understand how users react to computers' apologies (presented by textual or visual formats), a computer-guessing game was designed to test users' reactions. The game features three treatments (difficulty levels, feedback types, and emotional icons), each having two levels (difficult vs. easy, apologetic feedback vs. non-apologetic feedback, with emotional icons vs. without emotional icons). Two-hundred and sixty nine high school students participated in this study and were randomly assigned to one of eight groups. The results show that while the computers' actual performances still dominated the users' assessments of the program, the computer apologies help to create more desirable psychological experiences for the users, and emotional icons help to improve the aesthetic quality of the program. {\textcopyright} 2004 Elsevier Ltd. All rights reserved.},
author = {Tzeng, Jeng Yi},
doi = {10.1016/j.ijhcs.2004.01.002},
file = {::},
issn = {10715819},
journal = {International Journal of Human Computer Studies},
keywords = {gen-lit,hci},
mendeley-tags = {gen-lit,hci},
number = {3},
pages = {319--345},
title = {{Toward a more civilized design: Studying the effects of computers that apologize}},
volume = {61},
year = {2004}
}
@inproceedings{kurvinen2016programming,
abstract = {Learning to program is known to be a difficult task, as the students typically lack the intrinsic motivation and find the new skills required difficult to master. It is hence typical for the educators to try to constantly improve their teaching methods to enhance the quality and outcome of the courses. We have developed an educational tool called ViLLE, which allows us to create interactive and automatically assessed programming exercises easily. In these exercises, the students have a near-to-authentic programming environment with compiler output and error messages provided. The same tool was used in our university's introductory programming course's final exam. In this paper, we analyze students' answers to three different coding exercises in this final exam. Since ViLLE automatically stores the program code when compiled, we have an access to previously unseen amounts of iterations of the exercise instead of just the final submission. The data is analyzed to identify typical misconceptions in programming exercises, and to show how the students gradually improve their answers based on the results and error messages. Finally, we discuss how the results of the analysis can be utilized to tackle these misconceptions during the course.},
author = {Kurvinen, Einari and Hellgren, Niko and Kaila, Erkki and Laakso, Mikko-Jussi and Salakoski, Tapio},
booktitle = {Proceedings of the 2016 ACM Conference on Innovation and Technology in Computer Science Education},
doi = {10.1145/2899415.2899447},
file = {::},
keywords = {automatic assessment,empirical,exams,misconceptions,pedagogy,programming,tool},
mendeley-tags = {empirical,pedagogy,tool},
pages = {308--313},
title = {{Programming Misconceptions in an Introductory Level Programming Course Exam}},
year = {2016}
}
@inproceedings{sippu1982lr,
abstract = {An automatic syntax error handling technique applicable to LR parsing is presented and analyzed. The technique includes a "phrase-level" error recovery strategy augmented with certain additional features such as "local correction". Attention has also been paid to di agnostic aspects, i.e. the automatic generation of error message texts. The technique has been implemented in the compiler writing system HLP (Helsinki Language Processor), and some promising experimental results have been obtained by testing the technique with erroneous student-written Algol and Pascal programs.},
address = {Albuquerque, New Mexico},
author = {Sippu, Seppo and Soisalon-Soininen, Eljas},
booktitle = {POPL '82:Proceedings of the 9th ACM SIGPLAN-SIGACT sguages},
doi = {10.1145/582153.582173},
file = {::},
isbn = {0897910656},
keywords = {empirical,technical},
mendeley-tags = {empirical,technical},
pages = {177--184},
publisher = {ACM},
title = {{Practical Error Recovery in LR Parsing}},
year = {1982}
}
@inproceedings{Jambalsuren2002,
author = {Jambalsuren, Mungunsukh and Cheng, Zixue},
booktitle = {Databases in Networked Information Systems, Second International Workshop,
DNIS 2002, Aizu, Japan, December 16-18, 2002, Proceedings},
doi = {10.1007/3-540-36233-9_16},
editor = {Bhalla, Subhash},
file = {::},
isbn = {3-540-00264-2},
keywords = {difficulties,enhancement},
mendeley-tags = {difficulties,enhancement},
pages = {201--212},
publisher = {Springer},
series = {Lecture Notes in Computer Science},
title = {{An Interactive Programming Environment for Enhancing Learning Performance}},
url = {https://doi.org/10.1007/3-540-36233-9_16},
volume = {2544},
year = {2002}
}
@article{vazou2018gradual,
abstract = {Refinement types allow for lightweight program verification by enriching types with logical predicates. Liquid typing provides a decidable refinement inference mechanism that is convenient but subject to two major issues: (1) inference is global and requires top-level annotations, making it unsuitable for inference of modular code components and prohibiting its applicability to library code, and (2) inference failure results in obscure error messages. These difficulties seriously hamper the migration of existing code to use refinements. This paper shows that gradual liquid type inference{\'{s}}a novel combination of liquid inference and gradual refinement types{\'{s}}addresses both issues. Gradual refinement types, which support imprecise predicates that are optimistically interpreted, can be used in argument positions to constrain liquid inference so that the global inference process effectively infers modular specifications usable for library components. Dually, when gradual refinements appear as the result of inference, they signal an inconsistency in the use of static refinements. Because liquid refinements are drawn from a finite set of predicates, in gradual liquid type inference we can enumerate the safe concretizations of each imprecise refinement, i.e., the static refinements that justify why a program is gradually well-typed. This enumeration is useful for static liquid type error explanation, since the safe concretizations exhibit all the potential inconsistencies that lead to static type errors. We develop the theory of gradual liquid type inference and explore its pragmatics in the setting of Liquid Haskell. To demonstrate the utility of our approach, we develop an interactive tool, GuiLT, for gradual liquid type inference in Liquid Haskell that both infers modular types and explores safe concretizations of gradual refinements. We report on the use of GuiLT for error reporting and discuss a case study on the migration of three commonly-used Haskell list manipulation libraries into Liquid Haskell.},
author = {Vazou, Niki and Tanter, {\'{E}}ric and {Van Horn}, David},
doi = {10.1145/3276502},
file = {::},
journal = {Proceedings of the ACM on Programming Languages},
keywords = {technical},
mendeley-tags = {technical},
number = {OOPSLA},
pages = {1--25},
title = {{Gradual liquid type inference}},
volume = {2},
year = {2018}
}
@inproceedings{relies1981user,
abstract = {This paper describes a software user inter- face that enables programmers to provide and main- tain online aids in an interactive system. Through the interface, users are given a set of consistent and unobtrusive aids that display summary information, command descriptions, explanations of error mes- sages, and other online documentation. The interface is presented here from the views of both the end-user and the programmer.},
author = {Relies, Nathan and Price, Lynne A},
booktitle = {5th international conference on Software engineering},
file = {::},
keywords = {enhancement},
mendeley-tags = {enhancement},
pages = {400--408},
title = {{A User Interface for Online Assistance}},
year = {1981}
}
@article{Lipman2014,
author = {Lipman, Derrell},
file = {::},
journal = {Journal of Computing Sciences in Colleges},
keywords = {difficulties,hci},
mendeley-tags = {difficulties,hci},
number = {6},
pages = {144--150},
title = {{LearnCS!: A New, Browser-Based C Programming Environment for CS1}},
volume = {29},
year = {2014}
}
@article{davis1995learning,
 abstract = {This article illustrates successful strategies for helping novice programming students understand the use of parentheses (Ps) and quotes (Qs) in LISP. Based on detailed analysis of students working programming problems, we designed lab exercises to address typical difficulties. Rather than emphasizing correct answers, our approach, inspired by the scaffolded knowledge integration (SKI) framework, required students to take the role of investigator and critic. In particular, the intervention required students to critique incorrect calls, identify the incorrect rule being applied in the incorrect call, and correct the call. It also required students to identify causes of error messages we identified as difficult. These exercises had a positive effect not just on the calls to functions, which the intervention specifically addressed, but also on writing function definitions and predicting results, which were not specifically addressed by the intervention. The exercises improved students' understanding of LISP and increased the efficiency of future instruction.},
 annote = {cited By 6},
 author = {Davis, E A and Linn, M C and Clancy, M},
 doi = {10.1080/0899340950060102},
 file = {::},
 journal = {Computer Science Education},
 keywords = {empirical,pedagogy,performance},
 mendeley-tags = {empirical,pedagogy,performance},
 number = {1},
 pages = {15--31},
 title = {{Learning to Use Parentheses and Quotes in LISP}},
 url = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-0038368529&doi=10.1080\%2F0899340950060102&partnerID=40&md5=a86258426366449ba478f7119f091282},
 volume = {6},
 year = {1995}
}

@article{Chu2015,
abstract = {With the popularity of embedded systems and the consequently rising demand in the job market for professionals well-versed in them, embedded operating systems (EOSs) have become one of the core courses in computer science studies across the world. The objective of EOS courses is to develop students' ability to port, modify, and customize an embedded operating system through a series of laboratory exercises. However, our teaching experience has revealed that beginners require a considerable amount of time to familiarize themselves with the development environment and the relevant processes, such as operating in a command line interface, setting environment variables, and kernel configurations. Furthermore, students need to constantly handle compiler error messages, malfunctions of the target EOS, and incompatibility issues related to development tools. These problems may frustrate and discourage students. A common strategy to address this problem is to dedicate more hours to teaching or to hire more teaching assistants to help students progress. However, none of these methods is suitable for institutions with limited resources. Therefore, in this paper, we develop a computer-assisted learning system called the Computer-assisted Learning Environment (CALEE) to assist students with their assignments and thus motivate them. CALEE consists of two parts: a self-learning assistant (SLAT) and a collaborative learning website (CLW). SLAT is a software application that provides a set of useful functions to help students perform EOS laboratory exercises, whereas the collaborative learning website seeks to encourage greater interaction among students. Our experiments show that CALEE expedites learning, improves students' motivation, and reduces the teaching load.},
author = {Chu, Edward T.H. and Fang, Chi Wei},
doi = {10.1016/j.compedu.2015.01.006},
file = {::},
issn = {03601315},
journal = {Computers and Education},
keywords = {Applications in subject areas,Architectures for educational technology system,Cooperative/collaborative learning,Improving classroom teaching,Interactive learning environments,empirical,enhancement},
mendeley-tags = {empirical,enhancement},
pages = {36--48},
publisher = {Elsevier Ltd},
title = {{CALEE: A computer-assisted learning system for embedded OS laboratory exercises}},
url = {http://dx.doi.org/10.1016/j.compedu.2015.01.006},
volume = {84},
year = {2015}
}
@article{bettini2019type,
abstract = {Providing IDE support for a programming language or a DSL (Domain Specific Language) helps the users of the language to be more productive and to have an immediate feedback on possible errors in a program. Static types can drive IDE mechanisms such as the content assist to propose sensible completions in a given program context. Types can also be used to enrich other typical IDE parts such as the Outline and theHovering pop-ups. In this paper, we focus on statically typed imperative languages, adopting some form of type inference. We present a few general patterns for implementing efficient type systems, focusing on type error recovery. This way, the type system is able to type as many parts of the program as possible, keeping a good IDE experience. Type error messages will be placed on the important parts of the program, avoiding cascading errors that can confuse the user. We show two case studies:we apply the presented patterns to implement the type system of two statically typed DSLs, a simple expression language and a reduced Java-like language, with OOP features. We use Xtext as the language workbench for implementing the compiler and the IDE support andXsemantics, a DSL for implementing type systems using a syntax that mimics formal systems. The patterns shown in the paper can be reused also for implementing languages with other language frameworks.},
author = {Bettini, Lorenzo},
doi = {10.1515/comp-2019-0003},
file = {::},
journal = {Open Computer Science},
keywords = {guidelines,ide,language implementation,technical,type system},
mendeley-tags = {guidelines,technical},
number = {1},
pages = {52--79},
title = {{Type errors for the IDE with Xtext and Xsemantics}},
volume = {9},
year = {2019}
}
@article{spenke1984language,
author = {Spenke, Michael and Muhlenbein, Heinz and Mevenkamp, Monika and Mattern, Friedemann},
file = {::},
keywords = {syntax error recovery,technical},
mendeley-tags = {technical},
number = {NOVEMBER},
pages = {1095--1107},
title = {{A language independent error recovery method for LL(1) parsers}},
volume = {14},
year = {1984}
}
@article{sayfan2007practical,
author = {{Gigi Sayfan}},
file = {::},
journal = {Dr. Dobb's},
keywords = {technical},
mendeley-tags = {technical},
title = {{Practical C++ Error Handling in Hybrid Environments How to interface your exception-handling code to software components that practice different error-handling methods}},
url = {www.drdobbs.com/article/print?articleId=197003350&siteSectionName=cppURL:http://www.drdobbs.com/cpp/practical-c-error-handling-in-hybrid-env/197003350},
year = {2007}
}
@article{serrano2019compiler,
abstract = {Domain-specific languages (DSLs) permeate current programming practices. An important kind of DSLs includes those developed and integrated within a host language, which we call embedded or internal DSLs. Unfortunately, embedded DSLs usually fall short on domain-specific error diagnosis, that is, they do not give control to DSL authors over how errors are reported to the programmer. As a consequence, implementation details of the DSL leak through in error messages, and programmers need to understand the internals of the DSL implementation to fix their code in a productive way. This paper addresses the challenge of building a compiler with integrated support for domain-specific error diagnosis. We assume that the type system is described using a constraint-based approach, and constraint solving is specified using rewrite rules. Domain information can then be injected at constraint gathering time via type rules, during constraint solving via specialized rules and axioms, and finally at blaming and reparation time via transformations. Furthermore, we define error contexts as a way to control the order in which solving and blaming proceeds. We engineer domain-specific error diagnosis in such a way that the compiler can also reuse the techniques for improving general error diagnosis.},
author = {Serrano, Alejandro and Hage, Jurriaan},
doi = {10.1515/comp-2019-0002},
file = {::},
journal = {Open Computer Science},
keywords = {technical},
mendeley-tags = {technical},
number = {1},
pages = {33--51},
title = {{A compiler architecture for domain-specific type error diagnosis}},
volume = {9},
year = {2019}
}
@article{maidl2016error,
abstract = {Parsing Expression Grammars (PEGs) describe top-down parsers. Unfortunately, the error-reporting techniques used in conventional top-down parsers do not directly apply to parsers based on Parsing Expression Grammars (PEGs), so they have to be somehow simulated. While the PEG formalism has no account of semantic actions, actual PEG implementations add them, and we show how to simulate an error-reporting heuristic through these semantic actions. We also propose a complementary error reporting strategy that may lead to better error messages: labeled failures. This approach is inspired by exception handling of programming languages, and lets a PEG define different kinds of failure, with each ordered choice operator specifying which kinds it catches. Labeled failures give a way to annotate grammars for better error reporting, to express some of the error reporting strategies used by deterministic parser combinators, and to encode predictive top-down parsing in a PEG.},
author = {Maidl, Andr{\'{e}} Murbach and Mascarenhas, Fabio and Medeiros, S{\'{e}}rgio and Ierusalimschy, Roberto},
doi = {10.1016/j.scico.2016.08.004},
file = {::},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Error reporting,Packrat parsing,Parser combinators,Parsing,Parsing expression grammars,enhancement,guidelines,technical},
mendeley-tags = {enhancement,guidelines,technical},
title = {{Error reporting in Parsing Expression Grammars}},
year = {2016}
}

@inproceedings{Magers2003,
 abstract = {An interactive computer system was made easier to learn for non-programmers by modifying the on-line HELP and error messages of a system designed primarily for programmers. The modifications included supplementing the existing HELP command with a HELP key, making the content of HELP and error messages more concrete, responding to command synonyms, and more. The systems were evaluated in a between-groups experiment in which office workers with no programming experience were asked to perform a typical office task using one of the unfamiliar interactive computer systems. The results of the experiment supported the inclusion of the modifications. Non-programmers using the modified system completed the computer task in less time, with greater accuracy, and with better resulting attitudes than those who used the system designed primarily for programmers.},
 mendeley-tags = {enhancement,pre-guidelines},
 author = {Magers, Celeste S.},
 title = {An Experimental Evaluation of On-line HELP for Non-programmers},
 booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
 series = {CHI '83},
 year = {1983},
 isbn = {0-89791-121-0},
 location = {Boston, Massachusetts, USA},
 pages = {277--281},
 url = {http://doi.acm.org/10.1145/800045.801626},
 doi = {10.1145/800045.801626},
 acmid = {801626},
 publisher = {ACM},
 address = {New York, NY, USA},
}}

@article{heeren2010type,
author = {Heeren, Bastiaan and Hage, Jurriaan},
doi = {10.1007/978-3-540-30557-6_19},
file = {::},
keywords = {directives,domain-specific,enhancement,technical,type classes,type error messages},
mendeley-tags = {enhancement,technical},
pages = {253--267},
title = {{Type Class Directives}},
year = {2010}
}

@article{Xinogalos2017,
 abstract = {{\textcopyright} 2015, Springer Science+Business Media New York.Teaching and learning programming constitutes a challenge. Although several teaching approaches and programming tools have been proposed, it seems that they have limited impact on classroom practice. This article investigates students' perceptions on five educational programming environments that are widely used and the features that any introductory programming environment should have. The environments investigated are: BlueJ; objectKarel; Scratch; Alice; and MIT App inventor. These environments were studied and used by experienced undergraduate students of Informatics in the context of a fourth year course. The main features of the environments and the way of presenting them to students, as well as the assignments in the context of the course are presented, in order to help the reader realize what experience was gained by the students that evaluated the environments. Based on a questionnaire filled in by students interesting conclusions were drawn. Students identified the main features of the environments and evaluated them positively, although problems were identified. An introductory programming environment should engage students through the development of programs connected to their interests, such as games and mobile apps. Moreover, an ideal introductory programming environment should provide a simple and user-friendly Graphical User Interface (GUI) that supports visualization of objects and classes, includes a puzzle-like editor for program development, reports simple and understandable error messages in natural language, and finally the ability to execute the program in a step by step manner. Although no single environment fulfils all these features, it seems that the most successful environment is Scratch.},
 author = {Xinogalos, Stelios and Satratzemi, Maya and Malliarakis, Christos},
 doi = {10.1007/s10639-015-9433-1},
 file = {::},
 issn = {15737608},
 journal = {Education and Information Technologies},
 keywords = {Educational games,Educational programming environments,Microworlds,Mobile apps,Pedagogy,Teaching and Learning Programming,pre-guidelines},
 mendeley-tags = {pre-guidelines},
 title = {{Microworlds, Games, Animations, Mobile Apps, Puzzle Editors and More: What is Important for an Introductory Programming Environment?}},
 year = {2017},
 month= Jan,
 volume="22",
 number="1",
 pages="145--176",
 url="https://doi.org/10.1007/s10639-015-9433-1"
}

@inproceedings{shaw1989making,
 abstract = {Emulating the overall design of APL, the error messages generated by APL interpreters are formal and succinct. Because of this one gets the feeling the interpreter is not telling all that it knows. It is urged that error messages be made more revealing, and, hence, more user-friendly.},
 mendeley-tags = {guidelines},
 author = {Shaw, W. J.},
 title = {Making APL Error Messages Kinder and Gentler},
 booktitle = {Conference Proceedings on APL As a Tool of Thought},
 series = {APL '89},
 year = {1989},
 isbn = {0-89791-327-2},
 location = {New York City, New York, USA},
 pages = {320--324},
 url = {http://doi.acm.org/10.1145/75144.75188},
 doi = {10.1145/75144.75188},
 acmid = {75188},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@article{Pantazos2013uVis,
abstract = {A toolkit facilitates the visualization development process. The process can be further enhanced by integrating the toolkits in development environments. This paper describes how the uVis toolkit, a formula-based visualiza- tion toolkit, has been extended with a development environment, called uVis Studio. Instead of programming, developers apply a Drag-Drop-Set-View-Interact approach. Developers bind controls to data, and the Studio gives immediate visual feedback in the Design Panel. This is a novel feature, called What-You-Bind-Is-What- You-Get. The Studio also provides Modes that allow developers to interact and view the visualization from the end-user's perspective without switching workspace, and Auto-Completion; a feature of the Property Grid that provides suggestions not only for the formula language syntax but also for the tables, the table elds and the relationships in the database. We conducted a usability study with six developers to evaluate if the Studio and its features enhance cognition and facilitate the visualization development. The results show that developers appreciated the Drag-Drop-Set- View-Interact approach, the What-You-Bind-Is-What-You-Get, the Auto-Completion and the Modes. Several usability problems were identified, and some suggestions for improvement include: new panels, better presentation of the Modes, and better error messages.},
author = {Pantazos, Kostas and Kuhail, Mohammad A. and Lauesen, Soren and Xu, Shangjin},
doi = {10.1117/12.2003067},
file = {::},
journal = {Visualization and Data Analysis 2013},
keywords = {information visualization,integrated development environment,tool,visualization development,what-,you-bind-is-what-you-get},
mendeley-tags = {tool},
pages = {86540L},
title = {{uVis Studio: an integrated development environment for visualization}},
volume = {8654},
year = {2013}
}
@inproceedings{dong2019impact,
author = {Dong, Tao and Khandwala, Kandarp},
booktitle = {Extended Abstracts of the 2019 CHI Conference on Human Factors in Computing Systems},
doi = {10.1145/3290607.3312978},
file = {::},
isbn = {9781450359719},
keywords = {Error message,developer experience,empirical,enhancement,experiment,presentation technique,programming},
mendeley-tags = {empirical,enhancement},
pages = {1--6},
title = {{The Impact of "Cosmetic" Changes on the Usability of Error Messages}},
year = {2019}
}
@inproceedings{carlson2017type,
abstract = {The work presented here reformulates type qualifiers as composable language extensions that can be automatically and reliably composed by the end-user programmer. Type expressions can be annotated with type qualifiers to specify new subtyping relations that are expressive enough to detect many kinds of programming errors. Type qualifiers, as illustrated in our ABLEC extensible language framework for C, can also introduce rich forms of concrete syntax, can generate dynamic checks on data when static checks are infeasible or not appropriate, and can inject generated code that affects program behavior, for example to log or display program execution or for the run-time conversion of data. The ABLEC framework and extensions to it are implemented using context-free grammars and attribute grammars. This provides an expressive mechanism for type qualifier implementations to check for additional errors, e.g.dereferences to pointers not qualified by a nonnull qualifier, and generate custom and informative error messages. This approach distinguishes programmers that use language extensions from language engineers that develop extensions. The framework provides modular analyses that extension developers use to ensure that their extension will compose with other extensions that all pass these analyses. Thus, when a programmer selects a set of extensions to use they will automatically and reliably compose to form a working translator for the extended language.},
address = {New York, New York, USA},
author = {Carlson, Travis and {Van Wyk}, Eric},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences - GPCE 2017},
doi = {10.1145/3136040.3136055},
file = {::},
isbn = {9781450355247},
issn = {1045926X},
keywords = {Extensible languages,Pluggable types,Type qualifiers,Type systems,enhancement,technical},
mendeley-tags = {enhancement,technical},
pages = {91--103},
publisher = {ACM Press},
title = {{Type qualifiers as composable language extensions}},
url = {http://dl.acm.org/citation.cfm?doid=3136040.3136055},
year = {2017}
}

@article{jeffery2003generating,
abstract = {LR parser generators are powerful and well-understood, but the parsers they generate are not suited to provide good error messages. Many compilers incur extensive modifications to the source grammar to produce useful syntax error messages. Interpreting the parse state (and input token) at the time of error is a nonintrusive alternative that does not entangle the error recovery mechanism in error message production. Unfortunately, every change to the grammar may significantly alter the mapping from parse states to diagnostic messages, creating a maintenance problem.Merr is a tool that allows a compiler writer to associate diagnostic messages with syntax errors by example, avoiding the need to add error productions to the grammar or interpret integer parse states. From a specification of errors and messages, Merr runs the compiler on each example error to obtain the relevant parse state and input token, and generates a yyerror() function that maps parse states and input tokens to diagnostic messages. Merr enables useful syntax error messages in LR-based compilers in a manner that is robust in the presence of grammar changes.},
author = {Jeffery, Clinton L.},
doi = {10.1145/937563.937566},
file = {::},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {technical},
mendeley-tags = {technical},
number = {5},
pages = {631--640},
title = {{Generating LR syntax error messages from examples}},
volume = {25},
year = {2003}
}

@article{burgess1972compile-time,
author = {Burgess, C. J.},
doi = {10.1093/comjnl/15.4.302},
file = {::},
issn = {00104620},
journal = {Computer Journal},
keywords = {difficulties,technical},
mendeley-tags = {difficulties,technical},
title = {{COMPILE-TIME ERROR DIAGNOSTICS IN SYNTAX-DIRECTED COMPILERS.}},
year = {1972}
}

@inproceedings{frisch2002semantic,
abstract = {Usually subtyping relations are defined either syntactically by a formal system or semantically by an interpretation of types in an untyped denotational model. In this work we show how to define a subtyping relation semantically, for a language whose operational semantics is driven by types; we consider a rich type algebra, with product, arrow, recursive, intersection, union and complement types. Our approach is to bootstrap the subtyping relation through a notion of set-theoretic model of the type algebra. The advantages of the semantic approach are manifold. Foremost we get for free many properties (e.g., the transitivity of subtyping) that, with axiomatized subtyping, would require tedious and error prone proofs. Equally important is that the semantic approach allows one to derive complete algorithms for the subtyping relation or the propagation of types through patterns. As the subtyping relation has a natural (inasmuch as semantic) interpretation, the type system can give informative error messages when static type-checking fails. Last but not least the approach has an immediate impact in the definition and the implementation of languages manipulating XML documents, as this was our original motivation.},
author = {Frisch, Alain and Castagna, Giuseppe and Benzaken, V{\'{e}}ronique},
booktitle = {Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},
doi = {10.1109/LICS.2002.1029823},
file = {::},
isbn = {0-7695-1483-9},
issn = {10436871},
keywords = {technical},
mendeley-tags = {technical},
pages = {137--146},
publisher = {IEEE Comput. Soc},
title = {{Semantic subtyping}},
url = {http://ieeexplore.ieee.org/document/1029823/},
year = {2002}
}

@article{DAntoni2016noFAQ,
abstract = {Command-line tools are confusing and hard to use for novice programmers due to their cryptic error messages and lack of documentation. Novice users often resort to online help-forums for finding corrections to their buggy commands, but have a hard time in searching precisely for posts that are relevant to their problem and then applying the suggested solutions to their buggy command. We present a tool, NoFAQ, that uses a set of rules to suggest possible fixes when users write buggy commands that trigger commonly occurring errors. The rules are expressed in a language called FixIt and each rule pattern-matches against the user's buggy command and the corresponding error message, and uses these inputs to produce a possible fixed command. Our main contribution is an algorithm based on lazy VSA for synthesizing FixIt rules from examples of buggy and repaired commands. The algorithm allows users to add new rules in NoFAQ without having to manually encode them. We present the evaluation of NoFAQ on 92 benchmark problems and show that NoFAQ is able to instantly synthesize rules for 81 benchmark problems in real time using just 2 to 5 input-output examples for each rule.},
archivePrefix = {arXiv},
arxivId = {1608.08219},
author = {D'Antoni, Loris and Singh, Rishabh and Vaughn, Michael},
eprint = {1608.08219},
file = {::},
journal = {2017 11th Joint Meeting on Foundations of Software Engineering},
keywords = {enhancement},
mendeley-tags = {enhancement},
pages = {1--15},
title = {{NoFAQ: Synthesizing Command Repairs from Examples}},
url = {http://arxiv.org/abs/1608.08219},
year = {2016}
}

@article{Heiner2009,
abstract = {Students in introductory programming classes often articulate their questions and information needs incompletely. Consequently, the automatic classification of student questions to provide automated tutorial responses is a challenging problem. This paper analyzes 411 questions from an introductory Java programming course by reducing the natural language of the questions to a vector space, and then utilizing cosine similarity to identify similar previous questions. We report classification accuracies between 23% and 55%, obtaining substantial improvements by exploiting domain knowledge (compiler error messages) and educational context (assignment name). Our mean reciprocal rank scores are comparable to and arguably better than most scores reported in a major information retrieval competition, even though our dataset consists of questions asked by students that are difficult to classify. Our results are especially timely and relevant for online courses where students are completing the same set of assignments asynchronously and access to staff is limited.},
author = {Heiner, Cecily and Zachary, Jl},
file = {::},
isbn = {9788461323081},
journal = {International Working Group on Educational Data Mining.},
keywords = {errors-only},
mendeley-tags = {errors-only},
pages = {259--268},
title = {{Improving Student Question Classification}},
url = {http://www.educationaldatamining.org/EDM2009/uploads/proceedings/heiner.pdf},
year = {2009}
}
@article{chargueraud2015improving,
abstract = {Cryptic type error messages are a major obstacle to learning OCaml or other ML-based languages. In many cases, error messages cannot be interpreted without a sufficiently-precise model of the type inference algorithm. The problem of improving type error messages in ML has received quite a bit of attention over the past two decades, and many different strategies have been considered. The challenge is not only to produce error messages that are both sufficiently concise and systematically useful to the programmer, but also to handle a full-blown programming language and to cope with large-sized programs efficiently. In this work, we present a modification to the traditional ML type inference algorithm implemented in OCaml that, by significantly reducing the left-to-right bias, allows us to report error messages that are more helpful to the programmer. Our algorithm remains fully predictable and continues to produce fairly concise error messages that always help making some progress towards fixing the code. We implemented our approach as a patch to the OCaml compiler in just a few hundred lines of code. We believe that this patch should benefit not just to beginners, but also to experienced programs developing large-scale OCaml programs.},
author = {Chargu{\'{e}}raud, Arthur},
doi = {10.4204/eptcs.198.4},
file = {::},
journal = {Electronic Proceedings in Theoretical Computer Science},
keywords = {technical},
mendeley-tags = {technical},
pages = {80--97},
title = {{Improving Type Error Messages in OCaml}},
volume = {198},
year = {2015}
}

@inproceedings{jackson2005identifying,
 abstract = {All freshmen at the United States Military Academy take an introductory programming course. We use a custom-built integrated development environment to help teach Java. During previous work, we implemented an integrated semantic and syntax error pre-processing system to help novice programmers decipher the otherwise cryptic compiler error messages in order for them to focus more on design issues than implementation issues. The syntactic errors that we checked were gathered by an informal survey of the current and former faculty members teaching the course. We noticed over the course of the year that there were discrepancies between the errors that the instructors had identified and the errors that the students were encountering. In response, we developed a real-time, automated error collection system that logged 100\% of the Java errors in a central database that all users, students and faculty alike, encountered while using the integrated development environment over the course of a semester. This paper discusses the implementation and results of our system as well as the implications for novice programmers},
 author = {Jackson, J. and Cobb, M. and Carver, C.},
 doi = {10.1109/fie.2005.1611967},
 isbn = {0780385527},
 booktitle = {35th Annual Frontiers in Education Conference},
 series = {FIE '05},
 mendeley-tags = {enhancement},
 title = {{Identifying Top Java Errors for Novice Programmers}},
 pages = {T4C-24 -- T4C-27},
 year = {2005}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Overlapping Papers
%%NO PAPERS SHOULD BE ADDED TO THIS SECTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@article{moulton1967ditran,
abstract = {DITRAN (Diagnostic FORTRAN) is an implementation of ASA Basic FORTRAN with rather extensive error checking capabilities both at compilation time and during execution of a program. The need for improved diagnostic capabilities and some objectives to be met by any compiler are discussed. Attention is given to the design and implementation of DITRAN and the particular techniques employed to provide the diagnostic features. The handling of error messages by a general macro approach is described. Special features which provide teaching aids for use by instructors are noted.},
author = {Moulton, P. G. and Muller, M. E.},
doi = {10.1145/363018.363060},
file = {::},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {difficulties,empirical,enhancement,pre-guidelines},
mendeley-tags = {difficulties,empirical,enhancement,pre-guidelines},
number = {1},
pages = {45--52},
title = {{DITRAN - A Compiler Emphasizing Diagnostics}},
volume = {10},
year = {1967}
}

@inproceedings{murphy2008backstop,
 abstract = {The errors that Java programmers are likely to encounter can roughly be categorized into three groups: compile-time (semantic and syntactic), logical, and runtime (exceptions). While much work has focused on the first two, there are very few tools that exist for interpreting the sometimes cryptic messages that result from runtime errors. Novice programmers in particular have difficulty dealing with uncaught exceptions in their code and the resulting stack traces, which are by no means easy to understand. We present Backstop, a tool for debugging runtime errors in Java applications. This tool provides more user-friendly error messages when an uncaught exception occurs, and also provides debugging support by allowing users to watch the execution of the program and the changes to the values of variables. We also present the results of two preliminary studies conducted on introductory-level programmers using the two different features of the tool.},
 mendeley-tags = {difficulties,empirical,enhancement,guidelines,runtime-errors,tool},
 author = {Murphy, Christian and Kim, Eunhee and Kaiser, Gail and Cannon, Adam},
 title = {Backstop: A Tool for Debugging Runtime Errors},
 booktitle = {Proceedings of the 39th SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '08},
 year = {2008},
 isbn = {978-1-59593-799-5},
 location = {Portland, OR, USA},
 pages = {173--177},
 url = {http://doi.acm.org/10.1145/1352135.1352193},
 doi = {10.1145/1352135.1352193},
 acmid = {1352193},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {debugging, exception handling},
}

@inproceedings{marceau2011mind,
 abstract = {Error messages are one of the most important tools that a language offers its programmers. For novices, this feed-back is especially critical. Error messages typically contain both a textual description of the problem and an indication of where in the code the error occurred. This paper reports on a series of studies that explore beginning students' inter-actions with the vocabulary and source-expression high-lighting in DrRacket. Our findings demonstrate that the error message significantly fail to convey information accurately to students, while also suggesting alternative designs that might address these problems.},
 mendeley-tags = {difficulties,guidelines},
 author = {Marceau, Guillaume and Fisler, Kathi and Krishnamurthi, Shriram},
 title = {Mind Your Language: On Novices' Interactions with Error Messages},
 booktitle = {Proceedings of the 10th SIGPLAN Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
 series = {Onward! 2011},
 year = {2011},
 isbn = {978-1-4503-0941-7},
 location = {Portland, Oregon, USA},
 pages = {3--18},
 url = {http://doi.acm.org/10.1145/2048237.2048241},
 doi = {10.1145/2048237.2048241},
 acmid = {2048241},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {beginner-friendly ides, error message design, novice programmers, user-studies},
}

@inproceedings{wrenn2017error,
 abstract = {This paper presents a lightweight process to guide error report authoring. We take the perspective that error reports are really classifiers of program information. They should therefore be subjected to the same measures as other classifiers (e.g., precision and recall). We formalize this perspective as a process for assessing error reports, describe our application of this process to an actual programming language, and present a preliminary study on the utility of the resulting error reports.},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Wrenn, Krishnamurthi - 2017 - Error messages are classifiers a process to design and evaluate error messages.pdf:pdf},
 mendeley-tags = {empirical,enhancement,pre-guidelines,technical},
 author = {Wrenn, John and Krishnamurthi, Shriram},
 title = {Error Messages Are Classifiers: A Process to Design and Evaluate Error Messages},
 booktitle = {Proceedings of the 2017 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
 series = {Onward! 2017},
 year = {2017},
 isbn = {978-1-4503-5530-8},
 location = {Vancouver, BC, Canada},
 pages = {134--147},
 url = {http://doi.acm.org/10.1145/3133850.3133862},
 doi = {10.1145/3133850.3133862},
 acmid = {3133862},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Pyret, classifiers, error messages, highlighting, precision and recall},
}

@inproceedings{marceau2011measuring,
 abstract = {Good error messages are critical for novice programmers. Re-cognizing this, the DrRacket programming environment provides a series of pedagogically-inspired language subsets with error messages customized to each subset. We apply human-factors research methods to explore the effectiveness of these messages. Unlike existing work in this area, we study messages at a fine-grained level by analyzing the edits students make in response to various classes of errors. We present a rubric (which is not language specific) to evaluate student responses, apply it to a course-worth of student lab work, and describe what we have learned about using the rubric effectively. We also discuss some concrete observations on the effectiveness of these messages.},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Marceau, Fisler, Krishnamurthi - 2011 - Measuring the effectiveness of error messages designed for novice programmers.pdf:pdf},
 mendeley-tags = {difficulties,empirical,guidelines},
 author = {Marceau, Guillaume and Fisler, Kathi and Krishnamurthi, Shriram},
 title = {Measuring the Effectiveness of Error Messages Designed for Novice Programmers},
 booktitle = {Proceedings of the 42nd ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '11},
 year = {2011},
 isbn = {978-1-4503-0500-6},
 location = {Dallas, TX, USA},
 pages = {499--504},
 url = {http://doi.acm.org/10.1145/1953163.1953308},
 doi = {10.1145/1953163.1953308},
 acmid = {1953308},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {error messages, novice programmers, user-studies},
}

@article{suhailan2014perspective,
 abstract = {Programming tools are meant for student to practice programming. Automated programming error feedback will be provided for students to self-construct the knowledge through their own experience. This paper has clustered current approaches in providing automated error programming feedback to the students during problem solving exercises. These include additional syntax error messages, solution template mismatches, test data comparison, assisted agent report and collaborative comment feedback. The study is conducted based on published papers for last two decades. The trends are analyzed to get the overview of latest research contributions towards eliminating programming difficulties among students. The result shows that future direction of automated programming error feedback approaches may combine agent and collaborative feedback approaches towards more interactive, dynamic, end-user oriented and specific goal oriented. Such future direction may help other researchers fill in the gap on new ways of assisting learners to better understand feedback messages provided by automated assessment tool.},
 author = {Suhailan, S and Samad, S Abdul and Burhanuddin, M A},
 file = {::},
 issn = {1817-3195},
 journal = {Journal of Theoretical and Applied Information Technology},
 keywords = {Automated Programming Error Feedback,Computer Aided Learning System,Programming Language,difficulties,e-Learning},
 mendeley-tags = {difficulties,guidelines,justification,pedagogy},
 number = {1},
 pages = {121--129},
 title = {{A Perspective of Automated Programming Error Feedback Approaches in Problem Solving Exercises}},
 url = {http://www.jatit.org/volumes/Vol70No1/16Vol70No1.pdf},
 volume = {70},
 year = {2014}
}

@inproceedings{barik2017do,
 abstract = {In integrated development environments, developers receive compiler error messages through a variety of textual and visual mechanisms, such as popups and wavy red underlines. Although error messages are the primary means of communicating defects to developers, researchers have a limited understanding on how developers actually use these messages to resolve defects. To understand how developers use error messages, we conducted an eye tracking study with 56 participants from undergraduate and graduate software engineering courses at our university. The participants attempted to resolve common, yet problematic defects in a Java code base within the Eclipse development environment. We found that: 1) participants read error messages and the difficulty of reading these messages is comparable to the difficulty of reading source code, 2) difficulty reading error messages significantly predicts participants' task performance, and 3) participants allocate a substantial portion of their total task to reading error messages (13\%--25\%). The results of our study offer empirical justification for the need to improve compiler error messages for developers.},
 mendeley-tags = {empirical,justification},
 author = {Barik, Titus and Smith, Justin and Lubick, Kevin and Holmes, Elisabeth and Feng, Jing and Murphy-Hill, Emerson and Parnin, Chris},
 title = {Do Developers Read Compiler Error Messages?},
 booktitle = {Proceedings of the 39th International Conference on Software Engineering},
 series = {ICSE '17},
 year = {2017},
 isbn = {978-1-5386-3868-2},
 location = {Buenos Aires, Argentina},
 pages = {575--585},
 url = {https://doi.org/10.1109/ICSE.2017.59},
 doi = {10.1109/ICSE.2017.59},
 acmid = {3097437},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 keywords = {compiler errors, eye tracking, integrated development environments, programmer comprehension, reading, visual attention},
}

@inproceedings{denny2014enhancing,
 abstract = {Debugging is an important skill for novice programmers to acquire. Error messages help novices to locate and correct errors, but compiler messages are frequently inadequate. We have developed a system that provides enhanced error messages, including concrete examples that illustrate the kind of error that has occurred and how that kind of error could be corrected. We evaluate the effectiveness of the enhanced error messages with a controlled empirical study and find no significant effect.},
 mendeley-tags = {empirical,enhancement},
 author = {Denny, Paul and Luxton-Reilly, Andrew and Carpenter, Dave},
 title = {Enhancing Syntax Error Messages Appears Ineffectual},
 booktitle = {Proceedings of the 19th Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '14},
 year = {2014},
 isbn = {978-1-4503-2833-3},
 location = {Uppsala, Sweden},
 pages = {273--278},
 url = {http://doi.acm.org/10.1145/2591708.2591748},
 doi = {10.1145/2591708.2591748},
 acmid = {2591748},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {debugging, error messages, errors, feedback, novice, programming, syntax error},
} 


@inproceedings{whittall2017codemage,
abstract = {CodeMage is an interactive educational programming environment targeted at novice Java programmers who have little knowledge in basic programming. The system comes with innovative features such as, real-time guidance and reviews, code generation tool, visual debugger, hinting system for best practices, remote tutor and database manipulation tool which makes it a unique educational programming environment. Though many of programming tools are available in the market, they have their drawbacks in suitability to be adopted in programming by beginners due to the complexity in software interface, cryptic error messages and warning messages, no adequate support to fix errors and not adhering to real-world programming context etc. CodeMage is an attempt to overcome above problems and change how novices perceive and practice Java programming around the world and it is working as expected.},
author = {Whittall, S. J. and Prashandi, W. A.C. and Himasha, G. L.S. and {De Silva}, D. I. and Suriyawansa, T. K.},
booktitle = {2017 9th International Conference on Knowledge and Smart Technology: Crunching Information of Everything, KST 2017},
doi = {10.1109/KST.2017.7886101},
file = {::;::},
isbn = {9781467390774},
keywords = {Educational programming environment,Novice programmers,anecdotal,difficulties,enhancement,pedagogy},
mendeley-tags = {anecdotal,difficulties,enhancement,pedagogy},
month = {Feb},
pages = {311--316},
publisher = {IEEE},
title = {{CodeMage: Educational programming environment for beginners}},
url = {http://ieeexplore.ieee.org/document/7886101/},
year = {2017}
}

@inproceedings{becker2018effects,
 abstract = {There is an active strand of research in the literature exploring the effects of Enhanced Compiler Error Messages on student programming behavior, however many results seem conflicting. This is compounded by the fact that directly comparing these results is difficult as these studies utilize different metrics, and what metrics are best suited to measure the effects of enhanced compiler error messages is not known. Common to most studies to-date is that the metrics employed measure how many errors students produce, and/or rectify while writing programs. This study takes a different approach by measuring how many pre-existing syntax errors are rectified by students while debugging programs. Specifically, we measured the effect of enhanced compiler error messages in an empirical control/intervention experiment where students were given the task of removing syntax errors from non-compiling source code they did not write. We find a significant positive effect on the overall number of errors rectified, as well as the number of certain specific error types, but no significant effect on the number of non-compiling submissions or student scores. These results (in different ways) support the findings of several recent studies and suggest that their results may not be as conflicting as they seem. This is evidence that enhanced error messages may be effective, but also that the signal of these effects are relatively weak, indicating that how and what is measured when attempting to observe these effects is important.},
 mendeley-tags = {difficulties,empirical,enhancement,guidelines,justification,pedagogy,performance},
 author = {Becker, Brett A. and Goslin, Kyle and Glanville, Graham},
 title = {The Effects of Enhanced Compiler Error Messages on a Syntax Error Debugging Test},
 booktitle = {Proceedings of the 49th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '18},
 year = {2018},
 isbn = {978-1-4503-5103-4},
 location = {Baltimore, Maryland, USA},
 pages = {640--645},
 url = {http://doi.acm.org/10.1145/3159450.3159461},
 doi = {10.1145/3159450.3159461},
 acmid = {3159461},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, Java, compiler error messages, debugging, enhanced compiler error messages, novice programmers, syntax error messages},
}

@article{munson2015analyzing,
abstract = {Error messages represent a critical feedback mechanism provided to introductory programming students during their early attempts at programming. However, these messages are explanations of program-translation problems, rather than true feedback on mistakes in a students program. This mismatch presents problems for novices, while experts are able to make more appropriate use of compiler error messages. Programming activity logs generated by an instructional programming environment were analyzed for students' utilization of error messages in their edits prior to each compilation. Overall, students addressed the first error about half the time. Assignment grades were positively associated with the proportion of times that the first error message was addressed.},
author = {Munson, Jonathan P and Schilling, Elizabeth A},
file = {::;::;::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//Munson, Schilling - 2015 - ANALYZING NOVICE PROGRAMMERS' RESPONSE TO COMPILER ERROR MESSAGES.pdf:pdf},
journal = {Journal of Computing Sciences in Colleges},
keywords = {difficulties,empirical,errors-only},
mendeley-tags = {difficulties,empirical,errors-only},
number = {3},
pages = {53--61},
title = {{Analyzing novice programmers' response to compiler error messages}},
url = {http://users.csc.calpoly.edu/$\sim$phatalsk/references/},
volume = {31},
year = {2016}
}
@inproceedings{gray2003professorj,
abstract = {In the second-semester programming course at the University of Utah, we have observed that our students suffer unnecessarily from a mismatch between the course content and the programming environment. The course is typical, in that it exposes students to Java a little at a time. The programming environments are also typical, in that they report compilation and run-time errors in the jargon of professional programmers who use the full Java language. As a result, students rely heavily on teaching assistants to interpret error messages, and valuable classroom time is wasted on syntactic diversions. ProfessorJ is our new programming environment that remedies this problem. Like other pedagogical environments, such as BlueJ and DrJava, ProfessorJ presents the student with a simplified interface to the Java compiler and virtual machine. Unlike existing environments, ProfessorJ tailors the Java language and error messages to the students' needs. Since their needs evolve through the course, ProfessorJ offers several language levels, from Beginner Java to Full Java.},
address = {Anaheim, CA, USA},
author = {Gray, Kathryn E and Flatt, Matthew},
booktitle = {18th Annual ACM SIGPLAN Conference on Object-oriented Programming, Systems, Languages, and Applications},
doi = {10.1145/949344.949394},
file = {::},
keywords = {Computer science education,Human Factors,Languages,difficulties,enhancement,pedagogy,tool},
mendeley-tags = {difficulties,enhancement,pedagogy,tool},
pages = {170----177},
publisher = {ACM},
title = {{ProfessorJ: A Gradual Introduction to Java Through Language Levels}},
url = {http://doi.acm.org/10.1145/949344.94939},
year = {2003}
}
@inproceedings{isa1983methodology,
 abstract = {Message quality is a critical factor in influencing user acceptance of a program product. Good error messages can reduce the time and cost to create and maintain software, as well as help users learn about the product. We have developed a methodology for conducting controlled usability evaluations of error messages. The Message Test Program is easily modified to adapt to different product situations, and messages can be evaluated even before working code exists. The Message Test Program can be used to test error messages for a batch product, as well as messages for an interactive product. It can also be used for stand-alone messages, for products that offer on-line help, or messages that provide additional information in a reference manual. Message testing enables us to objectively evaluate error messages and provide specific feedback about the difficulties users encounter and how error messages can be improved.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Isa et al. - 1983 - A Methodology for Objectively Evaluating Error Messages.pdf:pdf},
 mendeley-tags = {empirical,guidelines,pre-guidelines,technical},
 author = {Isa, Barbara S. and Boyle, James M. and Neal, Alan S. and Simons, Roger M.},
 title = {A Methodology for Objectively Evaluating Error Messages},
 booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
 series = {CHI '83},
 year = {1983},
 isbn = {0-89791-121-0},
 location = {Boston, Massachusetts, USA},
 pages = {68--71},
 url = {http://doi.acm.org/10.1145/800045.801583},
 doi = {10.1145/800045.801583},
 acmid = {801583},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@inproceedings{luoma2007clip,
 abstract = {C++ is not the best choice for a first programming language, but if it is used, the learning circumstances need to be as easy as possible. We have developed a pedagogically designed interpreter for this purpose. Our hypothesis is that an interpreter is easier than a compiler for a novice programmer to use. We do not want students to use language properties they do not yet fully understand, so our approach is imperative-first. In addition, when using an interpreter, learning concepts such as libraries can be postponed until later in the course. C++ is a complex language and most of its language features are not needed by a novice programmer. Therefore we have simplified the language to a subset of C++ that we call C-. For instance, classes have been omitted. We have also put a lot of effort into producing clear, informative error messages, something that is made possible by of the simpler programming language. This article introduces some other C/C++ interpreters , their evaluation, and the description of our interpreter called CLIP. So far CLIP has not been used by students, so its evaluation is left as future work.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Luoma, Lahtinen, Jarvinen - 2007 - CLIP, a Command Line InterPreter for a subset of C.pdf:pdf},
 mendeley-tags = {anecdotal,difficulties,enhancement,justification,pedagogy,pre-guidelines,technical},
 author = {Luoma, Harri and Lahtinen, Essi and J\"{a}rvinen, Hannu-Matti},
 title = {CLIP, a Command Line Interpreter for a Subset of C++},
 booktitle = {Proceedings of the Seventh Baltic Sea Conference on Computing Education Research - Volume 88},
 series = {Koli Calling '07},
 year = {2007},
 isbn = {978-1-920682-69-9},
 location = {Koli National Park, Finland},
 pages = {199--202},
 url = {http://dl.acm.org/citation.cfm?id=2449323.2449351},
 acmid = {2449351},
 publisher = {Australian Computer Society, Inc.},
 address = {Darlinghurst, Australia, Australia},
 keywords = {C++, education, interpreter, novice programmers},
}

@inproceedings{kohn2019error,
 abstract = {The interaction between a novice programmer, and the compiler plays a crucial role in the learning process of the novice programmer. Of particular importance is the compiler's feedback on errors in the program code. Accordingly, compiler error messages are an important and active field of research. Yet, a language that has largely been left out of this discussion so far is Python. We have collected Python programs from high school students taking introductory courses. For each collected erroneous program, we sought to classify the effective error, and assess if the student was able to fix the error. Our study is a precursor to providing improved error messages in Python, and assess their effectiveness. As such, we are eventually interested in finding ways to automatically determine the effective error, so as to base the displayed message on. From our data, we found that a considerable part of students' errors can be attributed to minor mistakes, which can easily be identified and corrected. However, beyond such minor mistakes, a proper error diagnosis might have to be based on a goal/plan analysis of the entire program. Likewise, proper assessment of whether an error has been fixed frequently requires more context than is provided by the program alone.},
 mendeley-tags = {difficulties,empirical},
 author = {Kohn, Tobias},
 title = {The Error Behind The Message: Finding the Cause of Error Messages in Python},
 booktitle = {Proceedings of the 50th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '19},
 year = {2019},
 isbn = {978-1-4503-5890-3},
 location = {Minneapolis, MN, USA},
 pages = {524--530},
 url = {http://doi.acm.org/10.1145/3287324.3287381},
 doi = {10.1145/3287324.3287381},
 acmid = {3287381},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {cem, compiler errors, error message, python},
}

@inproceedings{prather2017novices,
 abstract = {The difficulty in understanding compiler error messages can be a major impediment to novice student learning. To alleviate this issue, multiple researchers have run experiments enhancing compiler error messages in automated assessment tools for programming assignments. The conclusions reached by these published experiments appear to be conflicting. We examine these experiments and propose five potential reasons for the inconsistent conclusions concerning enhanced compiler error messages: (1) students do not read them, (2) researchers are measuring the wrong thing, (3) the effects are hard to measure, (4) the messages are not properly designed, (5) the messages are properly designed, but students do not understand them in context due to increased cognitive load. We constructed mixed-methods experiments designed to address reasons 1 and 5 with a specific automated assessment tool, Athene, that previously reported inconclusive results. Testing student comprehension of the enhanced compiler error messages outside the context of an automated assessment tool demonstrated their effectiveness over standard compiler error messages. Quantitative results from a 60 minute one-on-one think-Aloud study with 31 students did not show substantial increase in student learning outcomes over the control. However, qualitative results from the one-on-one thinkaloud study indicated that most students are reading the enhanced compiler error messages and generally make effective changes after encountering them.},
 mendeley-tags = {empirical,enhancement,pedagogy,pre-guidelines,tool},
 author = {Prather, James and Pettit, Raymond and McMurry, Kayla Holcomb and Peters, Alani and Homer, John and Simone, Nevan and Cohen, Maxine},
 title = {On Novices' Interaction with Compiler Error Messages: A Human Factors Approach},
 booktitle = {Proceedings of the 2017 ACM Conference on International Computing Education Research},
 series = {ICER '17},
 year = {2017},
 isbn = {978-1-4503-4968-0},
 location = {Tacoma, Washington, USA},
 pages = {74--82},
 url = {http://doi.acm.org/10.1145/3105726.3106169},
 doi = {10.1145/3105726.3106169},
 acmid = {3106169},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, HCI, automated assessment tools, education, ethnography, human factors, usability},
}

@inproceedings{mccall2014meaningful,
 abstract = {The frequency of different kinds of error made by students learning to write computer programs has long been of interest to researchers and educators. In the past, various studies investigated this topic, usually by recording and analysing compiler error messages, and producing tables of relative frequencies of specific errors diagnostics produced by the compiler. In this paper, we improve on such prior studies by investigating actual logical errors in student code, as opposed to diagnostic messages produced by the compiler. The actual errors reported here are more precise, more detailed and more accurate than the diagnostic produced automatically.},
 author = {McCall, Davin and K{\"{o}}lling, Michael},
 booktitle = {IEEE Frontiers in Education Conference},
 series = {FIE '14},
 doi = {10.1109/FIE.2014.7044420},
 issn = {15394565},
 keywords = {Java,difficulties,empirical,errors,justification,novices,programming},
 mendeley-tags = {difficulties,empirical,justification},
 pages = {1--8},
 title = {{Meaningful Categorisation of Novice Programmer Errors}},
 year = {2014}
}

@inproceedings{heeren2004helium,
 abstract = {Helium is a user-friendly compiler designed especially for learning the functional programming language Haskell. The quality of the error messages has been the main concern both in the choice of the language features and in the implementation of the compiler. Helium implements almost full Haskell, where the most notable difference is the absence of type classes. Our goal is to let students learn functional programming more quickly and with more fun. The compiler has been successfully employed in two introductory programming courses at Utrecht University.},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Heeren, Leijen, van IJzendoorn - 2003 - Helium, for learning Haskell.pdf:pdf},
 mendeley-tags = {empirical,enhancement,technical},
 author = {Heeren, Bastiaan and Leijen, Daan and van IJzendoorn, Arjan},
 title = {Helium, for Learning Haskell},
 booktitle = {Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell},
 series = {Haskell '03},
 year = {2003},
 isbn = {1-58113-758-3},
 location = {Uppsala, Sweden},
 pages = {62--71},
 url = {http://doi.acm.org/10.1145/871895.871902},
 doi = {10.1145/871895.871902},
 acmid = {871902},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {education, error logging, error messages, learning Haskell, type inference},
}

@article{becker2016effectiveCSEJ,
 abstract = {Programming is an essential skill that many computing students are expected to master. However, programming can be difficult to learn. Successfully interpreting compiler error messages (CEMs) is crucial for correcting errors and progressing toward success in programming. Yet these messages are often difficult to understand and pose a barrier to progress for many novices, with struggling students often exhibiting high frequencies of errors, particularly repeated errors. This paper presents a control/intervention study on the effectiveness of enhancing Java CEMs. Results show that the intervention group experienced reductions in the number of overall errors, errors per student, and several repeated error metrics. These results are important as the effectiveness of CEM enhancement has been recently debated. Further, generalizing these results should be possible at least in part, as the control group is shown to be comparable to those in several studies using Java and other languages.},
 author = {Becker, Brett A. and Glanville, Graham and Iwashima, Ricardo and McDonnell, Claire and Goslin, Kyle and Mooney, Catherine},
 doi = {10.1080/08993408.2016.1225464},
 issn = {0899-3408},
 journal = {Computer Science Education},
 keywords = {CS1,Compiler errors,Java,compiler error enhancement,difficulties,empirical,enhancement,justification,novice programmers,pre-guidelines,syntax errors},
 mendeley-tags = {difficulties,empirical,enhancement,justification,pre-guidelines},
 number = {2-3},
 pages = {148--175},
 title = {{Effective Compiler Error Message Enhancement for Novice Programming Students}},
 url = {https://www.tandfonline.com/doi/full/10.1080/08993408.2016.1225464},
 volume = {26},
 year = {2016}
}

@inproceedings{hartmann2010what,
 abstract = {Interpreting compiler errors and exception messages is challenging for novice programmers. Presenting examples of how other programmers have corrected similar errors may help novices understand and correct such errors. This paper introduces HelpMeOut, a social recommender system that aids the debugging of error messages by suggesting solutions that peers have applied in the past. HelpMeOut comprises IDE instrumentation to collect examples of code changes that fix errors; a central database that stores fix reports from many users; and a suggestion interface that, given an error, queries the database for a list of relevant fixes and presents these to the programmer. We report on implementations of this architecture for two programming languages. An evaluation with novice programmers found that the technique can suggest useful fixes for 47% of errors after 39 person-hours of programming in an instrumented environment.},
 mendeley-tags = {empirical,enhancement,guidelines},
 author = {Hartmann, Bj\"{o}rn and MacDougall, Daniel and Brandt, Joel and Klemmer, Scott R.},
 title = {What Would Other Programmers Do: Suggesting Solutions to Error Messages},
 booktitle = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
 series = {CHI '10},
 year = {2010},
 isbn = {978-1-60558-929-9},
 location = {Atlanta, Georgia, USA},
 pages = {1019--1028},
 url = {http://doi.acm.org/10.1145/1753326.1753478},
 doi = {10.1145/1753326.1753478},
 acmid = {1753478},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {debugging, recommender systems},
}

@article{duboulay1984fatal,
 abstract = {All novice programmers find that their initial programs are rejected by the compiler in a flurry of incomprehensible error messages. Some messages are even hostile (e.g. fatal error in pass zero) and leave the novice sadder and certainly no wiser. The quality of error messages is usually the loser when the compiler writer attempts to balance conflicting design constraints such as size, speed, quality of target code and utility of use by competent programmers. We believe that novices? programs should be passed through a series of checkers which are designed to trap and comment on the particular kinds of errors made by them. Such systems may have to make several passes through the program, even to provide an apposite comment on a syntactic error. For logic checking such systems will need access to a description (in some form) of what the novice's program is supposed to do. Only when a novice's program passes through all the checkers successfully should it be submitted to the standard compiler. This paper surveys existing attempts to build ?intelligent? compilers which are considerate of novices? difficulties. It then describes our own progress towards the construction of program checkers for use by undergraduates learning Pascal.},
 author = {du Boulay, Benedict and Matthew, Ian},
 doi = {10.1080/01449298408901742},
 file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/du Boulay, Matthew - 1984 - Fatal error in pass zero How not to confuse novices.pdf:pdf},
 issn = {13623001},
 journal = {Behaviour and Information Technology},
 keywords = {pedagogy,technical},
 mendeley-tags = {pedagogy,technical},
 number = {2},
 pages = {109--118},
 title = {{Fatal Error in Pass Zero: How Not to Confuse Novices}},
 volume = {3},
 year = {1984}
}

@article{traver2010on,
 abstract = {Programmers often encounter cryptic compiler error messages that are difficult to understand and thus difficult to resolve. Unfortunately, most related disciplines, including compiler technology, have not paid much attention to this important aspect that affects programmers significantly, apparently because it is felt that programmers should adapt to compilers. In this article, however, this problem is studied from the perspective of the discipline of human-computer interaction to gain insight into why compiler errors messages make the work of programmers more difficult, and how this situation can be alleviated. Additionally, because poorly designed error messages affect novice programmers more adversely, the problems faced by computer science students while learning to program are analyzed, and the obstacles originated by compilers are identified. Examples of actual compiler error messages are provided and carefully commented. Finally, some possible measures that can be taken are outlined, and some principles for compiler error message design are included.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Traver - 2010 - On Compiler Error Messages What They Say and What They Mean.pdf:pdf},
 journal = {Advances in Human-Computer Interaction},
 mendeley-tags = {difficulties,guidelines,justification,pedagogy,technical},
 author = {Traver, V. Javier},
 title = {On Compiler Error Messages: What They Say and What They Mean},
 issue_date = {January 2010},
 volume = {2010},
 month = jan,
 year = {2010},
 issn = {1687-5893},
 pages = {3:1--3:26},
 articleno = {3},
 numpages = {26},
 url = {http://dx.doi.org/10.1155/2010/602570},
 doi = {10.1155/2010/602570},
 acmid = {1945532},
 publisher = {Hindawi Publishing Corp.},
 address = {New York, NY, United States},
}

@inproceedings{hasker2002hic,
abstract = {In CS1 courses, students must often use professional environments to develop programs. Students often find these difficult to use because error messages involve terms they do not understand. Professional systems must support the entire language, so messages must use terms which ensure both accuracy and brevity. This is a particular problem in C++. This paper presents a solution based on identifying a subset of C++ which is appropriate for introductory students. It also presents a development environment based on this subset, HiC, and our experiences in using HiC in a CS1 course.},
author = {Hasker, Robert W},
booktitle = {CCSC: Midwestern Conference JCSC 18, 1 (October 2002) 2.},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Hasker - 2002 - HiC A C COMPILER FOR CS1.pdf:pdf},
keywords = {enhancement,pedagogy},
mendeley-tags = {enhancement,pedagogy},
pages = {56 -- 64},
title = {{HiC: A C++ COMPILER FOR CS1}},
year = {2002}
}

@inproceedings{barik2018should,
 abstract = {Compilers primarily give feedback about problems to developers through the use of error messages. Unfortunately, developers routinely find these messages to be confusing and unhelpful. In this paper, we postulate that because error messages present poor explanations , theories of explanation-such as Toulmin's model of argument-can be applied to improve their quality. To understand how compilers should present explanations to developers, we conducted a comparative evaluation with 68 professional software developers and an empirical study of compiler error messages found in Stack Overflow questions across seven different programming languages. Our findings suggest that, given a pair of error messages, developers significantly prefer the error message that employs proper argument structure over a deficient argument structure when neither offers a resolution-but will accept a deficient argument structure if it provides a resolution to the problem. Human-authored explanations on Stack Overflow converge to one of the three argument structures: those that provide a resolution to the error, simple arguments, and extended arguments that provide additional evidence for the problem. Finally, we contribute three practical design principles to inform the design and evaluation of compiler error messages. CCS CONCEPTS ¢ Human-centered computing â Empirical studies in HCI; ¢ Software and its engineering â Integrated and visual development environments;},
 mendeley-tags = {difficulties,empirical,enhancement,guidelines,pre-guidelines,technical},
 author = {Barik, Titus and Ford, Denae and Murphy-Hill, Emerson and Parnin, Chris},
 title = {How Should Compilers Explain Problems to Developers?},
 booktitle = {Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
 series = {ESEC/FSE 2018},
 year = {2018},
 isbn = {978-1-4503-5573-5},
 location = {Lake Buena Vista, FL, USA},
 pages = {633--643},
 url = {http://doi.acm.org/10.1145/3236024.3236040},
 doi = {10.1145/3236024.3236040},
 acmid = {3236040},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Stack Overflow, communication theory, compilers, debugging, error messages, explanations},
}


@inproceedings{uchida2016c-helper,
 abstract = {For better programming language education, it is crucial to make compiler warning messages more understandable for novice programmers. Unfortunately, however, Kojima's research showed warning messages in commercial-level compilers like GCC are still difficult to understand, and the commercial-level compilers tend not to emit how to modify programs to correct the problems. Furthermore, we found that they also tend not to handle latent errors. To solve this problem, by using a heuristic approach, we propose a novel C static checker called C-Helper, that aims to emit more direct error messages understandable for novices to correct wrong programs, and also aims to handle latent errors. Our preliminary evaluation shows that C-Helper was positively evaluated, although our heuristic approach increased false-positives.},
 mendeley-tags = {anecdotal,difficulties,empirical,enhancement,justification,technical,tool},
 author = {Uchida, Kota and Gondow, Katsuhiko},
 title = {C-Helper: C Latent-error Static/Heuristic Checker for Novice Programmers},
 booktitle = {Proceedings of the 8th International Conference on Computer Supported Education},
 series = {CSEDU 2016},
 year = {2016},
 isbn = {978-989-758-179-3},
 location = {Rome, Italy},
 pages = {321--329},
 url = {https://doi.org/10.5220/0005797703210329},
 doi = {10.5220/0005797703210329},
 acmid = {3096377},
 publisher = {SciTePress - Science and Technology Publications, Lda},
 address = {Portugal},
 keywords = {C Static Checker, Compiler Warning Messages, Heuristics, Latent Errors, Novice Programmer., Programming Education},
}

@article{brown1983error,
abstract = {The quality of error messages produced by software used in the field was tested by a simple experiment; it was found to be far from adequate. The re- sults of the experiment are ana- lyzed, and some responses which tend to collaborate the original findings are discussed. Finally, some suggestions are made for improving the quality of error messages.},
author = {Brown, P. J.},
doi = {10.1145/2163.358083},
file = {::},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {anecdotal,difficulties,empirical,justification,pre-guidelines},
mendeley-tags = {anecdotal,difficulties,empirical,justification,pre-guidelines},
month = { Apr},
number = {4},
pages = {246--249},
title = {{Error Messages: The Neglected Area of the Man/Machine Interface}},
url = {https://dl.acm.org/citation.cfm?id=358083 http://portal.acm.org/citation.cfm?doid=2163.358083},
volume = {26},
year = {1983}
}

@inproceedings{barik2014compiler,
abstract = {Error notifications and their resolutions, as presented by modern IDEs, are still cryptic and confusing to developers. We propose an interaction-first approach to help developers more effectively comprehend and resolve compiler error notifications through a conceptual interaction framework. We propose novel taxonomies that can serve as controlled vocabularies for compiler notifications and their resolutions. We use preliminary taxonomies to demonstrate, through a prototype IDE, how the taxonomies make notifications and their resolutions more consistent and unified.},
address = {Hyderabad, India},
author = {Barik, Titus and Witschey, Jim and Johnson, Brittany and Murphy-Hill, Emerson},
booktitle = {Companion Proceedings of the Conference on Software Engineering, ICSE},
doi = {10.1145/2591062.2591124},
file = {::;::},
isbn = {9781450327688},
keywords = {compiler error messages,enhancement,ide,taxonomy,tool,visualization},
mendeley-tags = {enhancement,tool},
pages = {536--539},
title = {{Compiler Error Notifications Revisited: An Interaction-First Approach for Helping Developers More Effectively Comprehend and Resolve Error Notification}},
year = {2014}
}

@inproceedings{pritchard2015frequency,
abstract = {Which programming error messages are the most common? We investigate this question, motivated by writing error explanations for novices. We consider large data sets in Python and Java that include both syntax and run-time errors. In both data sets, after grouping essentially identical messages, the error message frequencies empirically resemble Zipf-Mandelbrot distributions. We use a maximum-likelihood approach to fit the distribution parameters. This gives one possible way to contrast languages or compilers quantitatively.},
archivePrefix = {arXiv},
arxivId = {1509.07238v1},
author = {Pritchard, David},
booktitle = {Proceedings of the 6th Workshop on Evaluation and Usability of Programming Languages and Tools},
doi = {10.1145/nnnnnnn.nnnnnnn},
eprint = {1509.07238v1},
file = {::},
isbn = {1509.07238v1},
keywords = {D34 [Programming Language Processors]: Compilers,Run-time environments Keywords Error messages,difficulties,education,empirical,empirical analysis,error messages,runtime-errors,usability},
mendeley-tags = {difficulties,empirical,runtime-errors},
pages = {1--8},
title = {{Frequency Distribution of Error Messages}},
url = {http://dx.doi.org/10.1145/nnnnnnn.nnnnnnn http://arxiv.org/abs/1509.07238},
year = {2015}
}

@inproceedings{ahmed2018compilation,
 abstract = {Compile-time errors pose a major learning hurdle for students of introductory programming courses. Compiler error messages, while accurate, are targeted at seasoned programmers, and seem cryptic to beginners. In this work, we address this problem ofpedagogically- inspired program repair and report TRACER (Targeted RepAir of Compilation ERrors), a system for performing repairs on compilation errors, aimed at introductory programmers. TRACER invokes a novel combination of tools from program- ming language theory and deep learning and offers repairs that not only enable successful compilation, but repairs that are very close to those actually performed by students on similar errors. The ability to offer such targeted corrections, rather than just code that compiles, makes TRACER more relevant in offering real-time feedback to students in lab or tutorial sessions, as compared to existing works that merely offer a certain compilation success rate. In an evaluation on 4500 erroneous C programs written by students of a freshman year programming course, TRACER recom- mends a repair exactly matching the one expected by the student for 68\% of the cases, and in 79.27\% of the cases, produces a compilable repair. On a further set of 6971 programs that require errors to be fixed on multiple lines, TRACER enjoyed a success rate of 44\% compared to the 27\% success rate offered by the state-of-the-art technique DeepFix.},
 mendeley-tags = {difficulties,empirical,enhancement,justification,pedagogy,technical},
 author = {Ahmed, Umair Z. and Kumar, Pawan and Karkare, Amey and Kar, Purushottam and Gulwani, Sumit},
 title = {Compilation Error Repair: For the Student Programs, from the Student Programs},
 booktitle = {Proceedings of the 40th International Conference on Software Engineering: Software Engineering Education and Training},
 series = {ICSE-SEET '18},
 year = {2018},
 isbn = {978-1-4503-5660-2},
 location = {Gothenburg, Sweden},
 pages = {78--87},
 url = {http://doi.acm.org/10.1145/3183377.3183383},
 doi = {10.1145/3183377.3183383},
 acmid = {3183383},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automatic repair, compilation errors, intelligent tutoring systems, recommendation systems},
}

@inproceedings{barik2014developers,
 author={Titus Barik  and Kevin Lubick and Samuel Christie and Emerson Murphy-Hill},
 booktitle={2014 Second IEEE Working Conference on Software Visualization},
 title={How Developers Visualize Compiler Messages: A Foundational Approach to Notification Construction},
 year={2014},
 volume={},
 number={},
 pages={87-96},
 abstract={Self-explanation is one cognitive strategy through which developers comprehend error notifications. Self-explanation, when left solely to developers, can result in a significant loss of productivity because humans are imperfect and bounded in their cognitive abilities. We argue that modern IDEs offer limited visual affordances for aiding developers with self-explanation, because compilers do not reveal their reasoning about the causes of errors to the developer. The contribution of our paper is a foundational set of visual annotations that aid developers in better comprehending error messages when compilers expose their internal reasoning. We demonstrate through a user study of 28 undergraduate Software Engineering students that our annotations align with the way in which developers self-explain error notifications. We show that these annotations allow developers to give significantly better self-explanations when compared against today's dominant visualization paradigm, and that better self-explanations yield better mental models of notifications. The results of our work suggest that the diagrammatic techniques developers use to explain problems can serve as an effective foundation for how IDEs should visually communicate to developers.},
 keywords={data visualisation;program compilers;programming environments;compiler message visualization;error notifications;self-explanation;IDEs;visual annotations;undergraduate software engineering students;diagrammatic techniques;Visualization;Java;Cognition;Cognitive science;Software engineering;Programming;Computers},
 doi={10.1109/VISSOFT.2014.24},
 ISSN={},
 month={Sep.},
 publisher={IEEE},
 address={},
}

@article{gregor2006concepts,
abstract = {Concepts are structured mental representations with subpropositional content. Concepts enter into various psychological processes, including, for example, processes of categorization and reasoning. Theories of concepts are directed to explaining, among other things, the character of these processes, the structure of the representations involved, and the content that they have. We distinguish four broad approaches to the study of concepts - (1) the classical theory, (2) probabilistic theories, (3) the theory-theory, and (4) conceptual atomism - highlighting some of the issues that arise for these accounts. {\textcopyright} 2006 Elsevier Ltd. All rights reserved.},
author = {Gregor, D. and Jarvi, J. and Siek, J. and Stroustrup, B. and {Dos Reis}, G. and Lumsdaine, A.},
doi = {10.1007/978-1-4614-7822-5_2},
file = {::},
isbn = {1595933484},
issn = {21915776},
journal = {OOPSLA '06 Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
keywords = {Index term,Resource description framework,Semantic relation,Uniform resource identifier,Vector space model},
number = {9781461478218},
pages = {291--310},
title = {{Concepts: Linguistic Support for Generic Programming in C++}},
year = {2006}
}

@inproceedings{becker2016new,
 abstract = {Encountering the same compiler error repeatedly, particularly several times consecutively, has been cited as a strong indicator that a student is struggling with important programming concepts. Despite this, there are relatively few studies which investigate repeated errors in isolation or in much depth. There are also few data-driven metrics for measuring programming performance, and fewer for measuring repeated errors. This paper makes two contributions. First we introduce a new metric to quantify repeated errors, the repeated error density (RED). We compare this to Jadud's Error Quotient (EQ), the most studied metric, and show that RED has advantages over EQ including being less context dependent, and being useful for short sessions. This allows us to answer two questions posited by Jadud in 2006 that have until now been unanswered. Second, we compare the EQ and RED scores using data from an empirical control/intervention group study involving an editor which enhances compiler error messages. This intervention group has been previously shown to have a reduced overall number of student errors, number of errors per student, and number of repeated student errors per compiler error message. In this research we find a reduction in EQ, providing further evidence that error message enhancement has positive effects. In addition we find a significant reduction in RED providing evidence that this metric is valid.},
 annote = {- The paper is not about error messages, but about repetitions of errors.},
 mendeley-tags = {empirical,performance},
 author = {Becker, Brett A.},
 title = {A New Metric to Quantify Repeated Compiler Errors for Novice Programmers},
 booktitle = {Proceedings of the 21st ACM Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '16},
 year = {2016},
 isbn = {978-1-4503-4231-5},
 location = {Arequipa, Peru},
 pages = {296--301},
 url = {http://doi.acm.org/10.1145/2899415.2899463},
 doi = {10.1145/2899415.2899463},
 acmid = {2899463},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compiler errors, consecutive errors, cs1, debugging, eq, error messages, error quotient, errors, feedback, java, novice, programming, repeated errors, syntax errors},
}

@article{xinogalos2006introduction,
 abstract = {The objects-first strategy to teaching programming has prevailed over the imperative-first and functional first strategies during the last decade. However, the objects-first strategy has created added difficulties to both the teaching and learning of programming. In an attempt to confront these difficulties and support the objects-first strategy we developed a novel programming environment, objectKarel, which uses the language Karel++. The design of objectKarel was based on the results of the extended research that has been carried out about novice programmers. What differentiates it from analogous environments is the fact that it combines features that have been used solely in them: incorporated e-lessons and hands-on activities; an easy to use structure editor for developing/editing programs; program animation; explanatory visualization; highly informative and friendly error messages; recordability. In this paper, we present the didactic rationale that dictated the design of objectKarel and the features of the environment, including the e-lessons. In addition, we present the results from the use of objectKarel in the classroom and the results of the students{\~{O}} assessment of the environment.},
 author = {Xinogalos, Stelios and Satratzemi, Maya and Dagdilelis, Vassilios},
 doi = {10.1016/j.compedu.2004.09.005},
 file = {::;::},
 issn = {03601315},
 journal = {Computers and Education},
 keywords = {Pedagogical issues,Programming and programming languages,Teaching/learning strategies,difficulties,empirical,enhancement,pedagogy,pre-guidelines},
 mendeley-tags = {difficulties,empirical,enhancement,pedagogy,pre-guidelines},
 number = {2},
 pages = {148--171},
 title = {{An Introduction to Object-Oriented Programming with a Didactic Microworld: objectKarel}},
 url = {www.elsevier.com/locate/compedu},
 volume = {47},
 year = {2006}
}

@inproceedings{campbell2014syntax,
abstract = {A frustrating aspect of software development is that compiler error messages often fail to locate the actual cause of a syntax error. An errant semicolon or brace can result in many errors reported throughout the file. We seek to find the actual source of these syntax errors by relying on the consistency of software: valid source code is usually repetitive and unsurprising. We exploit this consistency by constructing a simple N-gram language model of lexed source code tokens. We implemented an automatic Java syntax-error locator using the corpus of the project itself and evaluated its performance on mutated source code from several projects. Our tool, trained on the past versions of a project, can effectively augment the syntax error locations produced by the native compiler. Thus we provide a methodology and tool that exploits the naturalness of software source code to detect syntax errors alongside the parser.},
address = {Hyderabad, India},
author = {Campbell, Joshua Charles and Hindle, Abram and Amaral, Jos{\'{e}} Nelson},
booktitle = {Proceedings of the 11th Working Conference on Mining Software Repositories},
doi = {10.1145/2597073.2597102},
file = {::;::},
isbn = {9781450328630},
keywords = {NLP,enhancement,error location,language,n-grams,naturalness,syntax,tool},
mendeley-tags = {enhancement,tool},
number = {May},
pages = {252--261},
publisher = {ACM},
title = {{Syntax errors just aren't natural: improving error reporting with language models}},
year = {2014}
}
@article{Serrano2018Type,
abstract = {Embedded domain specific languages (DSLs) are a common pattern in the functional programming world, providing very high-level abstractions to programmer. Unfortunately, this abstraction is broken when type errors occur, leaking details of the DSL implementation. In this paper we present a set of techniques for customizing type error diagnosis in order to avoid this leaking. These techniques have been implemented in the GHC Haskell compiler. Our customizations are declared in the type signatures of functions provided by the DSL, leading to type error message that are context-dependent: the same kind of error can be reported in a different way depending on the particular expression in which it occurs. We make use of the ability to manipulate constraints using type-level programming which is already present in GHC, and which enables reuse and abstraction of common type error patterns.},
author = {Serrano, Alejandro and Hage, Jurriaan},
doi = {10.1145/3205368.3205370},
file = {::},
isbn = {9781450363433},
journal = {IFL 2017 Proceedings of the 29th Symposium on the Implementation and Application of Functional Programming Languages},
keywords = {enhancement},
mendeley-tags = {enhancement},
number = {2},
pages = {1--15},
title = {{Type Error Customization in GHC: Controlling expression-level type errors by type-level programming}},
year = {2018}
}

@inproceedings{elboustani2011improving,
 abstract = {Since version 1.5, generics (parametric polymorphism) are part of the Java language. However, the combination of parametric polymorphism and inclusion polymorphism is complicated, particularly so for Generic Java. Indeed, the main Java compilers, Eclipse's ejc and Sun's javac, do not even accept the same set of programs. Moreover, experience with these compilers shows that the error messages provided by them leave more than a little to be desired. To alleviate the latter problem, we describe how to adapt the type inference process of Java to obtain better error diagnostics for generic method invocations. Although the extension by itself already helps to improve type error messages to some extent, another major advantage of the new type inference process is that it also paves the way for further heuristics can provide additional diagnostic information. The extension has been implemented into the JastAdd Extensible Java Compiler.},
 address = {Savannah, GA},
 author = {El Boustani, Nabil and Hage, Jurriaan},
 booktitle = {Higher-Order and Symbolic Computation},
 doi = {10.1007/s10990-011-9070-3},
 file = {::;::},
 isbn = {9781605583273},
 issn = {13883690},
 keywords = {Compilers,Error diagnosis,Java generics,Type checking,compilers,enhancement,error reporting,technical,type checking},
 mendeley-tags = {enhancement,technical},
 pages = {3--39},
 title = {{Improving Type Error Messages for Generic Java}},
 volume = {24},
 year = {2011},
}

@inproceedings{lerner2007searching-duplicate,
 abstract = {Advanced type systems often need some form of type inference to reduce the burden of explicit typing, but type inference often leads to poor error messages for ill-typed programs. This work pursues a new approach to constructing compilers and presenting type-error messages in which the type-checker itself does not produce the messages. Instead, it is an oracle for a search procedure that finds similar programs that do type-check. Our two-fold goal is to improve error messages while simplifying compiler construction. Our primary implementation and evaluation is for Caml, a language with full type inference. We also present a prototype for C++ template functions, where type instantiation is implicit. A key extension is making our approach robust even when the program has multiple independent type errors.},
 author = {Lerner, Benjamin S. and Flower, Matthew and Grossman, Dan and Chambers, Craig},
 title = {Searching for Type-error Messages},
 booktitle = {Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '07},
 year = {2007},
 isbn = {978-1-59593-633-2},
 location = {San Diego, California, USA},
 pages = {425--434},
 url = {http://doi.acm.org/10.1145/1250734.1250783},
 doi = {10.1145/1250734.1250783},
 acmid = {1250783},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {error messages, objective Caml, seminal, type-checking, type-inference},
}

@article{kantorowitz1986automatic,
abstract = {Many current compilers produce in some situations wrong error messages that mislead the user and harm his confidence in the system. It is demonstrated that a reliable and efficient syntax error handling system may be produced automatically by a compiler generator from the BNF specification of the language, and without any effort by the language implementor. This result is achieved in three ways: (a) Some errors may not be diagnosed without knowledge of the intentions of the programmer. Some compilers employ a sophisticated analysis that attempts to capture these intentions, but which is not always successful. Such an elaborate analysis is not employed here, and instead a list of all the legal corrections is displayed, so that the programmer may readily select the right one. (b) The recovery symbols are selected by a careful' algorithm resulting in a high probability for correct error recovery. (c) The honest' error messages show also the parts of the code which could not be analysed correctly because of errors, and where more errors may exist. Efficiency is achieved by computing the recovery sets once and for all at compiler generation time, so that a fast error recovery at program compilation time is achieved. Experiments with erroneous programs suggest that the method compares well with the best compilers that we have seen, and is specially good at the avoidance of wrong error messages.},
author = {Kantorowitz, Eliezer and Laor, H.},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Kantorowitz, Laor - 1986 - Automatic Generation of Useful Syntax Error Messages.pdf:pdf},
journal = {Software: Practice and Experience},
keywords = {guidelines,justification,pre-guidelines,technical},
mendeley-tags = {guidelines,justification,pre-guidelines,technical},
number = {7},
pages = {627--640},
title = {{Automatic Generation of Useful Syntax Error Messages}},
volume = {16},
year = {1986}
}
@inproceedings{kummerfeld2003neglected,
 abstract = {Syntax error correction is an essential part of the debugging process. Yet there has been little research investigating how programmers approach syntax error correction and how to help beginner programmers learn to fix errors efficiently. This paper describes development and evaluation of a tool to support students learning how to correct syntax errors. We collected both quantitative and qualitative data for a small but varied group of students as they corrected syntax errors. This showed that even the more experienced students took significant time to correct some syntax errors. It also indicated that general and language specific programming experience provides both strategic skill in correcting errors and greater depth of understanding of the error messages themselves. At the same time, we observed that beginners can be almost as efficient as more expert users when they have access to our tool for explanations of the less intuitive compile error messages.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Kummerfeld, Kay - 2003 - The neglected battle fields of Syntax Errors.pdf:pdf},
 mendeley-tags = {empirical,enhancement,pre-guidelines},
 author = {Kummerfeld, Sarah K. and Kay, Judy},
 title = {The Neglected Battle Fields of Syntax Errors},
 booktitle = {Proceedings of the Fifth Australasian Conference on Computing Education - Volume 20},
 series = {ACE '03},
 year = {2003},
 isbn = {0-909925-98-4},
 location = {Adelaide, Australia},
 pages = {105--111},
 url = {http://dl.acm.org/citation.cfm?id=858403.858416},
 acmid = {858416},
 publisher = {Australian Computer Society, Inc.},
 address = {Darlinghurst, Australia, Australia},
}

@inproceedings{becker2018fix,
 abstract = {In order to help students learning to develop computer programs, several computing education researchers have analyzed the compiler error messages generated by novices' attempts to compile their programs. The goal is to help students diagnose the errors they make through the messages generated by the compiler. This paper builds on that previous work by applying a technique based on a heuristic well-known to programmers - fix the first error and ignore the rest - to the analysis of over 21 million compiler error messages from the Blackbox dataset. We find that the ranks and frequencies obtained by considering all error messages are generally consistent with previously published lists, but when we consider first messages only, these ranks and frequencies are different. These differences could have important implications for teaching, and can inform tool design and future research efforts.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Becker et al. - 2018 - Fix the First, Ignore the Rest Dealing with Multiple Compiler Error Messages.pdf:pdf},
 mendeley-tags = {difficulties,empirical,justification,pedagogy,pre-guidelines},
 author = {Becker, Brett A. and Murray, Cormac and Tao, Tianyi and Song, Changheng and McCartney, Robert and Sanders, Kate},
 title = {Fix the First, Ignore the Rest: Dealing with Multiple Compiler Error Messages},
 booktitle = {Proceedings of the 49th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '18},
 year = {2018},
 isbn = {978-1-4503-5103-4},
 location = {Baltimore, Maryland, USA},
 pages = {634--639},
 url = {http://doi.acm.org/10.1145/3159450.3159453},
 doi = {10.1145/3159450.3159453},
 acmid = {3159453},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, blackbox, buried error messages, cascading error messages, compiler error messages, debugging, novice programmers, novice syntax errors, subsequent error messages},
}

@inproceedings{hristova2004identifying,
 abstract = {Programming in Java can be a daunting task for introductory students, one that is only compounded by the cryptic compiler error messages they see when they first start to write actual code. This article details a project conducted by faculty and advanced students in the creation of an educational tool for Java programming, called Expresso. This paper discusses some existing programming tools, explains their drawbacks, and describes why Expresso is different. We also include a detailed list of typical errors made by novice programmers, used in the construction of the Expresso tool.},
 mendeley-tags = {enhancement,pedagogy,technical},
 author = {Hristova, Maria and Misra, Ananya and Rutter, Megan and Mercuri, Rebecca},
 title = {Identifying and Correcting Java Programming Errors for Introductory Computer Science Students},
 booktitle = {Proceedings of the 34th SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '03},
 year = {2003},
 isbn = {1-58113-648-X},
 location = {Reno, Navada, USA},
 pages = {153--156},
 url = {http://doi.acm.org/10.1145/611892.611956},
 doi = {10.1145/611892.611956},
 acmid = {611956},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, Java, logic, programming, semantics, syntax},
}

@inproceedings{pettit2017enhanced,
 abstract = {One common frustration students face when first learning to program in a compiled language is the difficulty in interpreting the compiler error messages they receive. Attempts to improve error messages have produced differing results. Two recently published papers showed conflicting results, with one showing measurable change in student behavior, and the other showing no measurable change. We conducted an experiment comparable to these two over the course of several semesters in a CS1 course. This paper presents our results in the context of previous work in this area. We improved the clarity of the compiler error messages the students receive, so that they may more readily understand their mistakes and be able to make effective corrections. Our goal was to help students better understand their syntax mistakes and, as a reasonable measure of our success, we expected to document a decrease in the number of times students made consecutive submissions with the same compilation error. By doing this, we could demonstrate that this enhancement is effective. After collecting and thoroughly analyzing our own experimental data, we found that--despite anecdotal stories, student survey responses, and instructor opinions testifying to the tool's helpfulness--enhancing compiler error messages shows no measurable benefit to students. Our results validate one of the existing studies and contradict another. We discuss some of the reasons for these results and conclude with projections for future research.},
 mendeley-tags = {empirical,enhancement,performance,pre-guidelines},
 author = {Pettit, Raymond S. and Homer, John and Gee, Roger},
 title = {Do Enhanced Compiler Error Messages Help Students?: Results Inconclusive.},
 booktitle = {Proceedings of the 2017 ACM SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '17},
 year = {2017},
 isbn = {978-1-4503-4698-6},
 location = {Seattle, Washington, USA},
 pages = {465--470},
 url = {http://doi.acm.org/10.1145/3017680.3017768},
 doi = {10.1145/3017680.3017768},
 acmid = {3017768},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automated assessment tools, automated feedback, computer aided instruction, computer science education, error messages},
}

@inproceedings{zhang2015diagnosing,
 abstract = {Type inference engines often give terrible error messages, and the more sophisticated the type system the worse the problem. We show that even with the highly expressive type system implemented by the Glasgow Haskell Compiler (GHC)-including type classes, GADTs, and type families-it is possible to identify the most likely source of the type error, rather than the first source that the inference engine trips over. To determine which are the likely error sources, we apply a simple Bayesian model to a graph representation of the typing constraints; the satisfiability or unsatisfiability of paths within the graph provides evidence for or against possible explanations. While we build on prior work on error diagnosis for simpler type systems, inference in the richer type system of Haskell requires extending the graph with new nodes. The augmentation of the graph creates challenges both for Bayesian reasoning and for ensuring termination. Using a large corpus of Haskell programs, we show that this error localization technique is practical and significantly improves accuracy over the state of the art.},
 mendeley-tags = {enhancement,technical},
 author = {Zhang, Danfeng and Myers, Andrew C. and Vytiniotis, Dimitrios and Peyton-Jones, Simon},
 title = {Diagnosing Type Errors with Class},
 booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '15},
 year = {2015},
 isbn = {978-1-4503-3468-6},
 location = {Portland, OR, USA},
 pages = {12--21},
 url = {http://doi.acm.org/10.1145/2737924.2738009},
 doi = {10.1145/2737924.2738009},
 acmid = {2738009},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Error diagnosis, Haskell, type inference},
}

@inproceedings{more2011web,
abstract = {One of the grand challenges in computing education is to teach programming to novice students. Typically, novices find it difficult to understand compiler error messages. Hence a prototype of web based programming assistance tool has been developed to assist them in the programming process. It is an online program development environment to help beginners to debug programs in C language. The debugger component assists to identify the errors and fix them. Hints will be provided to deal with the compiler error messages. The system comprises of a GUI editor, a GCC compiler and a central database. The database stores a list of almost all compiler error messages, and the corresponding fixes and hints. Based on the error messages generated after compilation, queries are sent to the database and the relevant fixes are presented to the programmer.},
author = {More, Anmol and Kumar, Jitendra and Renumol, V. G.},
booktitle = {Proceedings - IEEE International Conference on Technology for Education, T4E 2011},
doi = {10.1109/T4E.2011.55},
file = {::;:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley//More, Kumar, Renumol - 2011 - Web based programming assistance tool for novices.pdf:pdf},
isbn = {9780769545349},
keywords = {anecdotal,computer programming,debugging,enhancement,novice programmers,web based interface},
mendeley-tags = {anecdotal,enhancement},
title = {{Web based programming assistance tool for novices}},
year = {2011}
}

@inproceedings{nienaltowski2008compiler,
 abstract = {Novices find it difficult to understand and use compiler error messages. It is useful to refine this observation and study the effect of different message styles on how well and quickly students identify errors in programs. For example, does an increased level of detail simplify the understanding of errors and their correction? We analyzed messages produced by a number of compilers for five programming languages, and grouped them into three style categories from their level of detail and presentation format, and correlated the level of experience and error type with performance and speed of response. The study involved two groups of students taking an introductory programming course at two different institutions; they used messages in these three styles to debug erroneous code. The results indicate that more detailed messages do not necessarily simplify the understanding of errors but that it matters more where information is placed and how it is structured.},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Nienaltowski, Pedroni, Meyer - 2008 - Compiler error messages What can help novices.pdf:pdf},
 mendeley-tags = {difficulties,enhancement,justification,performance,pre-guidelines},
 author = {Nienaltowski, Marie-H{\'e}l\`{e}ne and Pedroni, Michela and Meyer, Bertrand},
 title = {Compiler Error Messages: What Can Help Novices?},
 booktitle = {Proceedings of the 39th SIGCSE Technical Symposium on Computer Science Education},
 series = {SIGCSE '08},
 year = {2008},
 isbn = {978-1-59593-799-5},
 location = {Portland, OR, USA},
 pages = {168--172},
 url = {http://doi.acm.org/10.1145/1352135.1352192},
 doi = {10.1145/1352135.1352192},
 acmid = {1352192},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compiler error messages, novice programmers},
}

@inproceedings{kadekar2018effects,
 abstract = {The role of error messages in the context of teaching programming, specifically assembly language programming to students who have limited prior programming experience was investigated. Assemblers and compilers provide feedback to a programmer in the form of error messages, and these error messages influence the programmer's mental model of computing. The current study investigated how an error message affects students' approach to understanding the error and fixing the error. Three error message types were developed - Default, Link and Example, to better understand the effects of error messages. The Default type provides an assembler-centric single line error message, the Link type provides a program-centric detailed error description with a hyperlink for more information, and the Example type provides a program-centric detailed error description with a relevant example. A think aloud programming exercise was conducted to capture the student programmer's knowledge model. Different codes were developed to analyze the data collected as part of think aloud exercise. After transcribing, coding, and analyzing the data, it was found that the Link type of error message helped to fix the error in less time and with fewer steps. Among the three types, the Link type of error message also resulted in a higher ratio of correct to incorrect hypotheses made by the participants, and a correspondingly higher ratio of correct to incorrect steps taken by them to fix the error.},
 author = {Kadekar, Harsha B M and Sohum, Sohoni and Craig, Scotty D},
 booktitle = {IEEE Frontiers in Education Conference},
 series = {FIE},
 isbn = {9781538611746},
 keywords = {component,empirical,formatting,insert,key,performance,pre-guidelines,style,styling},
 mendeley-tags = {empirical,performance,pre-guidelines},
 pages = {1--8},
 publisher = {IEEE},
 title = {{Effects of Error Messages on Students' Ability to Understand and Fix Programming Errors}},
 year = {2018}
}

@inproceedings{graham1973practical,
 abstract = {A substantial portion of any programmer's time is spent in debugging. One of the major services of any compiler ought to be to provide as much information as possible about compile-time errors in order to minimize the time required for debugging. A good error detection and recovery scheme should maximize the number of errors detected but minimize the number of times it reports an error when there is none. These spurious error detections and their associated error messages are usually engendered by an inappropriate recovery action.},
 mendeley-tags = {technical},
 author = {Graham, Susan L. and Rhodes, Steven P.},
 title = {Practical Syntactic Error Recovery in Compilers},
 booktitle = {Proceedings of the 1st Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
 series = {POPL '73},
 year = {1973},
 location = {Boston, Massachusetts},
 pages = {52--58},
 url = {http://doi.acm.org/10.1145/512927.512932},
 doi = {10.1145/512927.512932},
 acmid = {512932},
 publisher = {ACM},
 address = {New York, NY, USA},
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%External
%%NEW PAPERS **NOT** DIRECTLY RELATED TO PROGRAMMING ERROR MESSAGES CAN GO AT THE BOTTOM OF THIS SECTION (AND THEREFORE THE FILE) BETWEEN THE APPROPRIATE COMMENTS. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cognitive Load Theory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@article{ayres1990locus,
  ISSN = {00029556},
  URL = {http://www.jstor.org/stable/1423141},
  abstract = {Previous studies have suggested that the use of a means-ends problem-solving strategy imposes a heavy cognitive load which interferes with learning. In this article, we discuss some of the contributing factors. A computational model was used to suggest that cognitive load is at a maximum when subgoals are manipulated and calculated. This allowed us to predict that on two-move problems, most errors should occur during the calculation of the subgoal rather than the goal (labeled the stage effect). Experiment 1 supported this hypothesis using two-move geometry problems. Experiment 2 found that the presentation of unfamiliar problems tended to lead to the use of a means-ends strategy, and this strategy, in turn, increased the likelihood of the stage effect. Experiment 3 revealed that if the problem-solving environment was altered to reduce the likelihood of a means-ends strategy being used, error location became random. Experiment 4, using three-move problems, found that most errors were located at the subgoal immediately preceding the goal. Protocol analysis in Experiment 5 indicated that means-ends analysis also was most likely to be used at the subgoal immediatley preceding the goal. It was concluded that means-ends analysis imposes a heavy cognitive load during the calculation of subgoal stages and this may explain the detrimental effect of the strategy on learning.},
  author = {Paul Ayres and John Sweller},
  journal = {The American Journal of Psychology},
  number = {2},
  pages = {167--193},
  publisher = {University of Illinois Press},
  title = {Locus of Difficulty in Multistage Mathematics Problems},
  volume = {103},
  year = {1990}
}

@article{ayres2001systematic,
 title = "Systematic Mathematical Errors and Cognitive Load",
 journal = "Contemporary Educational Psychology",
 volume = "26",
 number = "2",
 pages = "227 - 248",
 year = "2001",
 issn = "0361-476X",
 doi = "https://doi.org/10.1006/ceps.2000.1051",
 url = "http://www.sciencedirect.com/science/article/pii/S0361476X00910518",
 author = "Paul L. Ayres",
 keywords = "Key Words: cognitive load, mathematical errors, working memory failure",
 abstract = "The hypothesis that the intrinsic nature of algebraic bracket tasks causes an uneven distribution of cognitive load during computation was tested in three experiments with grades 8 and 9 students. In Experiment 1, students were given problems which required two successive brackets to be expanded; each bracket required two operations (computations) to be completed. It was discovered that more errors were made during the calculation of the second bracket than the first, and more errors were made during the second operation than the first operation within each bracket. Verbal protocols collected in Experiment 2 indicated that most errors were caused by failures in working memory rather than poorly learned rules. In Experiment 3, a dual-task methodology showed that the cognitive nature of brackets affected working memory performance. It was concluded that the cognitive load experienced by problem solvers on these tasks varied across operations and caused the observed error pattern."
}

@inproceedings{shaffer2003applying,
 title={Applying Cognitive Load Theory to Computer Science Education.},
 author={Shaffer, Dale and Doube, Wendy and Tuovinen, Juhani},
 booktitle = {Proceedings of the 15th Annual Workshop of the Psychology of Programming Interest Group},
 series = {PPIG '03},
 pages     = {333-346},
 year      = {2003},
 url       = {http://ppig.org/library/paper/applying-cognitive-load-theory-computer-science-education},
 location = {Keele, UK},
}

@article{sweller1988cognitive,
  title={Cognitive Load During Problem Solving: Effects on Learning},
  author={Sweller, John},
  journal={Cognitive science},
  volume={12},
  number={2},
  pages={257--285},
  year={1988},
  publisher={Elsevier},
  url = {https://www.sciencedirect.com/science/article/pii/0364021388900237}
}

%***********************
% Metacognition and Scaffolding
%**********************
@article{etelapelto1993metacognition,
 author={Etel{\"a}pelto, Anneli},
 title = {Metacognition and the Expertise of Computer Program Comprehension},
 journal = {Scandinavian Journal of Educational Research},
 volume = {37},
 number = {3},
 pages = {243-254},
 year  = {1993},
 publisher = {Routledge},
 doi = {10.1080/0031383930370305},
 URL = {https://doi.org/10.1080/0031383930370305},
 abstract = { Abstract This study focuses on different components of metacognition and their role in the expertise of computer program comprehension. After the elaboration of the concepts of expertise and metacognition, expert and novice computer programmers are compared in terms of their metacognitive knowledge and the task‐specific awareness. Subject ( N = 24) with two different competence levels, novices and experts, were individually presented an updating program, written in COBOL language. The data about metacognition was mainly derived from subjects’ interviews and thinking‐aloud protocols. Results showed that experts were superior to the novices in their metacognitive knowledge of the program task and of the working strategies. Experts had a definite conception about an ideal working strategy, and they also seemed to work in accordance with this. Furthermore, experts had more adequate awareness of their working than novices. It is concluded that experts have a close interaction between metacognitive knowledge, task‐specific awareness and cognitive monitoring. Among novices, this kind of relationship could not be found. }
}

@inproceedings{mani2013incorporating,
 author = {Mani, Murali and Mazumder, Quamrul},
 title = {Incorporating Metacognition into Learning},
 booktitle = {Proceeding of the 44th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '13},
 year = {2013},
 isbn = {978-1-4503-1868-6},
 location = {Denver, Colorado, USA},
 pages = {53--58},
 url = {http://doi.acm.org/10.1145/2445196.2445218},
 doi = {10.1145/2445196.2445218},
 acmid = {2445218},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {active learning, metacognition, regression},
}

@inproceedings{loksa2016programming,
 author = {Loksa, Dastyni and Ko, Amy J. and Jernigan, Will and Oleson, Alannah and Mendez, Christopher J. and Burnett, Margaret M.},
 title = {Programming, Problem Solving, and Self-Awareness: Effects of Explicit Guidance},
 booktitle = {Proceedings of the 2016 CHI Conference on Human Factors in Computing Systems},
 series = {CHI '16},
 year = {2016},
 isbn = {978-1-4503-3362-7},
 location = {San Jose, California, USA},
 pages = {1449--1461},
 url = {http://doi.acm.org/10.1145/2858036.2858252},
 doi = {10.1145/2858036.2858252},
 acmid = {2858252},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {computer science education, metacognition, problem-solving, programming},
}

%***********************


@misc{Kitchenham_2007,
 author={B. Kitchenham and S. Charters},
 journal={School Comput. Sci. Math., Keele Univ., Keele, U.K., Rep. EBSE-2007-01},
 title={Guidelines for Performing Systematic Literature Reviews in Software Engineering, version 2.3},
 year={2007},
}

@article{Medeiros_2019,
author={R. P. {Medeiros} and G. L. {Ramalho} and T. P. {Falc\~{a}o}},
journal={IEEE Transactions on Education},
title={A Systematic Literature Review on Teaching and Learning Introductory Programming in Higher Education},
year={2019},
volume={62},
number={2},
pages={77-90},
keywords={computer aided instruction;computer science education;educational courses;further education;programming;programming languages;teaching;personalized teaching;systematic literature review;learning introductory programming;higher education;introductory programming learning;teaching introductory programming;novice student;problem solving;programming languages syntax;Programming profession;Education;Systematics;Tools;Bibliographies;Manuals;Achievement;faculty development;higher education;introductory programming;STEM;student experience;systematic review},
doi={10.1109/TE.2018.2864133},
ISSN={0018-9359},
month={May},}

@article{Brereton_2007,
 author = {Brereton, Pearl and Kitchenham, Barbara A. and Budgen, David and Turner, Mark and Khalil, Mohamed},
 title = {Lessons from Applying the Systematic Literature Review Process Within the Software Engineering Domain},
 journal = {J. Syst. Softw.},
 issue_date = {April, 2007},
 volume = {80},
 number = {4},
 month =  Apr,
 year = {2007},
 issn = {0164-1212},
 pages = {571--583},
 url = {http://dx.doi.org/10.1016/j.jss.2006.07.009},
 doi = {10.1016/j.jss.2006.07.009},
 acmid = {1226109},
 publisher = {Elsevier Science Inc.},
 address = {New York, NY, USA},
 keywords = {Empirical software engineering, Systematic literature review},
} 


@book{lidwell2010universal,
  title={Universal Principles of Design, Revised and Updated: 125 Ways to Enhance Usability, Influence Perception, Increase Appeal, Make Better Design Decisions, and Teach through Design},
  author={Lidwell, William and Holden, Kritina and Butler, Jill},
  year={2010},
  publisher={Rockport Publishers}
}

@book{shneiderman2004designing,
 author = {Shneiderman, Ben and Plaisant, Catherine},
 title = {Designing the User Interface: Strategies for Effective Human-Computer Interaction},
 year = {2004},
 edition = {4th},
 publisher = {Pearson Addison Wesley},
 isbn = {0321197860},
} 

@article{fisher2002clubhouse,
 author = {Fisher, Allan and Margolis, Jane},
 title = {Unlocking the Clubhouse: The Carnegie Mellon Experience},
 journal = {SIGCSE Bull.},
 issue_date = {June 2002},
 volume = {34},
 number = {2},
 month = Jun,
 year = {2002},
 issn = {0097-8418},
 pages = {79--83},
 url = {http://doi.acm.org/10.1145/543812.543836},
 doi = {10.1145/543812.543836},
 acmid = {543836},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

@inproceedings{luxton-reilly2016learning,
 author = {Luxton-Reilly, Andrew},
 title = {Learning to Program is Easy},
 booktitle = {Proceedings of the 21st ACM Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '16},
 year = {2016},
 isbn = {978-1-4503-4231-5},
 location = {Arequipa, Peru},
 pages = {284--289},
 url = {http://doi.acm.org/10.1145/2899415.2899432},
 doi = {10.1145/2899415.2899432},
 acmid = {2899432},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {computer science education, cs1, curriculum, expectations, learning outcomes, novice, programming, standards},
} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%BEGIN NEW EXTERNAL PAPERS

@article{beelders2016influence,
author = {Beelders, T.R. and du Plessis, Jean-Pierre L.},
doi = {http://dx.doi.org/10.16910/jemr.9.1.1},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Beelders, du Plessis - 2016 - The influence of syntax highlighting on reading and comprehending code.pdf:pdf},
journal = {Journal of Eye Movement Research Beelders},
keywords = {code comprehension,eye-tracking,highlighting might assist,programmers the colour syntax,reading behaviour,realise,syntax highlighting,them more than they},
number = {1},
pages = {1--11},
title = {{The Influence of Syntax Highlighting on Reading and Comprehending Code}},
volume = {91},
year = {2016}
}

@article{sarkar2015impact,
abstract = {We present an empirical study investigating the effect of syntax highlighting on program comprehension and its interaction with programming experience. Quantitative data was captured from 10 human subjects using an eye tracker during a controlled, randomised, within-subjects study. We observe that syntax highlighting significantly improves task completion time, and that this effect becomes weaker with an increase in programming experience.},
author = {Sarkar, Advait},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Sarkar - 2015 - The Impact of Syntax Colouring on Program Comprehension.pdf:pdf},
journal = {Proceedings of the 26th Annual Conference of the Psychology of Programming Interest Group (PPIG '15)},
keywords = {b,d,editors,eye-tracking,gen-lit,pop-ii,pop-iii,pop-v,program comprehension},
mendeley-tags = {gen-lit},
pages = {49--58},
title = {{The Impact of Syntax Colouring on Program Comprehension}},
url = {http://www.ppig.org/library/paper/impact-syntax-colouring-program-comprehension},
year = {2015}
}

@article{gries1968use,
 author = {Gries, David},
 title = {Use of Transition Matrices in Compiling},
 journal = {Commun. ACM},
 issue_date = {Jan. 1968},
 volume = {11},
 number = {1},
 month = jan,
 year = {1968},
 issn = {0001-0782},
 pages = {26--34},
 OPTnumpages = {9},
 url = {http://doi.acm.org/10.1145/362851.362872},
 doi = {10.1145/362851.362872},
 acmid = {362872},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compilation, context-free language, formal language, grammar, parsing, transition matrices, translation},
}

@article{wirth1968pl360,
 author = {Wirth, Niklaus},
 title = {PL360, a Programming Language for the 360 Computers},
 journal = {J. ACM},
 issue_date = {Jan. 1968},
 volume = {15},
 number = {1},
 month = jan,
 year = {1968},
 issn = {0004-5411},
 pages = {37--74},
 url = {http://doi.acm.org/10.1145/321439.321442},
 doi = {10.1145/321439.321442},
 acmid = {321442},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

@phdthesis{leinius1970error,
 author = {Leinius, Ronald Paul},
 title = {Error Detection and Recovery for Syntax Directed Compiler Systems},
 year = {1970},
 note = {AAI7024758},
 publisher = {The University of Wisconsin - Madison},
} 

@inproceedings{karvelas2019investigating,
 author = {Karvelas, Ioannis},
 title = {Investigating Novice Programmers' Interaction with Programming Environments},
 booktitle = {Proceedings of the 2019 ACM Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '19},
 year = {2019},
 isbn = {978-1-4503-6895-7},
 location = {Aberdeen, Scotland Uk},
 pages = {336--337},
 url = {http://doi.acm.org/10.1145/3304221.3325596},
 doi = {10.1145/3304221.3325596},
 acmid = {3325596},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compiler error messages, cs1, educational data mining, novice programmers, programming, programming process data},
} 

@article{sime1977structuring,
 abstract = {Computer programming could be made easier. This paper gives a short account of the authors' empirical studies of programming, showing that very considerable improvements can be obtained both for beginners and for professionals. The improvements are related to, though not wholly dependent on, the new concepts of 'structured programming'; we have found ways to improve both the programming language itself and the procedures used by the programmer. Psychological explanations of the effects are offered and the limitations of present findings are noted.},
 author = {Sime, M. E. and Arblaster, A. T. and Green, T. R.},
 doi = {10.1111/j.2044-8325.1977.tb00376.x},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/SIME, ARBLASTER, GREEN - 1977 - Structuring the programmer's task.pdf:pdf},
 issn = {03058107},
 journal = {Journal of Occupational Psychology},
 keywords = {justification},
 mendeley-tags = {justification},
 month = {sep},
 number = {3},
 pages = {205--216},
 title = {{Structuring the Programmer's Task}},
 url = {http://doi.wiley.com/10.1111/j.2044-8325.1977.tb00376.x},
 volume = {50},
 year = {1977}
}

@inproceedings{watson2014no,
 author = {Watson, Christopher and Li, Frederick W.B. and Godwin, Jamie L.},
 title = {No Tests Required: Comparing Traditional and Dynamic Predictors of Programming Success},
 booktitle = {Proceedings of the 45th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '14},
 year = {2014},
 isbn = {978-1-4503-2605-6},
 location = {Atlanta, Georgia, USA},
 pages = {469--474},
 url = {http://doi.acm.org/10.1145/2538862.2538930},
 doi = {10.1145/2538862.2538930},
 acmid = {2538930},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, error quotient, learning strategies, learning styles, prediction, predictors of success, programming behavior, watwin},
} 

@article{rice1953classes,
 ISSN = {00029947},
 URL = {http://www.jstor.org/stable/1990888},
 author = {H. G. Rice},
 journal = {Transactions of the American Mathematical Society},
 number = {2},
 pages = {358--366},
 publisher = {American Mathematical Society},
 title = {Classes of Recursively Enumerable Sets and Their Decision Problems},
 volume = {74},
 year = {1953}
}

@techreport{iso2011cpp,
 key = {ISO/IEC 14882:2011},
 title = {Information Technology \textendash\ Programming languages \textendash\ {C++}},
 year = {2011},
 url = {https://www.iso.org/standard/50372.html},
 OPTnumber = {ISO/IEC 14882:2011},
 OPTinstitution = {ISO/IEC JTC 1/SC 22/WG 21}
}

@techreport{iso2015cpp,
 key = {ISO/IEC TS 19217:2015},
 title = {Information Technology \textendash\ Programming Languages \textendash\ {C++} Extensions for Concepts},
 year = {2015},
 url = {https://www.iso.org/standard/64031.html},
 OPTnumber = {TS 19217:2015},
 OPTinstitution = {ISO/IEC JTC 1/SC 22/WG 21}
}

@inproceedings{zeller1999today,
 author = {Zeller, Andreas},
 title = {Yesterday, My Program Worked. Today, It Does Not. Why?},
 booktitle = {Proceedings of the 7th European Software Engineering Conference Held Jointly with the 7th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
 series = {ESEC/FSE '99},
 year = {1999},
 isbn = {3-540-66538-2},
 location = {Toulouse, France},
 pages = {253--267},
 url = {http://dl.acm.org/citation.cfm?id=318773.318946},
 acmid = {318946},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
}

@article{lee1998proofs,
 author = {Lee, Oukseh and Yi, Kwangkeun},
 title = {Proofs About a Folklore Let-polymorphic Type Inference Algorithm},
 journal = {ACM Trans. Program. Lang. Syst.},
 issue_date = {July 1998},
 volume = {20},
 number = {4},
 month = jul,
 year = {1998},
 issn = {0164-0925},
 pages = {707--723},
 url = {http://doi.acm.org/10.1145/291891.291892},
 doi = {10.1145/291891.291892},
 acmid = {291892},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {type error, type inference algorithm},
}

@inproceedings{schilling2011constraintfree,
 author = {Schilling, Thomas},
 title = {Constraint-Free Type Error Slicing},
 booktitle = {Proceedings of the 12th International Conference on Trends in Functional Programming},
 series = {TFP'11},
 year = {2012},
 isbn = {978-3-642-32036-1},
 location = {Madrid, Spain},
 pages = {1--16},
 url = {http://dx.doi.org/10.1007/978-3-642-32037-8_1},
 doi = {10.1007/978-3-642-32037-8_1},
 acmid = {2362965},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
}

@inproceedings{brassel2004typehope,
  title={Typehope: There is Hope for Your Type Errors},
  author={Bra{\ss}el, Bernd},
  booktitle={Int. Workshop on Implementation of Functional Languages},
  year={2004}
}
%%END NEW EXTERNAL PAPERS%%%%%%%%%%%%%%%%%%%%%%%%%%

@misc{nesbitt2017how, 
 title={How to Write Better Error Messages}, url={https://opensource.com/article/17/8/write-effective-error-messages},
 journal={Opensource.com}, 
 author={Nesbitt, Scott}, 
 year={2017}, 
 month={Aug}}
 
@misc{mulder2016awesome, 
 title={Awesome Error Messages for Dotty}, url={https://www.scala-lang.org/blog/2016/10/14/dotty-errors.html}, 
 journal={Awesome error messages for Dotty}, 
 author={Mulder, F},
 year={2016},
 month={Oct}}
 
@inproceedings{bhatia2016automated,
 abstract = {We present a technique for providing feedback on syntax errors that uses Recurrent neural networks (RNNs) to model syntactically valid token sequences. Syntax errors constitute one of the largest classes of errors (34\%) in our dataset of student submissions obtained from a MOOC courseon edX. For a given programming assignment, we first learn an RNN to model all valid token sequences using the set of syntactically correct submissions. Then, for a student submission with syntax errors, we query the learnt RNN model with the preïfix token sequence to predict token sequences that can fix the error by either replacing or inserting the predicted token sequence at the error location. We evaluate our technique on over 14,000 student submissions with syntax errors.},
 author = {Bhatia, Sahil and Singh, Rishabh},
 booktitle = {2nd Indian Workshop on Machine Learning},
 series = {IWML '16},
 file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Bhatia, Singh - 2016 - Automated Correction for Syntax Errors in Programming Assignments using Recurrent Neural Networks.pdf:pdf},
 keywords = {errors-only,justification,pedagogy},
 mendeley-tags = {errors-only,justification,pedagogy},
 title = {{Automated Correction for Syntax Errors in Programming Assignments using Recurrent Neural Networks}},
 url = {https://www2.cse.iitk.ac.in/~iwml/2016/papers/iWML_2016_paper_5.pdf},
 year = {2016}
}

@article{teitelbaum1981cornell,
author = {Teitelbaum, Tim and Reps, Thomas},
doi = {10.1145/358746.358755},
issn = {00010782},
journal = {Communications of the ACM},
month = {sep},
number = {9},
pages = {563--573},
title = {{The Cornell Program Synthesizer: A Syntax-Directed Programming Environment}},
url = {http://portal.acm.org/citation.cfm?doid=358746.358755},
volume = {24},
year = {1981}
}
 
@article{teitelman1981interlisp,
  title={The Interlisp Programming Environment},
  author={Teitelman, Warren and Masinter, Larry},
  journal={Computer},
  volume={14}, 
  number={4},
  pages={25--33},
  year={1981},
  keywords={Programming environments;Costs;Computer languages;Artificial intelligence;Error correction;Speech;Program processors;Operating systems;Educational institutions;Diseases}, 
  doi={10.1109/C-M.1981.220410}, 
  publisher={IEEE}
} 

@inproceedings{altadmri2016cost,
 author = {Altadmri, Amjad and Kolling, Michael and Brown, Neil C. C.},
 booktitle = {2016 IEEE 40th Annual Computer Software and Applications Conference},
 series = {COMPSAC '16},
 doi = {10.1109/COMPSAC.2016.204},
 isbn = {978-1-4673-8845-0},
 month = {jun},
 pages = {748--753},
 publisher = {IEEE},
 title = {{The Cost of Syntax and How to Avoid It: Text versus Frame-Based Editing}},
 url = {http://ieeexplore.ieee.org/document/7552099/},
 year = {2016}
}

@inproceedings{perkins1986fragile,
 author = {Perkins, D. N. and Martin, Fay},
 title = {Fragile Knowledge and Neglected Strategies in Novice Programmers},
 booktitle = {Papers Presented at the First Workshop on Empirical Studies of Programmers on Empirical Studies of Programmers},
 year = {1986},
 isbn = {0-89391-388-X},
 location = {Washington, D.C., USA},
 pages = {213--229},
 url = {http://dl.acm.org/citation.cfm?id=21842.28896},
 acmid = {28896},
 publisher = {Ablex Publishing Corp.},
 address = {Norwood, NJ, USA},
} 

@incollection{eisenstadt2018errors,
  title={Errors in an Interactive Programming Environment: Causes and Cures},
  author={Eisenstadt, Marc and Lewis, Matthew W.},
  booktitle={Novice Programming Environments},
  editor = {Eisenstadt, Mark and Keane, Mark T. and Rajan, Tim},
  pages={111--131},
  chapter = {5},
  address ={London},
  year={2018},
  publisher={Routledge}
}

@inproceedings{brown2014blackbox,
 author = {Brown, Neil C. C. and K\"{o}lling, Michael and McCall, Davin and Utting, Ian},
 title = {Blackbox: A Large Scale Repository of Novice Programmers' Activity},
 booktitle = {Proceedings of the 45th ACM Technical Symposium on Computer Science Education},
 series = {SIGCSE '14},
 year = {2014},
 isbn = {978-1-4503-2605-6},
 location = {Atlanta, Georgia, USA},
 pages = {223--228},
 url = {http://doi.acm.org/10.1145/2538862.2538924},
 doi = {10.1145/2538862.2538924},
 acmid = {2538924},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {BlueJ, blackbox, data collection, programming education},
} 

@article{Kelleher2002,
abstract = {Alice2 is a programming environment designed for teaching programming through building 3D virtual worlds. Based on feedback from user tests, we have created a drag and drop programming system that allows users to experiment with the logic and programming structures taught in introductory programming classes without making syntax errors. While similar programming environments for beginners allow us-ers to experiment with only a few programming concepts, Alice2 allows users to experiment with conditionals, count loops, while loops, variables, parameters, and procedures.},
author = {Kelleher, Caitlin and Cosgrove, Dennis and Culyba, David},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Kelleher, Cosgrove, Culyba - 2002 - Alice2 programming without syntax errors.pdf:pdf},
journal = {User Interface Software and Technology - UIST 2002},
keywords = {novice programming environments},
pages = {3--4},
title = {{Alice2: Programming Without Syntax Errors}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.4640&rep=rep1&type=pdf},
year = {2002}
}

@book{harris1995literacy,
  title={The Literacy Dictionary: The Vocabulary of Reading and Writing.},
  author={Harris, Theodore L and Hodges, Richard E},
  year={1995},
  publisher={ERIC}
}

@article{dale1949concept,
  title={The Concept of Readability},
  author={Dale, Edgar and Chall, Jeanne S},
  journal={Elementary English},
  volume={26},
  number={1},
  pages={19--26},
  year={1949},
  publisher={JSTOR}
}

@article{mc1969smog,
  title={SMOG Grading -- A New Readability Formula},
  author={Mc Laughlin, G Harry},
  journal={Journal of reading},
  volume={12},
  number={8},
  pages={639--646},
  year={1969},
  publisher={JSTOR}
}

@book{dubay2007smart,
  title={Smart Language: Readers, Readability, and the Grading of Text.},
  author={DuBay, William H},
  year={2007},
  publisher={ERIC}
}

@article{fry2006readability,
  title={Readability: Reading Hall of Fame Book. Newark},
  author={Fry, Edward B},
  journal={DE: International Reading Association},
  year={2006}
}

@inproceedings{rafalski2019randomized,
 author = {Rafalski, Timothy and Uesbeck, P. Merlin and Panks-Meloney, Cristina and Daleiden, Patrick and Allee, William and Mcnamara, Amelia and Stefik, Andreas},
 title = {A Randomized Controlled Trial on the Wild Wild West of Scientific Computing with Student Learners},
 booktitle = {Proceedings of the 2019 ACM Conference on International Computing Education Research},
 series = {ICER '19},
 year = {2019},
 isbn = {978-1-4503-6185-9},
 location = {Toronto ON, Canada},
 pages = {239--247},
 url = {http://doi.acm.org/10.1145/3291279.3339421},
 doi = {10.1145/3291279.3339421},
 acmid = {3339421},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {programming languages, scientific computing, statistics education},
} 

@inproceedings{quille2018second,
 author = {Quille, Keith and Faherty, Roisin and Bergin, Susan and Becker, Brett A.},
 title = {Second Level Computer Science: The Irish K-12 Journey Begins},
 booktitle = {Proceedings of the 18th Koli Calling International Conference on Computing Education Research},
 series = {Koli Calling '18},
 year = {2018},
 isbn = {978-1-4503-6535-2},
 location = {Koli, Finland},
 pages = {22:1--22:5},
 articleno = {22},
 numpages = {5},
 url = {http://doi.acm.org/10.1145/3279720.3279742},
 doi = {10.1145/3279720.3279742},
 acmid = {3279742},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {AP Computer Science, Computer Science Education, Curriculum, High School, Introduction to Computer Science, K-12},
} 

@inproceedings{marwan2019impact,
 author = {Marwan, Samiha and Lytle, Nicholas and Williams, Joseph Jay and Price, Thomas},
 title = {The Impact of Adding Textual Explanations to Next-step Hints in a Novice Programming Environment},
 booktitle = {Proceedings of the 2019 ACM Conference on Innovation and Technology in Computer Science Education},
 series = {ITiCSE '19},
 year = {2019},
 isbn = {978-1-4503-6895-7},
 location = {Aberdeen, Scotland Uk},
 pages = {520--526},
 url = {http://doi.acm.org/10.1145/3304221.3319759},
 doi = {10.1145/3304221.3319759},
 acmid = {3319759},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {computer science education, intelligent tutoring systems, next step hints, textual hints},
} 

@techreport{bigrigg2003evaluation,
author = {Bigrigg, Michael W. and Bortz, Russell and Chandra, Shyamal and Reed, David and Sheehan, Jared and Smith, Sara},
booktitle = {ICES Carnegie Mellon University Technical Report 04-9-03},
file = {:C\:/Users/bbecker/Box/AA AAAUCD/Mendeley/Bigrigg et al. - 2003 - An Evaluation of the Usefulness of Compiler Error Messages.pdf:pdf},
keywords = {difficulties},
mendeley-tags = {difficulties},
title = {{An Evaluation of the Usefulness of Compiler Error Messages}},
url = {http://www.ices.cmu.edu/reports/040903.pdf},
year = {2003}
}


@inproceedings{Fincher_1999,
author={S. {Fincher}},
booktitle={FIE'99 Frontiers in Education. 29th Annual Frontiers in Education Conference. Designing the Future of Science and Engineering Education. Conference Proceedings (IEEE Cat. No.99CH37011},
title={What are we doing when we teach programming?},
year={1999},
volume={1},
number={},
pages={12A4/1-12A4/5 vol.1},
keywords={computer science education;teaching;programming;programming teaching;computer science;syntax-free approach;problem-solving approach;literacy approach;computation-as-interaction approach;preliminary taxonomic framework;Education;Computer science;Vehicles;Laboratories},
doi={10.1109/FIE.1999.839268},
ISSN={},
month={Nov}
}

@inproceedings{Ettles_2018_CLE,
 author = {Ettles, Andrew and Luxton-Reilly, Andrew and Denny, Paul},
 title = {Common Logic Errors Made by Novice Programmers},
 booktitle = {Proceedings of the 20th Australasian Computing Education Conference},
 series = {ACE '18},
 year = {2018},
 isbn = {978-1-4503-6340-2},
 location = {Brisbane, Queensland, Australia},
 pages = {83--89},
 numpages = {7},
 url = {http://doi.acm.org/10.1145/3160489.3160493},
 doi = {10.1145/3160489.3160493},
 acmid = {3160493},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CS1, logic errors, novice programmers},
} 

@inproceedings{Reestman_2019_NLE,
 author = {Reestman, Kyle and Dorn, Brian},
 title = {Native Language's Effect on Java Compiler Errors},
 booktitle = {Proceedings of the 2019 ACM Conference on International Computing Education Research},
 series = {ICER '19},
 year = {2019},
 isbn = {978-1-4503-6185-9},
 location = {Toronto ON, Canada},
 pages = {249--257},
 numpages = {9},
 url = {http://doi.acm.org/10.1145/3291279.3339423},
 doi = {10.1145/3291279.3339423},
 acmid = {3339423},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {blackbox, compiler error behavior, english as a second language},
}

@article{Mahmoud_2004_RIC,
 author = {Mahmoud, Qusay H. and Dobosiewicz, Wlodek and Swayne, David},
 title = {Redesigning Introductory Computer Programming with HTML, JavaScript, and Java},
 journal = {SIGCSE Bull.},
 issue_date = {March 2004},
 volume = {36},
 number = {1},
 month = mar,
 year = {2004},
 issn = {0097-8418},
 pages = {120--124},
 numpages = {5},
 url = {http://doi.acm.org/10.1145/1028174.971344},
 doi = {10.1145/1028174.971344},
 acmid = {971344},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {HTML, Java, JavaScript, programming for fun, retention},
} 

@book{ref1,
 author = {Abelson, Harold and Sussman, Gerald J.},
 title = {Structure and Interpretation of Computer Programs},
 year = {1996},
 isbn = {0262011530},
 edition = {2nd},
 publisher = {MIT Press},
 address = {Cambridge, MA, USA},
} 


@article{ref2,
 author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram},
 title = {The Structure and Interpretation of the Computer Science Curriculum},
 journal = {J. Funct. Program.},
 issue_date = {July 2004},
 volume = {14},
 number = {4},
 month = jul,
 year = {2004},
 issn = {0956-7968},
 pages = {365--378},
 numpages = {14},
 url = {http://dx.doi.org/10.1017/S0956796804005076},
 doi = {10.1017/S0956796804005076},
 acmid = {997813},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
 } 

@book{ref3,
 author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram},
 title = {How to Design Programs: An Introduction to Programming and Computing},
 year = {2001},
 isbn = {0-262-06218-6},
 publisher = {MIT Press},
 address = {Cambridge, MA, USA},
} 


@misc{ref4,
Author={Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram},
Title={How to Design Programs, Second Edition},
Url={http://www.ccs.neu.edu/home/matthias/HtDP2e/},
Lastchecked = {4/26/16},
}
